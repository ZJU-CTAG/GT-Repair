{
  "patch": "\n/**\n * Replace the provide statement.\n *\n * If we're providing a name with no definition, then create one.\n * If we're providing a name with a duplicate definition, then make sure\n * that definition becomes a declaration.\n */\nvoid replace() {\n    if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n    }\n\n    // Handle the case where there is a duplicate definition for an explicitly\n    // provided symbol.\n    if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node assignNode = candidateDefinition.getFirstChild();\n            Node nameNode = assignNode.getFirstChild();\n            if (nameNode.getType() == Token.NAME) {\n                // Need to convert this assign to a var declaration.\n                Node valueNode = nameNode.getNext();\n                assignNode.removeChild(nameNode);\n                assignNode.removeChild(valueNode);\n                nameNode.addChildToFront(valueNode);\n                Node varNode = new Node(Token.VAR, nameNode);\n                varNode.copyInformationFrom(candidateDefinition);\n                candidateDefinition.getParent().replaceChild(\n                        candidateDefinition, varNode);\n                nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n                compiler.reportCodeChange();\n                replacementNode = varNode;\n            }\n        }\n    } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n            firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n            // In this case, the name was implicitly provided by two independent\n            // modules. We need to move this code up to a common module.\n            int indexOfDot = namespace.lastIndexOf('.');\n            if (indexOfDot == -1) {\n                // Any old place is fine.\n                compiler.getNodeForCodeInsertion(minimumModule)\n                        .addChildToBack(replacementNode);\n            } else {\n                // Add it after the parent namespace.\n                ProvidedName parentName =\n                        providedNames.get(namespace.substring(0, indexOfDot));\n                Preconditions.checkNotNull(parentName);\n                Preconditions.checkNotNull(parentName.replacementNode);\n                parentName.replacementNode.getParent().addChildAfter(\n                        replacementNode, parentName.replacementNode);\n            }\n        }\n        if (explicitNode != null) {\n            explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n    }\n}\n",
  "index": 10,
  "validation": "plausible",
  "errors": [],
  "total_trigger": 1,
  "passing_trigger": 1,
  "total_relevant": 6,
  "failing_relevant": 0,
  "passing_tests": [
    "com.google.javascript.jscomp.ProcessClosurePrimitivesTest::testProvideInIndependentModules4"
  ],
  "failing_tests": [],
  "sum_entropy": -6.64470030708566,
  "mean_entropy": -0.012192110655203047
}