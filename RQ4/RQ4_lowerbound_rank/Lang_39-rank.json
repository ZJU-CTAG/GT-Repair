{
  "Lang_39_src/java/org/apache/commons/lang3/StringUtils.java_3557_3731": {
    "patches": [
      {
        "patch": "\n    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i = 0; i < searchList.length; i++) {\n            if (replacementList[i] != null) {\n                int greater = replacementList[i].length() - searchList[i].length();\n                if (greater > 0) {\n                    increase += 3 * greater; // assume 3 matches\n                }\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            if (replacementList[replaceIndex] != null) {\n                buf.append(replacementList[replaceIndex]);\n            }\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
        "index": 11,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -5.117198265483702,
        "mean_entropy": -0.003067864667556176,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "correct"
      },
      {
        "patch": "\n    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i = 0; i < searchList.length; i++) {\n            if (replacementList[i] != null && searchList[i] != null) {\n                int greater = replacementList[i].length() - searchList[i].length();\n                if (greater > 0) {\n                    increase += 3 * greater; // assume 3 matches\n                }\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            if (replacementList[replaceIndex] != null) {\n                buf.append(replacementList[replaceIndex]);\n            }\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
        "index": 46,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -6.664928402770593,
        "mean_entropy": -0.003979061732997368,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "correct"
      },
      {
        "patch": "\n    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i = 0; i < searchList.length; i++) {\n            if(replacementList[i] != null) {\n                int greater = replacementList[i].length() - searchList[i].length();\n                if (greater > 0) {\n                    increase += 3 * greater; // assume 3 matches\n                }\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            if (replacementList[replaceIndex] != null) {\n                buf.append(replacementList[replaceIndex]);\n            }\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
        "index": 22,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -9.804487419802816,
        "mean_entropy": -0.005877990059833822,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "correct"
      },
      {
        "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (replacementList[i] != null && replacementList[i].length() > searchList[i].length()) {\n                increase += 3 * (replacementList[i].length() - searchList[i].length());\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            if (replacementList[replaceIndex] != null) {\n                buf.append(replacementList[replaceIndex]);\n            }\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
        "index": 49,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -8.001518671495448,
        "mean_entropy": -0.010115699963963904,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "wrong"
      },
      {
        "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (replacementList[i] != null) {\n                int greater = replacementList[i].length() - searchList[i].length();\n                if (greater > 0) {\n                    increase += 3 * greater;\n                }\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            if (replacementList[replaceIndex] != null) {\n                buf.append(replacementList[replaceIndex]);\n            }\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
        "index": 12,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -8.28280740157554,
        "mean_entropy": -0.010431747357148037,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "wrong"
      },
      {
        "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (replacementList[i] != null) {\n                int greater = replacementList[i].length() - searchList[i].length();\n                if (greater > 0) {\n                    increase += 3 * greater; \n                }\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            if (replacementList[replaceIndex] != null) {\n                buf.append(replacementList[replaceIndex]);\n            }\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
        "index": 41,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -8.727771514728449,
        "mean_entropy": -0.01097832894934396,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "wrong"
      },
      {
        "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (replacementList[i] != null) {\n                int greater = replacementList[i].length() - searchList[i].length();\n                if (greater > 0) {\n                    increase += 3 * greater;\n                }\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            if (replacementList[replaceIndex] != null) {\n                buf.append(replacementList[replaceIndex]);\n            }\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
        "index": 39,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -9.657037022668217,
        "mean_entropy": -0.012162515141899517,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "wrong"
      },
      {
        "patch": "\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            int greater = replacementList[i] != null ? replacementList[i].length() - searchList[i].length() : 0;\n            if (greater > 0) {\n                increase += 3 * greater;\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            if (replacementList[replaceIndex] != null) {\n                buf.append(replacementList[replaceIndex]);\n            }\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
        "index": 17,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -10.846607096368603,
        "mean_entropy": -0.013712524774170167,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "wrong"
      },
      {
        "patch": "\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList,\n                                   boolean repeat, int timeToLive) {\n\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n\n    if (text == null || text.length() == 0 || searchList == null ||\n        searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n            searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        if (replacementList[i] != null && searchList[i] != null) {\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        if (replacementList[replaceIndex] != null) {\n            buf.append(replacementList[replaceIndex]);\n        }\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic duplicated above END\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\n",
        "index": 75,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -14.8613256144486,
        "mean_entropy": -0.014358768709612174,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "wrong"
      },
      {
        "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList,\n                                      boolean repeat, int timeToLive)\n    {\n\n        if (text == null || text.length() == 0 || searchList == null ||\n            searchList.length == 0 || replacementList == null || replacementList.length == 0)\n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                searchList[i].length() == 0 || replacementList[i] == null)\n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            int greater = replacementList[i] != null ? replacementList[i].length() - searchList[i].length() : 0;\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            if (replaceIndex != -1 && replacementList[replaceIndex] != null) {\n                buf.append(replacementList[replaceIndex]);\n            }\n\n            start = textIndex + (searchList[replaceIndex] != null ? searchList[replaceIndex].length() : 0);\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                    searchList[i].length() == 0 || replacementList[i] == null)\n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
        "index": 60,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -13.069787674916773,
        "mean_entropy": -0.016135540339403422,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "wrong"
      },
      {
        "patch": "\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n    int increase = 0;\n\n    for (int i = 0; i < searchList.length; i++) {\n        if (replacementList[i] != null) {\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \n            }\n        }\n    }\n\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        if (replacementList[replaceIndex] != null) {\n            buf.append(replacementList[replaceIndex]);\n        }\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\n",
        "index": 50,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -13.348686867466634,
        "mean_entropy": -0.01685440261043767,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "wrong"
      },
      {
        "patch": "\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList,\n                                      boolean repeat, int timeToLive)\n{\n\n    if (text == null || text.length() == 0 || searchList == null ||\n        searchList.length == 0 || replacementList == null || replacementList.length == 0)\n    {\n        return text;\n    }\n\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n            searchList[i].length() == 0 || replacementList[i] == null)\n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n    int increase = 0;\n\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i] != null ? replacementList[i].length() - searchList[i].length() : 0;\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        if (replacementList[replaceIndex] != null) {\n            buf.append(replacementList[replaceIndex]);\n        }\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                searchList[i].length() == 0 || replacementList[i] == null)\n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\n",
        "index": 38,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -13.487627211500508,
        "mean_entropy": -0.017269689131242646,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "wrong"
      },
      {
        "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] != null && replacementList[i] != null) {\n                int greater = replacementList[i].length() - searchList[i].length();\n                if (greater > 0) {\n                    increase += 3 * greater;\n                }\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            if (searchList[replaceIndex] != null && replacementList[replaceIndex] != null) {\n                buf.append(replacementList[replaceIndex]);\n            }\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
        "index": 10,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -14.580068936938023,
        "mean_entropy": -0.018000085107330893,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "correct"
      },
      {
        "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList,\n                                      boolean repeat, int timeToLive) {\n        \n        if (text == null || text.length() == 0 || searchList == null ||\n            searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n            return text;\n        }\n        \n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n        \n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n        \n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n        \n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n        \n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n        \n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n            \n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        \n        if (textIndex == -1) {\n            return text;\n        }\n        \n        int start = 0;\n        int increase = 0;\n        \n        for (int i = 0; i < searchList.length; i++) {\n            if (replacementList[i] != null && replacementList[i].length() > searchList[i].length()) {\n                increase += 3 * (replacementList[i].length() - searchList[i].length());\n            }\n        }\n        \n        increase = Math.min(increase, text.length() / 5);\n        \n        StringBuilder buf = new StringBuilder(text.length() + increase);\n        \n        while (textIndex != -1) {\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            if (replacementList[replaceIndex] != null) {\n                buf.append(replacementList[replaceIndex]);\n            }\n            \n            start = textIndex + searchList[replaceIndex].length();\n            \n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            \n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                    searchList[i].length() == 0 || replacementList[i] == null) {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n                \n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n        }\n        \n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        \n        if (!repeat) {\n            return result;\n        }\n        \n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
        "index": 62,
        "validation": "plausible",
        "errors": [],
        "total_trigger": 1,
        "passing_trigger": 1,
        "total_relevant": 19,
        "failing_relevant": 0,
        "passing_tests": [
          "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray"
        ],
        "failing_tests": [],
        "sum_entropy": -16.587329031528633,
        "mean_entropy": -0.02073416128941079,
        "pass_FIB_num": 19,
        "pass_FIB": [
          "Lang_39_n17.txt",
          "Lang_39_n5.txt",
          "Lang_39_n46.txt",
          "Lang_39_n14.txt",
          "Lang_39_n31.txt",
          "Lang_39_n2.txt",
          "Lang_39_n24.txt",
          "Lang_39_n8.txt",
          "Lang_39_n30.txt",
          "Lang_39_n35.txt",
          "Lang_39_n4.txt",
          "Lang_39_n10.txt",
          "Lang_39_n23.txt",
          "Lang_39_n16.txt",
          "Lang_39_n21.txt",
          "Lang_39_n41.txt",
          "Lang_39_n11.txt",
          "Lang_39_n42.txt",
          "Lang_39_n34.txt"
        ],
        "validation_wo": "plausible",
        "correctness": "wrong"
      }
    ]
  }
}