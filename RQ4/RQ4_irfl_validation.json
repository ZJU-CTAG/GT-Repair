{
  "Chart_9": [
    {
      "patch": "\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            // Fixed bug: Changed the condition to end < start instead of start < end\n            throw new IllegalArgumentException(\"Requires end >= start.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                // Fixed bug: Added a check to prevent index out of bounds\n                if (index < this.data.size()) {\n                    TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n                    TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                    try {\n                        copy.add(clone);\n                    } catch (SeriesException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -19.95569853288597,
      "mean_entropy": -0.06255704869243252
    },
    {
      "patch": "\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            // Changed the condition from end < start to end <= start\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                // Added a check to ensure index is within bounds\n                if (index < this.data.size()) {\n                    TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n                    TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                    try {\n                        copy.add(clone);\n                    } catch (SeriesException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -14.170360103403674,
      "mean_entropy": -0.04541782084424254
    },
    {
      "patch": "\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = 0; index < this.data.size(); index++) {\n                TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n                if (item.getPeriod().compareTo(this.getDataItem(start).getPeriod()) >= 0 &&\n                    item.getPeriod().compareTo(this.getDataItem(end).getPeriod()) <= 0) {\n                    TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                    try {\n                        copy.add(clone);\n                    } catch (SeriesException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -10.104857774654008,
      "mean_entropy": -0.031577680545793775
    },
    {
      "patch": "\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            // Fixing the bug here by changing the condition to end <= start\n            throw new IllegalArgumentException(\"Requires end >= start.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -10.241259757877518,
      "mean_entropy": -0.034953104975691186
    },
    {
      "patch": "\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            // Changed condition to end <= start to fix the bug\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -10.472310842065665,
      "mean_entropy": -0.036111416696778156
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                if (index >= this.data.size()) {\n                    break; // Avoid IndexOutOfBoundsException\n                }\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -8.37094232903342,
      "mean_entropy": -0.03146970800388504
    },
    {
      "patch": "\n/**\n * Creates a new instance by copying a subset of the data in this \n * collection.\n *\n * @param start  the index of the first item to copy.\n * @param end  the index of the last item to copy.\n *\n * @return A copy of a subset of the items.\n * \n * @throws CloneNotSupportedException if there is a cloning problem.\n */\npublic TimePeriodValues createCopy(int start, int end) \n    throws CloneNotSupportedException {\n\n    if (start > end) {\n        throw new IllegalArgumentException(\"Requires start <= end\");\n    }\n\n    TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n    copy.data = new ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = start; index <= end; index++) {\n            TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n            TimePeriodValue clone = (TimePeriodValue) item.clone();\n            try {\n                copy.add(clone);\n            }\n            catch (SeriesException e) {\n                System.err.println(\"Failed to add cloned item.\");\n            }\n        }\n    }\n    return copy;\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -6.715685437740231,
      "mean_entropy": -0.028822684282146915
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n        \n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                if (index >= this.data.size()) {\n                    break; // Stop if index is out of bounds\n                }\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -11.162704596695256,
      "mean_entropy": -0.04119079186972419
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end && index < this.data.size(); index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -4.827144435456174,
      "mean_entropy": -0.019155335061334024
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (!this.data.isEmpty()) {\n            for (int index = start; index <= end && index < this.data.size(); index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -7.779906184532134,
      "mean_entropy": -0.031370589453758604
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                } catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -6.283762402718032,
      "mean_entropy": -0.025648009807012373
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -4.483570405029731,
      "mean_entropy": -0.01822589595540541
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end && index < this.data.size(); index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -5.237574203616173,
      "mean_entropy": -0.0207840246175245
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -3.622685597766549,
      "mean_entropy": -0.014726364218563206
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end && index < this.data.size(); index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -4.827144435456174,
      "mean_entropy": -0.019155335061334024
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -4.868597197189928,
      "mean_entropy": -0.019791045517032226
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n        \n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n        \n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -6.7197888264862975,
      "mean_entropy": -0.02709592268744475
    },
    {
      "patch": "\n/**\n * Creates a new instance by copying a subset of the data in this \n * collection.\n *\n * @param start  the index of the first item to copy.\n * @param end  the index of the last item to copy.\n *\n * @return A copy of a subset of the items.\n * \n * @throws CloneNotSupportedException if there is a cloning problem.\n */\npublic TimePeriodValues createCopy(int start, int end) \n    throws CloneNotSupportedException {\n    if (start > end) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n\n    TimePeriodValues copy = (TimePeriodValues) super.clone();\n    copy.data = new ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = start; index <= end; index++) {\n            TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n            TimePeriodValue clone = (TimePeriodValue) item.clone();\n            try {\n                copy.add(clone);\n            } catch (SeriesException e) {\n                System.err.println(\"Failed to add cloned item.\");\n            }\n        }\n    }\n    return copy;\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -10.796069290927395,
      "mean_entropy": -0.04653478142641119
    },
    {
      "patch": "\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n        \n        if (start > end) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n        copy.data = new ArrayList();\n        \n        if (this.data.size() > 0) {\n            for (int index = start; index <= end && index < this.data.size(); index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                } catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        \n        return copy;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jfree.data.time.junit.TimeSeriesTests::testBug1864222\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222",
        [
          "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222"
        ]
      ],
      "sum_entropy": -8.107690185973148,
      "mean_entropy": -0.031920040102256485
    }
  ],
  "Cli_17": [],
  "Cli_26": [
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -0.9275412444866901,
      "mean_entropy": -0.010421811735805506
    },
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -0.9275412444866901,
      "mean_entropy": -0.010421811735805506
    },
    {
      "patch": "\n/**\n * Create an Option using the current settings\n *\n * @return the Option instance\n * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n */\npublic static Option create() throws IllegalArgumentException\n{\n    if (longopt == null)\n    {\n        OptionBuilder.reset();\n        throw new IllegalArgumentException(\"must specify longopt\");\n    }\n\n    return create(null);\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -2.8289361655886296,
      "mean_entropy": -0.03536170206985787
    },
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -0.9275412444866901,
      "mean_entropy": -0.010421811735805506
    },
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -0.9275412444866901,
      "mean_entropy": -0.010421811735805506
    },
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -0.9275412444866901,
      "mean_entropy": -0.010421811735805506
    },
    {
      "patch": "\n/**\n * Create an Option using the current settings\n *\n * @return the Option instance\n * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n */\npublic static Option create() throws IllegalArgumentException\n{\n    if (longopt == null)\n    {\n        OptionBuilder.reset();\n        throw new IllegalArgumentException(\"must specify longopt\");\n    }\n\n    return create(null);\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -2.8289361655886296,
      "mean_entropy": -0.03536170206985787
    },
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -0.9275412444866901,
      "mean_entropy": -0.010421811735805506
    },
    {
      "patch": "\n/**\n * Create an Option using the current settings\n *\n * @return the Option instance\n * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n */\npublic static Option create() throws IllegalArgumentException\n{\n    if (longopt == null)\n    {\n        OptionBuilder.reset();\n        throw new IllegalArgumentException(\"must specify longopt\");\n    }\n\n    Option option = create(null);\n    OptionBuilder.reset(); // Reset OptionBuilder to prevent unwanted settings\n    return option;\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -9.80120783307633,
      "mean_entropy": -0.0980120783307633
    },
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -0.9275412444866901,
      "mean_entropy": -0.010421811735805506
    },
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -0.9275412444866901,
      "mean_entropy": -0.010421811735805506
    },
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -0.9275412444866901,
      "mean_entropy": -0.010421811735805506
    },
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -0.89973906677538,
      "mean_entropy": -0.010109427716577303
    },
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -0.89973906677538,
      "mean_entropy": -0.010109427716577303
    },
    {
      "patch": "\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longOpt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longOpt\");\n        }\n\n        return create(null);\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways",
        [
          "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways"
        ]
      ],
      "sum_entropy": -2.3145951998664898,
      "mean_entropy": -0.026006687638949325
    }
  ],
  "Cli_29": [
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -1.1260134295231305,
      "mean_entropy": -0.005439678403493384
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -1.1260134295231305,
      "mean_entropy": -0.005439678403493384
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token); // Removed Util.stripLeadingAndTrailingQuotes() call\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -3.27174322622143,
      "mean_entropy": -0.014939466786399224
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -1.1260134295231305,
      "mean_entropy": -0.005439678403493384
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token); // Removed Util.stripLeadingAndTrailingQuotes() call\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -3.27174322622143,
      "mean_entropy": -0.014939466786399224
    },
    {
      "patch": "\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -3.3375939632082403,
      "mean_entropy": -0.019181574501196782
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -1.1260134295231305,
      "mean_entropy": -0.005439678403493384
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -1.1260134295231305,
      "mean_entropy": -0.005439678403493384
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token); // Remove Util.stripLeadingAndTrailingQuotes()\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -4.307149872035103,
      "mean_entropy": -0.01984861692182075
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -1.1260134295231305,
      "mean_entropy": -0.005439678403493384
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -1.1260134295231305,
      "mean_entropy": -0.005439678403493384
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token); // Removed Util.stripLeadingAndTrailingQuotes() call\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -3.27174322622143,
      "mean_entropy": -0.014939466786399224
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -1.1260134295231305,
      "mean_entropy": -0.005439678403493384
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token); // Removed Util.stripLeadingAndTrailingQuotes()\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -1.9403612163122501,
      "mean_entropy": -0.008941756757199309
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token); // Removed Util.stripLeadingAndTrailingQuotes()\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -1.9403612163122501,
      "mean_entropy": -0.008941756757199309
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token); // Removed Util.stripLeadingAndTrailingQuotes() call\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -3.27174322622143,
      "mean_entropy": -0.014939466786399224
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -0.8091453193906101,
      "mean_entropy": -0.003908914586428068
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -0.8091453193906101,
      "mean_entropy": -0.003908914586428068
    },
    {
      "patch": "\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n\n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -6.398490897502762,
      "mean_entropy": -0.037200528473853266
    },
    {
      "patch": "\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(token);\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes",
        [
          "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes"
        ]
      ],
      "sum_entropy": -0.8091453193906101,
      "mean_entropy": -0.003908914586428068
    }
  ],
  "Cli_32": [
    {
      "patch": "\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n            if (pos >= text.length() - 1) {\n                break;\n            }\n        }\n        return sb;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -8.063568297755188,
      "mean_entropy": -0.03042855961417052
    },
    {
      "patch": "\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            \n            if (pos >= text.length() - 1) {\n                break;\n            }\n        }\n        \n        return sb;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -5.906184569418522,
      "mean_entropy": -0.022120541458496335
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n            if (pos >= text.length() - 1) // Fixed the condition to prevent StringIndexOutOfBoundsException\n            {\n                return sb;\n            }\n        }\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -9.990637384567421,
      "mean_entropy": -0.02707489806115832
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            \n            if (pos >= text.length() - 1) {\n                break;\n            }\n        }\n        \n        return sb;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -5.33529628705442,
      "mean_entropy": -0.014697785914750468
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text) {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1) {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width) {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true) {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1) {\n                sb.append(text);\n                return sb;\n            }\n\n            if ((text.length() >= width) && (pos == nextLineTabStop - 1)) {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -7.128639524605489,
      "mean_entropy": -0.021536675300922927
    },
    {
      "patch": "\nprotected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1) {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    if (nextLineTabStop >= width) {\n        // stops infinite loop happening\n        nextLineTabStop = 1;\n    }\n\n    // all following lines must be padded with nextLineTabStop space characters\n    final String padding = createPadding(nextLineTabStop);\n\n    while (true) {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n\n        if (pos == -1) {\n            sb.append(text);\n            return sb;\n        }\n\n        if ((text.length() > width) && (pos == nextLineTabStop - 1)) {\n            pos = width;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (pos >= text.length()) {\n            break;\n        }\n    }\n\n    return sb;\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -9.949211246476876,
      "mean_entropy": -0.039796844985907506
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (pos < text.length())\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n\n        return sb;\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -3.8465411040074904,
      "mean_entropy": -0.011117170820830897
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n            if (pos >= text.length() - 1) // Fix: Change <= to <\n            {\n                break;\n            }\n        }\n        return sb;\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -12.017962790380418,
      "mean_entropy": -0.03256900485197945
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() >= width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -4.224433399831152,
      "mean_entropy": -0.01246145545672906
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n            if (pos >= text.length() - 1) // Fixed the condition to avoid StringIndexOutOfBoundsException\n            {\n                break;\n            }\n        }\n\n        return sb;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -9.478944466312422,
      "mean_entropy": -0.025481033511592532
    },
    {
      "patch": "\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n                return sb;\n            }\n\n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n            if (pos >= text.length() - 1) {\n                break;\n            }\n        }\n        \n        return sb;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -11.208479013949779,
      "mean_entropy": -0.04245635990132492
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n            if (pos >= text.length()) {\n                break;\n            }\n        }\n\n        return sb;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -6.530168644953419,
      "mean_entropy": -0.018291788921438148
    },
    {
      "patch": "\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n            // Fixing the bug reported: Change <= to <\n            if (text.length() < width && pos < nextLineTabStop - 1)\n            {\n                return sb;\n            }\n        }\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -19.265579419348917,
      "mean_entropy": -0.0683176575154217
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (pos < text.length())\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n\n        return sb;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -6.0894362595716185,
      "mean_entropy": -0.017599526761767684
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            if (pos >= text.length() - 1) {\n                break;\n            }\n        }\n        \n        return sb;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -6.32664694234342,
      "mean_entropy": -0.017476925255092323
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            \n            if (pos >= text.length() - 1) {\n                break;\n            }\n        }\n        return sb;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -6.705611304645421,
      "mean_entropy": -0.018523788134379618
    },
    {
      "patch": "\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (pos < text.length())\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n\n        return sb;\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -7.142459308316924,
      "mean_entropy": -0.02880023914643921
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            \n            if (pos >= text.length() - 1) {\n                break;\n            }\n        }\n        \n        return sb;\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -5.693221025443018,
      "mean_entropy": -0.01568380447780446
    },
    {
      "patch": "\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n            if (pos >= text.length() - 1) {\n                break;\n            }\n        }\n\n        return sb;\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
        [
          "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut",
          "org.apache.commons.cli.HelpFormatterTest::testFindWrapPos"
        ]
      ],
      "sum_entropy": -4.316661295385018,
      "mean_entropy": -0.011957510513531906
    }
  ],
  "Cli_8": [],
  "Closure_101": [
    {
      "patch": "\n//The fixed function:\nProcessClosurePrimitives(AbstractCompiler compiler,\n                           CheckLevel requiresLevel,\n                           boolean rewriteNewDateGoogNow) {\n    this.compiler = compiler;\n    this.moduleGraph = compiler.getModuleGraph();\n    this.requiresLevel = requiresLevel;\n    this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n\n    // goog is special-cased because it is provided in Closure's base library.\n    providedNames.put(GOOG,\n        new ProvidedName(GOOG, null, null, false /* implicit */));\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -5.577472981784751,
      "mean_entropy": -0.04892520159460308
    },
    {
      "patch": "\npublic ProcessClosurePrimitives(AbstractCompiler compiler, CheckLevel requiresLevel, boolean rewriteNewDateGoogNow) {\n    this.compiler = compiler;\n    this.moduleGraph = compiler.getModuleGraph();\n    this.requiresLevel = requiresLevel;\n    this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n\n    // goog is special-cased because it is provided in Closure's base library.\n    providedNames.put(GOOG, new ProvidedName(GOOG, null, null, false)); // Removed incorrect comment syntax\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -8.7568336912653,
      "mean_entropy": -0.07960757901150273
    },
    {
      "patch": "\npublic ProcessClosurePrimitives(AbstractCompiler compiler, CheckLevel requiresLevel, boolean rewriteNewDateGoogNow) {\n    this.compiler = compiler;\n    this.moduleGraph = compiler.getModuleGraph();\n    this.requiresLevel = requiresLevel;\n    this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n\n    // goog is special-cased because it is provided in Closure's base library.\n    providedNames.put(GOOG,\n        new ProvidedName(GOOG, null, null, false)); // Removed the incorrect comment syntax\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -9.851196349771996,
      "mean_entropy": -0.0879571102658214
    },
    {
      "patch": "\n  ProcessClosurePrimitives(AbstractCompiler compiler,\n                           CheckLevel requiresLevel,\n                           boolean rewriteNewDateGoogNow) {\n    this.compiler = compiler;\n    this.moduleGraph = compiler.getModuleGraph();\n    this.requiresLevel = requiresLevel;\n    this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n\n    // goog is special-cased because it is provided in Closure's base library.\n    providedNames.put(GOOG,\n        new ProvidedName(GOOG, null, null, false /* implicit */));\n  }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -4.1788454819559195,
      "mean_entropy": -0.03764725659419747
    },
    {
      "patch": "\npublic ProcessClosurePrimitives(AbstractCompiler compiler,\n                                 CheckLevel requiresLevel,\n                                 boolean rewriteNewDateGoogNow) {\n    this.compiler = compiler;\n    this.moduleGraph = compiler.getModuleGraph();\n    this.requiresLevel = requiresLevel;\n    this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n\n    providedNames.put(GOOG,\n        new ProvidedName(GOOG, null, null, false)); // changed false /* implicit */ to false\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -11.99180837103217,
      "mean_entropy": -0.12112937748517343
    },
    {
      "patch": "\nProcessClosurePrimitives(AbstractCompiler compiler,\n                         CheckLevel requiresLevel,\n                         boolean rewriteNewDateGoogNow) {\n  this.compiler = compiler;\n  this.moduleGraph = compiler.getModuleGraph();\n  this.requiresLevel = requiresLevel;\n  this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n\n  // goog is special-cased because it is provided in Closure's base library.\n  providedNames.put(GOOG,\n      new ProvidedName(GOOG, null, null, false /* implicit */));\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -6.924346205655624,
      "mean_entropy": -0.06352611197849196
    },
    {
      "patch": "\n  public ProcessClosurePrimitives(AbstractCompiler compiler,\n                                  CheckLevel requiresLevel,\n                                  boolean rewriteNewDateGoogNow) {\n    this.compiler = compiler;\n    this.moduleGraph = compiler.getModuleGraph();\n    this.requiresLevel = requiresLevel;\n    this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n\n    // goog is special-cased because it is provided in Closure's base library.\n    providedNames.put(GOOG,\n        new ProvidedName(GOOG, null, null, false /* implicit */));\n  }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -6.033050056166572,
      "mean_entropy": -0.05386651835863011
    },
    {
      "patch": "\n  private void initConfigFromFlags(\n      String[] args, PrintStream err)\n      throws CmdLineException {\n    // Args4j has a different format that the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n    for (String arg : args) {\n      Matcher matcher = argPattern.matcher(arg);\n      if (matcher.matches()) {\n        processedArgs.add(matcher.group(1));\n\n        String value = matcher.group(2);\n        Matcher quotesMatcher = quotesPattern.matcher(value);\n        if (quotesMatcher.matches()) {\n          processedArgs.add(quotesMatcher.group(1));\n        } else {\n          processedArgs.add(value);\n        }\n      } else {\n        processedArgs.add(arg);\n      }\n    }\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      parser.printUsage(err);\n      throw e;\n    }\n    getCommandLineConfig()\n        .setPrintTree(flags.print_tree)\n        .setComputePhaseOrdering(flags.compute_phase_ordering)\n        .setPrintAst(flags.print_ast)\n        .setPrintPassGraph(flags.print_pass_graph)\n        .setJscompDevMode(flags.jscomp_dev_mode)\n        .setLoggingLevel(flags.logging_level)\n        .setExterns(flags.externs)\n        .setJs(flags.js)\n        .setJsOutputFile(flags.js_output_file)\n        .setModule(flags.module)\n        .setVariableMapInputFile(flags.variable_map_input_file)\n        .setPropertyMapInputFile(flags.property_map_input_file)\n        .setVariableMapOutputFile(flags.variable_map_output_file)\n        .setCreateNameMapFiles(flags.create_name_map_files)\n        .setPropertyMapOutputFile(flags.property_map_output_file)\n        .setThirdParty(flags.third_party)\n        .setSummaryDetailLevel(flags.summary_detail_level)\n        .setOutputWrapper(flags.output_wrapper)\n        .setOutputWrapperMarker(flags.output_wrapper_marker)\n        .setModuleWrapper(flags.module_wrapper)\n        .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n        .setCreateSourceMap(flags.create_source_map)\n        .setJscompError(flags.jscomp_error)\n        .setJscompWarning(flags.jscomp_warning)\n        .setJscompOff(flags.jscomp_off)\n        .setDefine(flags.define)\n        .setCharset(flags.charset);\n  }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -2.386819715497103,
      "mean_entropy": -0.004339672209994733
    },
    {
      "patch": "\nprivate void initConfigFromFlags(\n    String[] args, PrintStream err)\n    throws CmdLineException {\n  // Args4j has a different format that the old command-line parser.\n  // So we use some voodoo to get the args into the format that args4j\n  // expects.\n  Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n  Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n  List<String> processedArgs = Lists.newArrayList();\n  for (String arg : args) {\n    Matcher matcher = argPattern.matcher(arg);\n    if (matcher.matches()) {\n      processedArgs.add(matcher.group(1));\n\n      String value = matcher.group(2);\n      Matcher quotesMatcher = quotesPattern.matcher(value);\n      if (quotesMatcher.matches()) {\n        processedArgs.add(quotesMatcher.group(1));\n      } else {\n        processedArgs.add(value);\n      }\n    } else {\n      processedArgs.add(arg);\n    }\n  }\n\n  CmdLineParser parser = new CmdLineParser(flags);\n  try {\n    parser.parseArgument(processedArgs.toArray(new String[] {}));\n  } catch (CmdLineException e) {\n    err.println(e.getMessage());\n    parser.printUsage(err);\n    throw e;\n  }\n  getCommandLineConfig()\n      .setPrintTree(flags.print_tree)\n      .setComputePhaseOrdering(flags.compute_phase_ordering)\n      .setPrintAst(flags.print_ast)\n      .setPrintPassGraph(flags.print_pass_graph)\n      .setJscompDevMode(flags.jscomp_dev_mode)\n      .setLoggingLevel(flags.logging_level)\n      .setExterns(flags.externs)\n      .setJs(flags.js)\n      .setJsOutputFile(flags.js_output_file)\n      .setModule(flags.module)\n      .setVariableMapInputFile(flags.variable_map_input_file)\n      .setPropertyMapInputFile(flags.property_map_input_file)\n      .setVariableMapOutputFile(flags.variable_map_output_file)\n      .setCreateNameMapFiles(flags.create_name_map_files)\n      .setPropertyMapOutputFile(flags.property_map_output_file)\n      .setThirdParty(flags.third_party)\n      .setSummaryDetailLevel(flags.summary_detail_level)\n      .setOutputWrapper(flags.output_wrapper)\n      .setOutputWrapperMarker(flags.output_wrapper_marker)\n      .setModuleWrapper(flags.module_wrapper)\n      .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n      .setCreateSourceMap(flags.create_source_map)\n      .setJscompError(flags.jscomp_error)\n      .setJscompWarning(flags.jscomp_warning)\n      .setJscompOff(flags.jscomp_off)\n      .setDefine(flags.define)\n      .setCharset(flags.charset);\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -2.8265946161120525,
      "mean_entropy": -0.0051580193724672495
    },
    {
      "patch": "\nprivate void initConfigFromFlags(\n    String[] args, PrintStream err)\n    throws CmdLineException {\n    // Args4j has a different format than the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n    for (String arg : args) {\n      Matcher matcher = argPattern.matcher(arg);\n      if (matcher.matches()) {\n        processedArgs.add(matcher.group(1));\n\n        String value = matcher.group(2);\n        Matcher quotesMatcher = quotesPattern.matcher(value);\n        if (quotesMatcher.matches()) {\n          processedArgs.add(quotesMatcher.group(1));\n        } else {\n          processedArgs.add(value);\n        }\n      } else {\n        processedArgs.add(arg);\n      }\n    }\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      parser.printUsage(err);\n      throw e;\n    }\n    getCommandLineConfig()\n        .setPrintTree(flags.print_tree)\n        .setComputePhaseOrdering(flags.compute_phase_ordering)\n        .setPrintAst(flags.print_ast)\n        .setPrintPassGraph(flags.print_pass_graph)\n        .setJscompDevMode(flags.jscomp_dev_mode)\n        .setLoggingLevel(flags.logging_level)\n        .setExterns(flags.externs)\n        .setJs(flags.js)\n        .setJsOutputFile(flags.js_output_file)\n        .setModule(flags.module)\n        .setVariableMapInputFile(flags.variable_map_input_file)\n        .setPropertyMapInputFile(flags.property_map_input_file)\n        .setVariableMapOutputFile(flags.variable_map_output_file)\n        .setCreateNameMapFiles(flags.create_name_map_files)\n        .setPropertyMapOutputFile(flags.property_map_output_file)\n        .setThirdParty(flags.third_party)\n        .setSummaryDetailLevel(flags.summary_detail_level)\n        .setOutputWrapper(flags.output_wrapper)\n        .setOutputWrapperMarker(flags.output_wrapper_marker)\n        .setModuleWrapper(flags.module_wrapper)\n        .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n        .setCreateSourceMap(flags.create_source_map)\n        .setJscompError(flags.jscomp_error)\n        .setJscompWarning(flags.jscomp_warning)\n        .setJscompOff(flags.jscomp_off)\n        .setDefine(flags.define)\n        .setCharset(flags.charset);\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -7.58600257545417,
      "mean_entropy": -0.013817855328696121
    },
    {
      "patch": "\n  private void initConfigFromFlags(\n      String[] args, PrintStream err)\n      throws CmdLineException {\n    // Args4j has a different format that the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n    for (String arg : args) {\n      Matcher matcher = argPattern.matcher(arg);\n      if (matcher.matches()) {\n        processedArgs.add(matcher.group(1));\n\n        String value = matcher.group(2);\n        Matcher quotesMatcher = quotesPattern.matcher(value);\n        if (quotesMatcher.matches()) {\n          processedArgs.add(quotesMatcher.group(1));\n        } else {\n          processedArgs.add(value);\n        }\n      } else {\n        processedArgs.add(arg);\n      }\n    }\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      parser.printUsage(err);\n      throw e;\n    }\n    getCommandLineConfig()\n        .setPrintTree(flags.print_tree)\n        .setComputePhaseOrdering(flags.compute_phase_ordering)\n        .setPrintAst(flags.print_ast)\n        .setPrintPassGraph(flags.print_pass_graph)\n        .setJscompDevMode(flags.jscomp_dev_mode)\n        .setLoggingLevel(flags.logging_level)\n        .setExterns(flags.externs)\n        .setJs(flags.js)\n        .setJsOutputFile(flags.js_output_file)\n        .setModule(flags.module)\n        .setVariableMapInputFile(flags.variable_map_input_file)\n        .setPropertyMapInputFile(flags.property_map_input_file)\n        .setVariableMapOutputFile(flags.variable_map_output_file)\n        .setCreateNameMapFiles(flags.create_name_map_files)\n        .setPropertyMapOutputFile(flags.property_map_output_file)\n        .setThirdParty(flags.third_party)\n        .setSummaryDetailLevel(flags.summary_detail_level)\n        .setOutputWrapper(flags.output_wrapper)\n        .setOutputWrapperMarker(flags.output_wrapper_marker)\n        .setModuleWrapper(flags.module_wrapper)\n        .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n        .setCreateSourceMap(flags.create_source_map)\n        .setJscompError(flags.jscomp_error)\n        .setJscompWarning(flags.jscomp_warning)\n        .setJscompOff(flags.jscomp_off)\n        .setDefine(flags.define)\n        .setCharset(flags.charset);\n  }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -2.386819715497103,
      "mean_entropy": -0.004339672209994733
    },
    {
      "patch": "\nprivate void initConfigFromFlags(\n    String[] args, PrintStream err)\n    throws CmdLineException {\n  Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n  Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n  List<String> processedArgs = Lists.newArrayList();\n  for (String arg : args) {\n    Matcher matcher = argPattern.matcher(arg);\n    if (matcher.matches()) {\n      processedArgs.add(matcher.group(1));\n\n      String value = matcher.group(2);\n      Matcher quotesMatcher = quotesPattern.matcher(value);\n      if (quotesMatcher.matches()) {\n        processedArgs.add(quotesMatcher.group(1));\n      } else {\n        processedArgs.add(value);\n      }\n    } else {\n      processedArgs.add(arg);\n    }\n  }\n\n  CmdLineParser parser = new CmdLineParser(flags);\n  try {\n    parser.parseArgument(processedArgs.toArray(new String[] {}));\n  } catch (CmdLineException e) {\n    err.println(e.getMessage());\n    parser.printUsage(err);\n    throw e;\n  }\n  getCommandLineConfig()\n      .setPrintTree(flags.print_tree)\n      .setComputePhaseOrdering(flags.compute_phase_ordering)\n      .setPrintAst(flags.print_ast)\n      .setPrintPassGraph(flags.print_pass_graph)\n      .setJscompDevMode(flags.jscomp_dev_mode)\n      .setLoggingLevel(flags.logging_level)\n      .setExterns(flags.externs)\n      .setJs(flags.js)\n      .setJsOutputFile(flags.js_output_file)\n      .setModule(flags.module)\n      .setVariableMapInputFile(flags.variable_map_input_file)\n      .setPropertyMapInputFile(flags.property_map_input_file)\n      .setVariableMapOutputFile(flags.variable_map_output_file)\n      .setCreateNameMapFiles(flags.create_name_map_files)\n      .setPropertyMapOutputFile(flags.property_map_output_file)\n      .setThirdParty(flags.third_party)\n      .setSummaryDetailLevel(flags.summary_detail_level)\n      .setOutputWrapper(flags.output_wrapper)\n      .setOutputWrapperMarker(flags.output_wrapper_marker)\n      .setModuleWrapper(flags.module_wrapper)\n      .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n      .setCreateSourceMap(flags.create_source_map)\n      .setJscompError(flags.jscomp_error)\n      .setJscompWarning(flags.jscomp_warning)\n      .setJscompOff(flags.jscomp_off)\n      .setDefine(flags.define)\n      .setCharset(flags.charset);\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -5.69631760391638,
      "mean_entropy": -0.011213223629756653
    },
    {
      "patch": "\nprivate void initConfigFromFlags(String[] args, PrintStream err) throws CmdLineException {\n    // Args4j has a different format than the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n    for (String arg : args) {\n        Matcher matcher = argPattern.matcher(arg);\n        if (matcher.matches()) {\n            processedArgs.add(matcher.group(1));\n\n            String value = matcher.group(2);\n            Matcher quotesMatcher = quotesPattern.matcher(value);\n            if (quotesMatcher.matches()) {\n                processedArgs.add(quotesMatcher.group(1));\n            } else {\n                processedArgs.add(value);\n            }\n        } else {\n            processedArgs.add(arg);\n        }\n    }\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    try {\n        parser.parseArgument(processedArgs.toArray(new String[] {}));\n    } catch (CmdLineException e) {\n        err.println(e.getMessage());\n        parser.printUsage(err);\n        throw e;\n    }\n\n    CommandLineConfig config = getCommandLineConfig();\n    config.setPrintTree(flags.print_tree)\n            .setComputePhaseOrdering(flags.compute_phase_ordering)\n            .setPrintAst(flags.print_ast)\n            .setPrintPassGraph(flags.print_pass_graph)\n            .setJscompDevMode(flags.jscomp_dev_mode)\n            .setLoggingLevel(flags.logging_level)\n            .setExterns(flags.externs)\n            .setJs(flags.js)\n            .setJsOutputFile(flags.js_output_file)\n            .setModule(flags.module)\n            .setVariableMapInputFile(flags.variable_map_input_file)\n            .setPropertyMapInputFile(flags.property_map_input_file)\n            .setVariableMapOutputFile(flags.variable_map_output_file)\n            .setCreateNameMapFiles(flags.create_name_map_files)\n            .setPropertyMapOutputFile(flags.property_map_output_file)\n            .setThirdParty(flags.third_party)\n            .setSummaryDetailLevel(flags.summary_detail_level)\n            .setOutputWrapper(flags.output_wrapper)\n            .setOutputWrapperMarker(flags.output_wrapper_marker)\n            .setModuleWrapper(flags.module_wrapper)\n            .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n            .setCreateSourceMap(flags.create_source_map)\n            .setJscompError(flags.jscomp_error)\n            .setJscompWarning(flags.jscomp_warning)\n            .setJscompOff(flags.jscomp_off)\n            .setDefine(flags.define)\n            .setCharset(flags.charset);\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -8.757461941476103,
      "mean_entropy": -0.01595166109558489
    },
    {
      "patch": "\nprivate void initConfigFromFlags(\n    String[] args, PrintStream err)\n    throws CmdLineException {\n  // Args4j has a different format that the old command-line parser.\n  // So we use some voodoo to get the args into the format that args4j\n  // expects.\n  Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n  Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n  List<String> processedArgs = Lists.newArrayList();\n  for (String arg : args) {\n    Matcher matcher = argPattern.matcher(arg);\n    if (matcher.matches()) {\n      processedArgs.add(matcher.group(1));\n\n      String value = matcher.group(2);\n      Matcher quotesMatcher = quotesPattern.matcher(value);\n      if (quotesMatcher.matches()) {\n        processedArgs.add(quotesMatcher.group(1));\n      } else {\n        processedArgs.add(value);\n      }\n    } else {\n      processedArgs.add(arg);\n    }\n  }\n\n  CmdLineParser parser = new CmdLineParser(flags);\n  try {\n    parser.parseArgument(processedArgs.toArray(new String[] {}));\n  } catch (CmdLineException e) {\n    err.println(e.getMessage());\n    parser.printUsage(err);\n    throw e;\n  }\n\n  CommandLineConfig config = getCommandLineConfig();\n  config.setPrintTree(flags.print_tree)\n      .setComputePhaseOrdering(flags.compute_phase_ordering)\n      .setPrintAst(flags.print_ast)\n      .setPrintPassGraph(flags.print_pass_graph)\n      .setJscompDevMode(flags.jscomp_dev_mode)\n      .setLoggingLevel(flags.logging_level)\n      .setExterns(flags.externs)\n      .setJs(flags.js)\n      .setJsOutputFile(flags.js_output_file)\n      .setModule(flags.module)\n      .setVariableMapInputFile(flags.variable_map_input_file)\n      .setPropertyMapInputFile(flags.property_map_input_file)\n      .setVariableMapOutputFile(flags.variable_map_output_file)\n      .setCreateNameMapFiles(flags.create_name_map_files)\n      .setPropertyMapOutputFile(flags.property_map_output_file)\n      .setThirdParty(flags.third_party)\n      .setSummaryDetailLevel(flags.summary_detail_level)\n      .setOutputWrapper(flags.output_wrapper)\n      .setOutputWrapperMarker(flags.output_wrapper_marker)\n      .setModuleWrapper(flags.module_wrapper)\n      .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n      .setCreateSourceMap(flags.create_source_map)\n      .setJscompError(flags.jscomp_error)\n      .setJscompWarning(flags.jscomp_warning)\n      .setJscompOff(flags.jscomp_off)\n      .setDefine(flags.define)\n      .setCharset(flags.charset);\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -7.070568639044934,
      "mean_entropy": -0.012809001157690098
    },
    {
      "patch": "\nprivate void initConfigFromFlags(\n    String[] args, PrintStream err)\n    throws CmdLineException {\n  // Args4j has a different format that the old command-line parser.\n  // So we use some voodoo to get the args into the format that args4j\n  // expects.\n  Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n  Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n  List<String> processedArgs = Lists.newArrayList();\n  for (String arg : args) {\n    Matcher matcher = argPattern.matcher(arg);\n    if (matcher.matches()) {\n      processedArgs.add(matcher.group(1));\n\n      String value = matcher.group(2);\n      Matcher quotesMatcher = quotesPattern.matcher(value);\n      if (quotesMatcher.matches()) {\n        processedArgs.add(quotesMatcher.group(1));\n      } else {\n        processedArgs.add(value);\n      }\n    } else {\n      processedArgs.add(arg);\n    }\n  }\n\n  CmdLineParser parser = new CmdLineParser(flags);\n  try {\n    parser.parseArgument(processedArgs.toArray(new String[] {}));\n  } catch (CmdLineException e) {\n    err.println(e.getMessage());\n    parser.printUsage(err);\n    throw e;\n  }\n  getCommandLineConfig()\n      .setPrintTree(flags.print_tree)\n      .setComputePhaseOrdering(flags.compute_phase_ordering)\n      .setPrintAst(flags.print_ast)\n      .setPrintPassGraph(flags.print_pass_graph)\n      .setJscompDevMode(flags.jscomp_dev_mode)\n      .setLoggingLevel(flags.logging_level)\n      .setExterns(flags.externs)\n      .setJs(flags.js)\n      .setJsOutputFile(flags.js_output_file)\n      .setModule(flags.module)\n      .setVariableMapInputFile(flags.variable_map_input_file)\n      .setPropertyMapInputFile(flags.property_map_input_file)\n      .setVariableMapOutputFile(flags.variable_map_output_file)\n      .setCreateNameMapFiles(flags.create_name_map_files)\n      .setPropertyMapOutputFile(flags.property_map_output_file)\n      .setThirdParty(flags.third_party)\n      .setSummaryDetailLevel(flags.summary_detail_level)\n      .setOutputWrapper(flags.output_wrapper)\n      .setOutputWrapperMarker(flags.output_wrapper_marker)\n      .setModuleWrapper(flags.module_wrapper)\n      .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n      .setCreateSourceMap(flags.create_source_map)\n      .setJscompError(flags.jscomp_error)\n      .setJscompWarning(flags.jscomp_warning)\n      .setJscompOff(flags.jscomp_off)\n      .setDefine(flags.define)\n      .setCharset(flags.charset);\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -2.8265946161120525,
      "mean_entropy": -0.0051580193724672495
    },
    {
      "patch": "\nprivate void initConfigFromFlags(\n    String[] args, PrintStream err)\n    throws CmdLineException {\n  // Args4j has a different format that the old command-line parser.\n  // So we use some voodoo to get the args into the format that args4j\n  // expects.\n  Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n  Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n  List<String> processedArgs = Lists.newArrayList();\n  for (String arg : args) {\n    Matcher matcher = argPattern.matcher(arg);\n    if (matcher.matches()) {\n      processedArgs.add(matcher.group(1));\n\n      String value = matcher.group(2);\n      Matcher quotesMatcher = quotesPattern.matcher(value);\n      if (quotesMatcher.matches()) {\n        processedArgs.add(quotesMatcher.group(1));\n      } else {\n        processedArgs.add(value);\n      }\n    } else {\n      processedArgs.add(arg);\n    }\n  }\n\n  CmdLineParser parser = new CmdLineParser(flags);\n  try {\n    parser.parseArgument(processedArgs.toArray(new String[] {}));\n  } catch (CmdLineException e) {\n    err.println(e.getMessage());\n    parser.printUsage(err);\n    throw e;\n  }\n  getCommandLineConfig()\n      .setPrintTree(flags.print_tree)\n      .setComputePhaseOrdering(flags.compute_phase_ordering)\n      .setPrintAst(flags.print_ast)\n      .setPrintPassGraph(flags.print_pass_graph)\n      .setJscompDevMode(flags.jscomp_dev_mode)\n      .setLoggingLevel(flags.logging_level)\n      .setExterns(flags.externs)\n      .setJs(flags.js)\n      .setJsOutputFile(flags.js_output_file)\n      .setModule(flags.module)\n      .setVariableMapInputFile(flags.variable_map_input_file)\n      .setPropertyMapInputFile(flags.property_map_input_file)\n      .setVariableMapOutputFile(flags.variable_map_output_file)\n      .setCreateNameMapFiles(flags.create_name_map_files)\n      .setPropertyMapOutputFile(flags.property_map_output_file)\n      .setThirdParty(flags.third_party)\n      .setSummaryDetailLevel(flags.summary_detail_level)\n      .setOutputWrapper(flags.output_wrapper)\n      .setOutputWrapperMarker(flags.output_wrapper_marker)\n      .setModuleWrapper(flags.module_wrapper)\n      .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n      .setCreateSourceMap(flags.create_source_map)\n      .setJscompError(flags.jscomp_error)\n      .setJscompWarning(flags.jscomp_warning)\n      .setJscompOff(flags.jscomp_off)\n      .setDefine(flags.define)\n      .setCharset(flags.charset);\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -2.8265946161120525,
      "mean_entropy": -0.0051580193724672495
    },
    {
      "patch": "\nprivate void initConfigFromFlags(\n    String[] args, PrintStream err)\n    throws CmdLineException {\n  // Args4j has a different format that the old command-line parser.\n  // So we use some voodoo to get the args into the format that args4j\n  // expects.\n  Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n  Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n  List<String> processedArgs = Lists.newArrayList();\n  for (String arg : args) {\n    Matcher matcher = argPattern.matcher(arg);\n    if (matcher.matches()) {\n      processedArgs.add(matcher.group(1));\n\n      String value = matcher.group(2);\n      Matcher quotesMatcher = quotesPattern.matcher(value);\n      if (quotesMatcher.matches()) {\n        processedArgs.add(quotesMatcher.group(1));\n      } else {\n        processedArgs.add(value);\n      }\n    } else {\n      processedArgs.add(arg);\n    }\n  }\n\n  CmdLineParser parser = new CmdLineParser(flags);\n  try {\n    parser.parseArgument(processedArgs.toArray(new String[] {}));\n  } catch (CmdLineException e) {\n    err.println(e.getMessage());\n    parser.printUsage(err);\n    throw e;\n  }\n  getCommandLineConfig()\n      .setPrintTree(flags.print_tree)\n      .setComputePhaseOrdering(flags.compute_phase_ordering)\n      .setPrintAst(flags.print_ast)\n      .setPrintPassGraph(flags.print_pass_graph)\n      .setJscompDevMode(flags.jscomp_dev_mode)\n      .setLoggingLevel(flags.logging_level)\n      .setExterns(flags.externs)\n      .setJs(flags.js)\n      .setJsOutputFile(flags.js_output_file)\n      .setModule(flags.module)\n      .setVariableMapInputFile(flags.variable_map_input_file)\n      .setPropertyMapInputFile(flags.property_map_input_file)\n      .setVariableMapOutputFile(flags.variable_map_output_file)\n      .setCreateNameMapFiles(flags.create_name_map_files)\n      .setPropertyMapOutputFile(flags.property_map_output_file)\n      .setThirdParty(flags.third_party)\n      .setSummaryDetailLevel(flags.summary_detail_level)\n      .setOutputWrapper(flags.output_wrapper)\n      .setOutputWrapperMarker(flags.output_wrapper_marker)\n      .setModuleWrapper(flags.module_wrapper)\n      .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n      .setCreateSourceMap(flags.create_source_map)\n      .setJscompError(flags.jscomp_error)\n      .setJscompWarning(flags.jscomp_warning)\n      .setJscompOff(flags.jscomp_off)\n      .setDefine(flags.define)\n      .setCharset(flags.charset);\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -2.8265946161120525,
      "mean_entropy": -0.0051580193724672495
    },
    {
      "patch": "\nprivate void initConfigFromFlags(\n    String[] args, PrintStream err)\n    throws CmdLineException {\n  // Args4j has a different format that the old command-line parser.\n  // So we use some voodoo to get the args into the format that args4j\n  // expects.\n  Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n  Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n  List<String> processedArgs = Lists.newArrayList();\n  for (String arg : args) {\n    Matcher matcher = argPattern.matcher(arg);\n    if (matcher.matches()) {\n      processedArgs.add(matcher.group(1));\n\n      String value = matcher.group(2);\n      Matcher quotesMatcher = quotesPattern.matcher(value);\n      if (quotesMatcher.matches()) {\n        processedArgs.add(quotesMatcher.group(1));\n      } else {\n        processedArgs.add(value);\n      }\n    } else {\n      processedArgs.add(arg);\n    }\n  }\n\n  CmdLineParser parser = new CmdLineParser(flags);\n  try {\n    parser.parseArgument(processedArgs.toArray(new String[] {}));\n  } catch (CmdLineException e) {\n    err.println(e.getMessage());\n    parser.printUsage(err);\n    throw e;\n  }\n  getCommandLineConfig()\n      .setPrintTree(flags.print_tree)\n      .setComputePhaseOrdering(flags.compute_phase_ordering)\n      .setPrintAst(flags.print_ast)\n      .setPrintPassGraph(flags.print_pass_graph)\n      .setJscompDevMode(flags.jscomp_dev_mode)\n      .setLoggingLevel(flags.logging_level)\n      .setExterns(flags.externs)\n      .setJs(flags.js)\n      .setJsOutputFile(flags.js_output_file)\n      .setModule(flags.module)\n      .setVariableMapInputFile(flags.variable_map_input_file)\n      .setPropertyMapInputFile(flags.property_map_input_file)\n      .setVariableMapOutputFile(flags.variable_map_output_file)\n      .setCreateNameMapFiles(flags.create_name_map_files)\n      .setPropertyMapOutputFile(flags.property_map_output_file)\n      .setThirdParty(flags.third_party)\n      .setSummaryDetailLevel(flags.summary_detail_level)\n      .setOutputWrapper(flags.output_wrapper)\n      .setOutputWrapperMarker(flags.output_wrapper_marker)\n      .setModuleWrapper(flags.module_wrapper)\n      .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n      .setCreateSourceMap(flags.create_source_map)\n      .setJscompError(flags.jscomp_error)\n      .setJscompWarning(flags.jscomp_warning)\n      .setJscompOff(flags.jscomp_off)\n      .setDefine(flags.define)\n      .setCharset(flags.charset);\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -2.8265946161120525,
      "mean_entropy": -0.0051580193724672495
    },
    {
      "patch": "\nprivate void initConfigFromFlags(\n    String[] args, PrintStream err)\n    throws CmdLineException {\n  // Args4j has a different format that the old command-line parser.\n  // So we use some voodoo to get the args into the format that args4j\n  // expects.\n  Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n  Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n  List<String> processedArgs = Lists.newArrayList();\n  for (String arg : args) {\n    Matcher matcher = argPattern.matcher(arg);\n    if (matcher.matches()) {\n      processedArgs.add(matcher.group(1));\n\n      String value = matcher.group(2);\n      Matcher quotesMatcher = quotesPattern.matcher(value);\n      if (quotesMatcher.matches()) {\n        processedArgs.add(quotesMatcher.group(1));\n      } else {\n        processedArgs.add(value);\n      }\n    } else {\n      processedArgs.add(arg);\n    }\n  }\n\n  CmdLineParser parser = new CmdLineParser(flags);\n  try {\n    parser.parseArgument(processedArgs.toArray(new String[] {}));\n  } catch (CmdLineException e) {\n    err.println(e.getMessage());\n    parser.printUsage(err);\n    throw e;\n  }\n  getCommandLineConfig()\n      .setPrintTree(flags.print_tree)\n      .setComputePhaseOrdering(flags.compute_phase_ordering)\n      .setPrintAst(flags.print_ast)\n      .setPrintPassGraph(flags.print_pass_graph)\n      .setJscompDevMode(flags.jscomp_dev_mode)\n      .setLoggingLevel(flags.logging_level)\n      .setExterns(flags.externs)\n      .setJs(flags.js)\n      .setJsOutputFile(flags.js_output_file)\n      .setModule(flags.module)\n      .setVariableMapInputFile(flags.variable_map_input_file)\n      .setPropertyMapInputFile(flags.property_map_input_file)\n      .setVariableMapOutputFile(flags.variable_map_output_file)\n      .setCreateNameMapFiles(flags.create_name_map_files)\n      .setPropertyMapOutputFile(flags.property_map_output_file)\n      .setThirdParty(flags.third_party)\n      .setSummaryDetailLevel(flags.summary_detail_level)\n      .setOutputWrapper(flags.output_wrapper)\n      .setOutputWrapperMarker(flags.output_wrapper_marker)\n      .setModuleWrapper(flags.module_wrapper)\n      .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n      .setCreateSourceMap(flags.create_source_map)\n      .setJscompError(flags.jscomp_error)\n      .setJscompWarning(flags.jscomp_warning)\n      .setJscompOff(flags.jscomp_off)\n      .setDefine(flags.define)\n      .setCharset(flags.charset);\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -3.081452019517722,
      "mean_entropy": -0.005623087626857157
    },
    {
      "patch": "\nprivate void initConfigFromFlags(String[] args, PrintStream err) throws CmdLineException {\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n    for (String arg : args) {\n        Matcher matcher = argPattern.matcher(arg);\n        if (matcher.matches()) {\n            processedArgs.add(matcher.group(1));\n\n            String value = matcher.group(2);\n            Matcher quotesMatcher = quotesPattern.matcher(value);\n            if (quotesMatcher.matches()) {\n                processedArgs.add(quotesMatcher.group(1));\n            } else {\n                processedArgs.add(value);\n            }\n        } else {\n            processedArgs.add(arg);\n        }\n    }\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    try {\n        parser.parseArgument(processedArgs.toArray(new String[] {}));\n    } catch (CmdLineException e) {\n        err.println(e.getMessage());\n        parser.printUsage(err);\n        throw e;\n    }\n\n    getCommandLineConfig()\n        .setPrintTree(flags.print_tree)\n        .setComputePhaseOrdering(flags.compute_phase_ordering)\n        .setPrintAst(flags.print_ast)\n        .setPrintPassGraph(flags.print_pass_graph)\n        .setJscompDevMode(flags.jscomp_dev_mode)\n        .setLoggingLevel(flags.logging_level)\n        .setExterns(flags.externs)\n        .setJs(flags.js)\n        .setJsOutputFile(flags.js_output_file)\n        .setModule(flags.module)\n        .setVariableMapInputFile(flags.variable_map_input_file)\n        .setPropertyMapInputFile(flags.property_map_input_file)\n        .setVariableMapOutputFile(flags.variable_map_output_file)\n        .setCreateNameMapFiles(flags.create_name_map_files)\n        .setPropertyMapOutputFile(flags.property_map_output_file)\n        .setThirdParty(flags.third_party)\n        .setSummaryDetailLevel(flags.summary_detail_level)\n        .setOutputWrapper(flags.output_wrapper)\n        .setOutputWrapperMarker(flags.output_wrapper_marker)\n        .setModuleWrapper(flags.module_wrapper)\n        .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n        .setCreateSourceMap(flags.create_source_map)\n        .setJscompError(flags.jscomp_error)\n        .setJscompWarning(flags.jscomp_warning)\n        .setJscompOff(flags.jscomp_off)\n        .setDefine(flags.define)\n        .setCharset(flags.charset);\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -6.9147940999092015,
      "mean_entropy": -0.013692661583978617
    },
    {
      "patch": "\n  private void initConfigFromFlags(\n      String[] args, PrintStream err)\n      throws CmdLineException {\n    // Args4j has a different format than the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n    for (String arg : args) {\n      Matcher matcher = argPattern.matcher(arg);\n      if (matcher.matches()) {\n        processedArgs.add(matcher.group(1));\n\n        String value = matcher.group(2);\n        Matcher quotesMatcher = quotesPattern.matcher(value);\n        if (quotesMatcher.matches()) {\n          processedArgs.add(quotesMatcher.group(1));\n        } else {\n          processedArgs.add(value);\n        }\n      } else {\n        processedArgs.add(arg);\n      }\n    }\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      parser.printUsage(err);\n      throw e;\n    }\n    getCommandLineConfig()\n        .setPrintTree(flags.print_tree)\n        .setComputePhaseOrdering(flags.compute_phase_ordering)\n        .setPrintAst(flags.print_ast)\n        .setPrintPassGraph(flags.print_pass_graph)\n        .setJscompDevMode(flags.jscomp_dev_mode)\n        .setLoggingLevel(flags.logging_level)\n        .setExterns(flags.externs)\n        .setJs(flags.js)\n        .setJsOutputFile(flags.js_output_file)\n        .setModule(flags.module)\n        .setVariableMapInputFile(flags.variable_map_input_file)\n        .setPropertyMapInputFile(flags.property_map_input_file)\n        .setVariableMapOutputFile(flags.variable_map_output_file)\n        .setCreateNameMapFiles(flags.create_name_map_files)\n        .setPropertyMapOutputFile(flags.property_map_output_file)\n        .setThirdParty(flags.third_party)\n        .setSummaryDetailLevel(flags.summary_detail_level)\n        .setOutputWrapper(flags.output_wrapper)\n        .setOutputWrapperMarker(flags.output_wrapper_marker)\n        .setModuleWrapper(flags.module_wrapper)\n        .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n        .setCreateSourceMap(flags.create_source_map)\n        .setJscompError(flags.jscomp_error)\n        .setJscompWarning(flags.jscomp_warning)\n        .setJscompOff(flags.jscomp_off)\n        .setDefine(flags.define)\n        .setCharset(flags.charset);\n  }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -4.1484716449760715,
      "mean_entropy": -0.007542675718138311
    },
    {
      "patch": "\nprivate void initConfigFromFlags(\n      String[] args, PrintStream err)\n      throws CmdLineException {\n    // Args4j has a different format that the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n    for (String arg : args) {\n      Matcher matcher = argPattern.matcher(arg);\n      if (matcher.matches()) {\n        processedArgs.add(matcher.group(1));\n\n        String value = matcher.group(2);\n        Matcher quotesMatcher = quotesPattern.matcher(value);\n        if (quotesMatcher.matches()) {\n          processedArgs.add(quotesMatcher.group(1));\n        } else {\n          processedArgs.add(value);\n        }\n      } else {\n        processedArgs.add(arg);\n      }\n    }\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      parser.printUsage(err);\n      throw e;\n    }\n    getCommandLineConfig()\n        .setPrintTree(flags.print_tree)\n        .setComputePhaseOrdering(flags.compute_phase_ordering)\n        .setPrintAst(flags.print_ast)\n        .setPrintPassGraph(flags.print_pass_graph)\n        .setJscompDevMode(flags.jscomp_dev_mode)\n        .setLoggingLevel(flags.logging_level)\n        .setExterns(flags.externs)\n        .setJs(flags.js)\n        .setJsOutputFile(flags.js_output_file)\n        .setModule(flags.module)\n        .setVariableMapInputFile(flags.variable_map_input_file)\n        .setPropertyMapInputFile(flags.property_map_input_file)\n        .setVariableMapOutputFile(flags.variable_map_output_file)\n        .setCreateNameMapFiles(flags.create_name_map_files)\n        .setPropertyMapOutputFile(flags.property_map_output_file)\n        .setThirdParty(flags.third_party)\n        .setSummaryDetailLevel(flags.summary_detail_level)\n        .setOutputWrapper(flags.output_wrapper)\n        .setOutputWrapperMarker(flags.output_wrapper_marker)\n        .setModuleWrapper(flags.module_wrapper)\n        .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n        .setCreateSourceMap(flags.create_source_map)\n        .setJscompError(flags.jscomp_error)\n        .setJscompWarning(flags.jscomp_warning)\n        .setJscompOff(flags.jscomp_off)\n        .setDefine(flags.define)\n        .setCharset(flags.charset);\n  }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives"
        ]
      ],
      "sum_entropy": -3.352021224702523,
      "mean_entropy": -0.006105685290897127
    }
  ],
  "Closure_105": [],
  "Closure_107": [
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar = false;\n    Node msgNode = null;\n    Node msgNodeParent = null;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage = msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(\n            traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel, MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(), MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications && !isUnnamedMsg && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage, messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT, messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage && (desc == null || desc.trim().isEmpty()) && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION, messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -8.782441622074998,
      "mean_entropy": -0.010480240599134842
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey = null;\n    boolean isVar = false;\n    Node msgNode = null, msgNodeParent = null;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage = (msgNode != null && msgNode.isCall());\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(\n                traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel,\n                MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n            isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(),\n                MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n            && !isUnnamedMsg\n            && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n            messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n                messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n            && (desc == null || desc.trim().isEmpty())\n            && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n                messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n            node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -6.438284806569885,
      "mean_entropy": -0.00753015766850279
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n  String messageKey;\n  boolean isVar = false;\n  Node msgNode = null, msgNodeParent = null;\n\n  switch (node.getType()) {\n    case Token.NAME:\n      // var MSG_HELLO = 'Message'\n      if ((parent != null) && (parent.isVar())) {\n        messageKey = node.getString();\n        isVar = true;\n      } else {\n        return;\n      }\n\n      msgNode = node.getFirstChild();\n      msgNodeParent = node;\n      break;\n    case Token.ASSIGN:\n      // somenamespace.someclass.MSG_HELLO = 'Message'\n      isVar = false;\n\n      Node getProp = node.getFirstChild();\n      if (!getProp.isGetProp()) {\n        return;\n      }\n\n      Node propNode = getProp.getLastChild();\n\n      messageKey = propNode.getString();\n      msgNode = node.getLastChild();\n      msgNodeParent = node;\n      break;\n    case Token.CALL:\n      // goog.getMsg()\n      String fnName = node.getFirstChild().getQualifiedName();\n      if (MSG_FUNCTION_NAME.equals(fnName)) {\n        googMsgNodes.put(node, traversal.getSourceName());\n      } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n        visitFallbackFunctionCall(traversal, node);\n      }\n      return;\n    default:\n      return;\n  }\n\n  // Is this a message name?\n  boolean isNewStyleMessage = (msgNode != null && msgNode.isCall());\n  if (!isMessageName(messageKey, isNewStyleMessage)) {\n    return;\n  }\n\n  if (msgNode == null) {\n    compiler.report(\n        traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n    return;\n  }\n\n  // Just report a warning if a qualified messageKey that looks like a message\n  // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n  if (isNewStyleMessage) {\n    googMsgNodes.remove(msgNode);\n  } else if (style != JsMessage.Style.LEGACY) {\n    compiler.report(traversal.makeError(node, checkLevel,\n        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n  }\n\n  boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n  Builder builder = new Builder(isUnnamedMsg ? null : messageKey);\n  builder.setSourceName(traversal.getSourceName());\n\n  try {\n    if (isVar) {\n      extractMessageFromVariable(builder, node, parent, parent.getParent());\n    } else {\n      extractMessageFromProperty(builder, node.getFirstChild(), node);\n    }\n  } catch (MalformedException ex) {\n    compiler.report(traversal.makeError(ex.getNode(),\n        MESSAGE_TREE_MALFORMED, ex.getMessage()));\n    return;\n  }\n\n  JsMessage extractedMessage = builder.build(idGenerator);\n\n  // If asked to check named internal messages.\n  if (needToCheckDuplications\n      && !isUnnamedMsg\n      && !extractedMessage.isExternal()) {\n    checkIfMessageDuplicated(messageKey, msgNode);\n  }\n  trackMessage(traversal, extractedMessage,\n      messageKey, msgNode, isUnnamedMsg);\n\n  if (extractedMessage.isEmpty()) {\n    // value of the message is an empty string. Translators do not like it.\n    compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n        messageKey));\n  }\n\n  // New-style messages must have descriptions. We don't emit a warning\n  // for legacy-style messages, because there are thousands of\n  // them in legacy code that are not worth the effort to fix, since they've\n  // already been translated anyway.\n  String desc = extractedMessage.getDesc();\n  if (isNewStyleMessage\n      && (desc == null || desc.trim().isEmpty())\n      && !extractedMessage.isExternal()) {\n    compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n        messageKey));\n  }\n\n  JsMessageDefinition msgDefinition = new JsMessageDefinition(\n      node, msgNode, msgNodeParent);\n  processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -12.422205677711014,
      "mean_entropy": -0.014597186460294963
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey = null;\n    boolean isVar = false;\n    Node msgNode = null, msgNodeParent = null;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if (parent != null && parent.isVar()) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage = msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel, MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(), MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications && !isUnnamedMsg && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage, messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT, messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage && (desc == null || desc.trim().isEmpty()) && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION, messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -7.171496606176034,
      "mean_entropy": -0.008588618690031179
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar;\n    Node msgNode, msgNodeParent;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage =\n            msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(\n                traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel,\n                MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n            isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(),\n                MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n            && !isUnnamedMsg\n            && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n            messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n                messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n            && (desc == null || desc.trim().isEmpty())\n            && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n                messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n            node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -5.586269644474104,
      "mean_entropy": -0.006595359674703783
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar;\n    Node msgNode, msgNodeParent;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage =\n            msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(\n                traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel,\n                MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n            isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(),\n                MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n            && !isUnnamedMsg\n            && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n            messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n                messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n            && (desc == null || desc.trim().isEmpty())\n            && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n                messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n            node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -5.586269644474104,
      "mean_entropy": -0.006595359674703783
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey = null;\n    boolean isVar = false;\n    Node msgNode = null, msgNodeParent = null;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    boolean isNewStyleMessage = msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(\n            traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel,\n            MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(),\n            MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    if (needToCheckDuplications && !isUnnamedMsg && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage, messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT, messageKey));\n    }\n\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage && (desc == null || desc.trim().isEmpty()) && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION, messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -9.468284858738953,
      "mean_entropy": -0.01388311562864949
    },
    {
      "patch": "\n  @Override\n  public void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey = null;\n    boolean isVar = false;\n    Node msgNode = null;\n    Node msgNodeParent = null;\n\n    switch (node.getType()) {\n      case Token.NAME:\n        // var MSG_HELLO = 'Message'\n        if ((parent != null) && (parent.isVar())) {\n          messageKey = node.getString();\n          isVar = true;\n        } else {\n          return;\n        }\n\n        msgNode = node.getFirstChild();\n        msgNodeParent = node;\n        break;\n      case Token.ASSIGN:\n        // somenamespace.someclass.MSG_HELLO = 'Message'\n        isVar = false;\n\n        Node getProp = node.getFirstChild();\n        if (!getProp.isGetProp()) {\n          return;\n        }\n\n        Node propNode = getProp.getLastChild();\n\n        messageKey = propNode.getString();\n        msgNode = node.getLastChild();\n        msgNodeParent = node;\n        break;\n      case Token.CALL:\n        // goog.getMsg()\n        String fnName = node.getFirstChild().getQualifiedName();\n        if (MSG_FUNCTION_NAME.equals(fnName)) {\n          googMsgNodes.put(node, traversal.getSourceName());\n        } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n          visitFallbackFunctionCall(traversal, node);\n        }\n        return;\n      default:\n        return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage =\n        msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n      return;\n    }\n\n    if (msgNode == null) {\n      compiler.report(\n          traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n      return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n      googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n      compiler.report(traversal.makeError(node, checkLevel,\n          MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n        isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n      if (isVar) {\n        extractMessageFromVariable(builder, node, parent, parent.getParent());\n      } else {\n        extractMessageFromProperty(builder, node.getFirstChild(), node);\n      }\n    } catch (MalformedException ex) {\n      compiler.report(traversal.makeError(ex.getNode(),\n          MESSAGE_TREE_MALFORMED, ex.getMessage()));\n      return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n        && !isUnnamedMsg\n        && !extractedMessage.isExternal()) {\n      checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n        messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n      // value of the message is an empty string. Translators do not like it.\n      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n          messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n        && (desc == null || desc.trim().isEmpty())\n        && !extractedMessage.isExternal()) {\n      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n          messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n        node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n  }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -4.141022809343574,
      "mean_entropy": -0.0048095503012120485
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar = false;\n    Node msgNode = null, msgNodeParent = null;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage =\n            msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(\n                traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel,\n                MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n            isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(),\n                MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n            && !isUnnamedMsg\n            && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n            messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n                messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n            && (desc == null || desc.trim().isEmpty())\n            && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n                messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n            node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -4.3671087672845665,
      "mean_entropy": -0.00511970547161145
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar;\n    Node msgNode = null, msgNodeParent = null;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage =\n            msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(\n                traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel,\n                MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n            isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(),\n                MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n            && !isUnnamedMsg\n            && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n            messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n                messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n            && (desc == null || desc.trim().isEmpty())\n            && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n                messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n            node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -4.132013887530937,
      "mean_entropy": -0.0048554804788847675
    },
    {
      "patch": "\n  @Override\n  public void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar = false;\n    Node msgNode = null, msgNodeParent = null;\n\n    switch (node.getType()) {\n      case Token.NAME:\n        // var MSG_HELLO = 'Message'\n        if ((parent != null) && (parent.isVar())) {\n          messageKey = node.getString();\n          isVar = true;\n        } else {\n          return;\n        }\n\n        msgNode = node.getFirstChild();\n        msgNodeParent = node;\n        break;\n      case Token.ASSIGN:\n        // somenamespace.someclass.MSG_HELLO = 'Message'\n        isVar = false;\n\n        Node getProp = node.getFirstChild();\n        if (!getProp.isGetProp()) {\n          return;\n        }\n\n        Node propNode = getProp.getLastChild();\n\n        messageKey = propNode.getString();\n        msgNode = node.getLastChild();\n        msgNodeParent = node;\n        break;\n      case Token.CALL:\n        // goog.getMsg()\n        String fnName = node.getFirstChild().getQualifiedName();\n        if (MSG_FUNCTION_NAME.equals(fnName)) {\n          googMsgNodes.put(node, traversal.getSourceName());\n        } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n          visitFallbackFunctionCall(traversal, node);\n        }\n        return;\n      default:\n        return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage = msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n      return;\n    }\n\n    if (msgNode == null) {\n      compiler.report(\n          traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n      return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n      googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n      compiler.report(traversal.makeError(node, checkLevel,\n          MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n        isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n      if (isVar) {\n        extractMessageFromVariable(builder, node, parent, parent.getParent());\n      } else {\n        extractMessageFromProperty(builder, node.getFirstChild(), node);\n      }\n    } catch (MalformedException ex) {\n      compiler.report(traversal.makeError(ex.getNode(),\n          MESSAGE_TREE_MALFORMED, ex.getMessage()));\n      return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n        && !isUnnamedMsg\n        && !extractedMessage.isExternal()) {\n      checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n        messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n      // value of the message is an empty string. Translators do not like it.\n      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n          messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n        && (desc == null || desc.trim().isEmpty())\n        && !extractedMessage.isExternal()) {\n      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n          messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n        node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n  }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -6.468961566533115,
      "mean_entropy": -0.007557198091744293
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n  String messageKey;\n  boolean isVar = false;\n  Node msgNode = null, msgNodeParent = null;\n\n  switch (node.getType()) {\n    case Token.NAME:\n      // var MSG_HELLO = 'Message'\n      if ((parent != null) && (parent.isVar())) {\n        messageKey = node.getString();\n        isVar = true;\n      } else {\n        return;\n      }\n\n      msgNode = node.getFirstChild();\n      msgNodeParent = node;\n      break;\n    case Token.ASSIGN:\n      // somenamespace.someclass.MSG_HELLO = 'Message'\n      Node getProp = node.getFirstChild();\n      if (!getProp.isGetProp()) {\n        return;\n      }\n\n      Node propNode = getProp.getLastChild();\n\n      messageKey = propNode.getString();\n      msgNode = node.getLastChild();\n      msgNodeParent = node;\n      break;\n    case Token.CALL:\n      // goog.getMsg()\n      String fnName = node.getFirstChild().getQualifiedName();\n      if (MSG_FUNCTION_NAME.equals(fnName)) {\n        googMsgNodes.put(node, traversal.getSourceName());\n      } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n        visitFallbackFunctionCall(traversal, node);\n      }\n      return;\n    default:\n      return;\n  }\n\n  // Is this a message name?\n  boolean isNewStyleMessage = msgNode != null && msgNode.isCall();\n  if (!isMessageName(messageKey, isNewStyleMessage)) {\n    return;\n  }\n\n  if (msgNode == null) {\n    compiler.report(\n        traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n    return;\n  }\n\n  if (isNewStyleMessage) {\n    googMsgNodes.remove(msgNode);\n  } else if (style != JsMessage.Style.LEGACY) {\n    compiler.report(traversal.makeError(node, checkLevel,\n        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n  }\n\n  boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n  Builder builder = new Builder(isUnnamedMsg ? null : messageKey);\n  builder.setSourceName(traversal.getSourceName());\n\n  try {\n    if (isVar) {\n      extractMessageFromVariable(builder, node, parent, parent.getParent());\n    } else {\n      extractMessageFromProperty(builder, node.getFirstChild(), node);\n    }\n  } catch (MalformedException ex) {\n    compiler.report(traversal.makeError(ex.getNode(), MESSAGE_TREE_MALFORMED, ex.getMessage()));\n    return;\n  }\n\n  JsMessage extractedMessage = builder.build(idGenerator);\n\n  if (needToCheckDuplications && !isUnnamedMsg && !extractedMessage.isExternal()) {\n    checkIfMessageDuplicated(messageKey, msgNode);\n  }\n  trackMessage(traversal, extractedMessage, messageKey, msgNode, isUnnamedMsg);\n\n  if (extractedMessage.isEmpty()) {\n    compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT, messageKey));\n  }\n\n  String desc = extractedMessage.getDesc();\n  if (isNewStyleMessage && (desc == null || desc.trim().isEmpty()) && !extractedMessage.isExternal()) {\n    compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION, messageKey));\n  }\n\n  JsMessageDefinition msgDefinition = new JsMessageDefinition(node, msgNode, msgNodeParent);\n  processJsMessage(extractedMessage, msgDefinition);\n}\n\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -14.440553098788145,
      "mean_entropy": -0.020253230152578044
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar = false;\n    Node msgNode = null, msgNodeParent = null;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage =\n            msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(\n                traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel,\n                MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n            isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(),\n                MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n            && !isUnnamedMsg\n            && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n            messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n                messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n            && (desc == null || desc.trim().isEmpty())\n            && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n                messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n            node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -4.3671087672845665,
      "mean_entropy": -0.00511970547161145
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar;\n    Node msgNode, msgNodeParent;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage =\n            msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(\n                traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel,\n                MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n            isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(),\n                MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n            && !isUnnamedMsg\n            && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n            messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n                messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n            && (desc == null || desc.trim().isEmpty())\n            && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n                messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n            node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -5.586269644474104,
      "mean_entropy": -0.006595359674703783
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar;\n    Node msgNode = null, msgNodeParent = null;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage = msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel, MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(), MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications && !isUnnamedMsg && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage, messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT, messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage && (desc == null || desc.trim().isEmpty()) && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION, messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -5.651366144201246,
      "mean_entropy": -0.00678435311428721
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar;\n    Node msgNode, msgNodeParent;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage = msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(\n            traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel, MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n        isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(), MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications && !isUnnamedMsg && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage, messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT, messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage && (desc == null || desc.trim().isEmpty()) && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION, messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -11.360259196452818,
      "mean_entropy": -0.013654157688044252
    },
    {
      "patch": "\n  @Override\n  public void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar = false;\n    Node msgNode = null, msgNodeParent = null;\n\n    switch (node.getType()) {\n      case Token.NAME:\n        // var MSG_HELLO = 'Message'\n        if ((parent != null) && (parent.isVar())) {\n          messageKey = node.getString();\n          isVar = true;\n        } else {\n          return;\n        }\n\n        msgNode = node.getFirstChild();\n        msgNodeParent = node;\n        break;\n      case Token.ASSIGN:\n        // somenamespace.someclass.MSG_HELLO = 'Message'\n        Node getProp = node.getFirstChild();\n        if (!getProp.isGetProp()) {\n          return;\n        }\n\n        Node propNode = getProp.getLastChild();\n\n        messageKey = propNode.getString();\n        msgNode = node.getLastChild();\n        msgNodeParent = node;\n        break;\n      case Token.CALL:\n        // goog.getMsg()\n        String fnName = node.getFirstChild().getQualifiedName();\n        if (MSG_FUNCTION_NAME.equals(fnName)) {\n          googMsgNodes.put(node, traversal.getSourceName());\n        } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n          visitFallbackFunctionCall(traversal, node);\n        }\n        return;\n      default:\n        return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage =\n        msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n      return;\n    }\n\n    if (msgNode == null) {\n      compiler.report(\n          traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n      return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n      googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n      compiler.report(traversal.makeError(node, checkLevel,\n          MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n        isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n      if (isVar) {\n        extractMessageFromVariable(builder, node, parent, parent.getParent());\n      } else {\n        extractMessageFromProperty(builder, node.getFirstChild(), node);\n      }\n    } catch (MalformedException ex) {\n      compiler.report(traversal.makeError(ex.getNode(),\n          MESSAGE_TREE_MALFORMED, ex.getMessage()));\n      return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n        && !isUnnamedMsg\n        && !extractedMessage.isExternal()) {\n      checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n        messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n      // value of the message is an empty string. Translators do not like it.\n      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n          messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n        && (desc == null || desc.trim().isEmpty())\n        && !extractedMessage.isExternal()) {\n      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n          messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n        node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n  }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -6.814297381659187,
      "mean_entropy": -0.008007399978447929
    },
    {
      "patch": "\n  @Override\n  public void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey = null;\n    boolean isVar = false;\n    Node msgNode = null;\n    Node msgNodeParent = null;\n\n    switch (node.getType()) {\n      case Token.NAME:\n        // var MSG_HELLO = 'Message'\n        if ((parent != null) && (parent.isVar())) {\n          messageKey = node.getString();\n          isVar = true;\n        } else {\n          return;\n        }\n\n        msgNode = node.getFirstChild();\n        msgNodeParent = node;\n        break;\n      case Token.ASSIGN:\n        // somenamespace.someclass.MSG_HELLO = 'Message'\n        isVar = false;\n\n        Node getProp = node.getFirstChild();\n        if (!getProp.isGetProp()) {\n          return;\n        }\n\n        Node propNode = getProp.getLastChild();\n\n        messageKey = propNode.getString();\n        msgNode = node.getLastChild();\n        msgNodeParent = node;\n        break;\n      case Token.CALL:\n        // goog.getMsg()\n        String fnName = node.getFirstChild().getQualifiedName();\n        if (MSG_FUNCTION_NAME.equals(fnName)) {\n          googMsgNodes.put(node, traversal.getSourceName());\n        } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n          visitFallbackFunctionCall(traversal, node);\n        }\n        return;\n      default:\n        return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage =\n        msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n      return;\n    }\n\n    if (msgNode == null) {\n      compiler.report(\n          traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n      return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n      googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n      compiler.report(traversal.makeError(node, checkLevel,\n          MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n        isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n      if (isVar) {\n        extractMessageFromVariable(builder, node, parent, parent.getParent());\n      } else {\n        extractMessageFromProperty(builder, node.getFirstChild(), node);\n      }\n    } catch (MalformedException ex) {\n      compiler.report(traversal.makeError(ex.getNode(),\n          MESSAGE_TREE_MALFORMED, ex.getMessage()));\n      return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n        && !isUnnamedMsg\n        && !extractedMessage.isExternal()) {\n      checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n        messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n      // value of the message is an empty string. Translators do not like it.\n      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n          messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n        && (desc == null || desc.trim().isEmpty())\n        && !extractedMessage.isExternal()) {\n      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n          messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n        node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n  }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -4.302690022560244,
      "mean_entropy": -0.0049973170993731055
    },
    {
      "patch": "\n@Override\npublic void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey;\n    boolean isVar;\n    Node msgNode, msgNodeParent;\n\n    switch (node.getType()) {\n        case Token.NAME:\n            // var MSG_HELLO = 'Message'\n            if ((parent != null) && (parent.isVar())) {\n                messageKey = node.getString();\n                isVar = true;\n            } else {\n                return;\n            }\n\n            msgNode = node.getFirstChild();\n            msgNodeParent = node;\n            break;\n        case Token.ASSIGN:\n            // somenamespace.someclass.MSG_HELLO = 'Message'\n            isVar = false;\n\n            Node getProp = node.getFirstChild();\n            if (!getProp.isGetProp()) {\n                return;\n            }\n\n            Node propNode = getProp.getLastChild();\n\n            messageKey = propNode.getString();\n            msgNode = node.getLastChild();\n            msgNodeParent = node;\n            break;\n        case Token.CALL:\n            // goog.getMsg()\n            String fnName = node.getFirstChild().getQualifiedName();\n            if (MSG_FUNCTION_NAME.equals(fnName)) {\n                googMsgNodes.put(node, traversal.getSourceName());\n            } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n                visitFallbackFunctionCall(traversal, node);\n            }\n            return;\n        default:\n            return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage =\n            msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n        return;\n    }\n\n    if (msgNode == null) {\n        compiler.report(\n                traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n        return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n        googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n        compiler.report(traversal.makeError(node, checkLevel,\n                MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n            isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n        if (isVar) {\n            extractMessageFromVariable(builder, node, parent, parent.getParent());\n        } else {\n            extractMessageFromProperty(builder, node.getFirstChild(), node);\n        }\n    } catch (MalformedException ex) {\n        compiler.report(traversal.makeError(ex.getNode(),\n                MESSAGE_TREE_MALFORMED, ex.getMessage()));\n        return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n            && !isUnnamedMsg\n            && !extractedMessage.isExternal()) {\n        checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n            messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n        // value of the message is an empty string. Translators do not like it.\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n                messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n            && (desc == null || desc.trim().isEmpty())\n            && !extractedMessage.isExternal()) {\n        compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n                messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n            node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -5.574644319279535,
      "mean_entropy": -0.0065816343793146815
    },
    {
      "patch": "\n  @Override\n  public void visit(NodeTraversal traversal, Node node, Node parent) {\n    String messageKey = null;\n    boolean isVar = false;\n    Node msgNode = null;\n    Node msgNodeParent = null;\n\n    switch (node.getType()) {\n      case Token.NAME:\n        // var MSG_HELLO = 'Message'\n        if ((parent != null) && (parent.isVar())) {\n          messageKey = node.getString();\n          isVar = true;\n        } else {\n          return;\n        }\n\n        msgNode = node.getFirstChild();\n        msgNodeParent = node;\n        break;\n      case Token.ASSIGN:\n        // somenamespace.someclass.MSG_HELLO = 'Message'\n        isVar = false;\n\n        Node getProp = node.getFirstChild();\n        if (!getProp.isGetProp()) {\n          return;\n        }\n\n        Node propNode = getProp.getLastChild();\n\n        messageKey = propNode.getString();\n        msgNode = node.getLastChild();\n        msgNodeParent = node;\n        break;\n      case Token.CALL:\n        // goog.getMsg()\n        String fnName = node.getFirstChild().getQualifiedName();\n        if (MSG_FUNCTION_NAME.equals(fnName)) {\n          googMsgNodes.put(node, traversal.getSourceName());\n        } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n          visitFallbackFunctionCall(traversal, node);\n        }\n        return;\n      default:\n        return;\n    }\n\n    // Is this a message name?\n    boolean isNewStyleMessage =\n        msgNode != null && msgNode.isCall();\n    if (!isMessageName(messageKey, isNewStyleMessage)) {\n      return;\n    }\n\n    if (msgNode == null) {\n      compiler.report(\n          traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey));\n      return;\n    }\n\n    // Just report a warning if a qualified messageKey that looks like a message\n    // (e.g. \"a.b.MSG_X\") doesn't use goog.getMsg().\n    if (isNewStyleMessage) {\n      googMsgNodes.remove(msgNode);\n    } else if (style != JsMessage.Style.LEGACY) {\n      compiler.report(traversal.makeError(node, checkLevel,\n          MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX));\n    }\n\n    boolean isUnnamedMsg = isUnnamedMessageName(messageKey);\n\n    Builder builder = new Builder(\n        isUnnamedMsg ? null : messageKey);\n    builder.setSourceName(traversal.getSourceName());\n\n    try {\n      if (isVar) {\n        extractMessageFromVariable(builder, node, parent, parent.getParent());\n      } else {\n        extractMessageFromProperty(builder, node.getFirstChild(), node);\n      }\n    } catch (MalformedException ex) {\n      compiler.report(traversal.makeError(ex.getNode(),\n          MESSAGE_TREE_MALFORMED, ex.getMessage()));\n      return;\n    }\n\n    JsMessage extractedMessage = builder.build(idGenerator);\n\n    // If asked to check named internal messages.\n    if (needToCheckDuplications\n        && !isUnnamedMsg\n        && !extractedMessage.isExternal()) {\n      checkIfMessageDuplicated(messageKey, msgNode);\n    }\n    trackMessage(traversal, extractedMessage,\n        messageKey, msgNode, isUnnamedMsg);\n\n    if (extractedMessage.isEmpty()) {\n      // value of the message is an empty string. Translators do not like it.\n      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n          messageKey));\n    }\n\n    // New-style messages must have descriptions. We don't emit a warning\n    // for legacy-style messages, because there are thousands of\n    // them in legacy code that are not worth the effort to fix, since they've\n    // already been translated anyway.\n    String desc = extractedMessage.getDesc();\n    if (isNewStyleMessage\n        && (desc == null || desc.trim().isEmpty())\n        && !extractedMessage.isExternal()) {\n      compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION,\n          messageKey));\n    }\n\n    JsMessageDefinition msgDefinition = new JsMessageDefinition(\n        node, msgNode, msgNodeParent);\n    processJsMessage(extractedMessage, msgDefinition);\n  }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -4.302690022560244,
      "mean_entropy": -0.0049973170993731055
    },
    {
      "patch": "\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -0.8901975558455301,
      "mean_entropy": -0.006795401189660535
    },
    {
      "patch": "\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -0.8901975558455301,
      "mean_entropy": -0.006795401189660535
    },
    {
      "patch": "\n/**\n * Checks if message already processed. If so - it generates 'message\n * duplicated' compiler error.\n *\n * @param msgName the name of the message\n * @param msgNode the node that represents JS message\n */\nprivate void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n        MessageLocation location = messageNames.get(msgName);\n        compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n                msgName, location.messageNode.getSourceFileName(),\n                Integer.toString(location.messageNode.getLineno())));\n    }\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -3.2514813468072505,
      "mean_entropy": -0.02665148644923976
    },
    {
      "patch": "\n/**\n * Checks if message already processed. If so - it generates 'message\n * duplicated' compiler error.\n *\n * @param msgName the name of the message\n * @param msgNode the node that represents JS message\n */\nprivate void checkIfMessageDuplicated(String msgName, Node msgNode) {\n  if (messageNames.containsKey(msgName)) {\n    MessageLocation location = messageNames.get(msgName);\n    String sourceFileName = (location.messageNode != null) ? location.messageNode.getSourceFileName() : null;\n    int lineno = (location.messageNode != null) ? location.messageNode.getLineno() : -1;\n    compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n        msgName, sourceFileName, Integer.toString(lineno)));\n  }\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -12.403871302742301,
      "mean_entropy": -0.07752419564213939
    },
    {
      "patch": "\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -0.8901975558455301,
      "mean_entropy": -0.006795401189660535
    },
    {
      "patch": "\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -0.8901975558455301,
      "mean_entropy": -0.006795401189660535
    },
    {
      "patch": "\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -0.8901975558455301,
      "mean_entropy": -0.006795401189660535
    },
    {
      "patch": "\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -0.8901975558455301,
      "mean_entropy": -0.006795401189660535
    },
    {
      "patch": "\n/**\n * Checks if message already processed. If so - it generates 'message\n * duplicated' compiler error.\n *\n * @param msgName the name of the message\n * @param msgNode the node that represents JS message\n */\nprivate void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n        MessageLocation location = messageNames.get(msgName);\n        compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n                msgName, location.messageNode.getSourceFileName(),\n                Integer.toString(location.messageNode.getLineno())));\n    }\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -3.2514813468072505,
      "mean_entropy": -0.02665148644923976
    },
    {
      "patch": "\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -0.8901975558455301,
      "mean_entropy": -0.006795401189660535
    },
    {
      "patch": "\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -0.8901975558455301,
      "mean_entropy": -0.006795401189660535
    },
    {
      "patch": "\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -0.8901975558455301,
      "mean_entropy": -0.006795401189660535
    },
    {
      "patch": "\n/**\n * Checks if message already processed. If so - it generates 'message\n * duplicated' compiler error.\n *\n * @param msgName the name of the message\n * @param msgNode the node that represents JS message\n */\nprivate void checkIfMessageDuplicated(String msgName, Node msgNode) {\n  if (messageNames.containsKey(msgName)) {\n    MessageLocation location = messageNames.get(msgName);\n    compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n        msgName, location.messageNode.getSourceFileName(),\n        Integer.toString(location.messageNode.getLineno())));\n  }\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -3.3111609355580494,
      "mean_entropy": -0.02714066340621352
    },
    {
      "patch": "\n/**\n * Checks if message already processed. If so - it generates 'message\n * duplicated' compiler error.\n *\n * @param msgName the name of the message\n * @param msgNode the node that represents JS message\n */\nprivate void checkIfMessageDuplicated(String msgName, Node msgNode) {\n  if (messageNames.containsKey(msgName)) {\n    MessageLocation location = messageNames.get(msgName);\n    compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n        msgName, location.messageNode.getSourceFileName(),\n        Integer.toString(location.messageNode.getLineno())));\n  }\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -2.9195767129601014,
      "mean_entropy": -0.023930956663607388
    },
    {
      "patch": "\n/**\n * Checks if message already processed. If so - it generates 'message\n * duplicated' compiler error.\n *\n * @param msgName the name of the message\n * @param msgNode the node that represents JS message\n */\nprivate void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n        MessageLocation location = messageNames.get(msgName);\n        compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n                msgName, location.messageNode.getSourceFileName(),\n                Integer.toString(location.messageNode.getLineno())));\n    }\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -2.7722901097374018,
      "mean_entropy": -0.022723689424077063
    },
    {
      "patch": "\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -1.0689324200476398,
      "mean_entropy": -0.008159789466012517
    },
    {
      "patch": "\n  /**\n   * Checks if message already processed. If so - it generates 'message\n   * duplicated' compiler error.\n   *\n   * @param msgName the name of the message\n   * @param msgNode the node that represents JS message\n   */\n  private void checkIfMessageDuplicated(String msgName, Node msgNode) {\n    if (messageNames.containsKey(msgName)) {\n      MessageLocation location = messageNames.get(msgName);\n      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n          msgName, location.messageNode.getSourceFileName(),\n          Integer.toString(location.messageNode.getLineno())));\n    }\n  }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings",
        [
          "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings"
        ]
      ],
      "sum_entropy": -1.0689324200476398,
      "mean_entropy": -0.008159789466012517
    }
  ],
  "Closure_122": [
    {
      "patch": "\n  /**\n   * Parameter NAMEs are special, because they can have inline type docs\n   * attached.\n   *\n   * function f(/** string &#42;/ x) {}\n   * annotates 'x' as a string.\n   *\n   * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n   *   Using Inline Doc Comments</a>\n   */\n  private Node transformParameter(AstNode node) {\n    Node irNode = justTransform(node);\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n      if (info != null) {\n        irNode.setJSDocInfo(info);\n      }\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.914182133716719,
      "mean_entropy": -0.016371809739981567
    },
    {
      "patch": "\n/**\n * Parameter NAMEs are special, because they can have inline type docs\n * attached.\n *\n * function f(/** string &#42;/ x) {}\n * annotates 'x' as a string.\n *\n * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n *   Using Inline Doc Comments</a>\n */\nprivate Node transformParameter(AstNode node) {\n  Node irNode = justTransform(node);\n  Comment comment = node.getJsDocNode();\n  if (comment != null) {\n    JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.21290508683354,
      "mean_entropy": -0.013330753535141807
    },
    {
      "patch": "\n/**\n * Parameter NAMEs are special, because they can have inline type docs\n * attached.\n *\n * function f(/** string &#42;/ x) {}\n * annotates 'x' as a string.\n *\n * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n *   Using Inline Doc Comments</a>\n */\nprivate Node transformParameter(AstNode node) {\n  Node irNode = justTransform(node);\n  Comment comment = node.getJsDocNode();\n  if (comment != null) {\n    JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.21290508683354,
      "mean_entropy": -0.013330753535141807
    },
    {
      "patch": "\n  /**\n   * Parameter NAMEs are special, because they can have inline type docs\n   * attached.\n   *\n   * function f(/** string &#42;/ x) {}\n   * annotates 'x' as a string.\n   *\n   * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n   *   Using Inline Doc Comments</a>\n   */\n  private Node transformParameter(AstNode node) {\n    Node irNode = justTransform(node);\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n      if (info != null) {\n        irNode.setJSDocInfo(info);\n      }\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.914182133716719,
      "mean_entropy": -0.016371809739981567
    },
    {
      "patch": "\n/**\n * Parameter NAMEs are special, because they can have inline type docs\n * attached.\n *\n * function f(/** string &#42;/ x) {}\n * annotates 'x' as a string.\n *\n * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n *   Using Inline Doc Comments</a>\n */\nprivate Node transformParameter(AstNode node) {\n  Node irNode = justTransform(node);\n  Comment comment = node.getJsDocNode();\n  if (comment != null) {\n    JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.21290508683354,
      "mean_entropy": -0.013330753535141807
    },
    {
      "patch": "\n  /**\n   * Parameter NAMEs are special, because they can have inline type docs\n   * attached.\n   *\n   * function f(/** string &#42;/ x) {}\n   * annotates 'x' as a string.\n   *\n   * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n   *   Using Inline Doc Comments</a>\n   */\n  private Node transformParameter(AstNode node) {\n    Node irNode = justTransform(node);\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n      if (info != null) {\n        irNode.setJSDocInfo(info);\n      }\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.914182133716719,
      "mean_entropy": -0.016371809739981567
    },
    {
      "patch": "\n/**\n * Parameter NAMEs are special, because they can have inline type docs\n * attached.\n *\n * function f(/** string &#42;/ x) {}\n * annotates 'x' as a string.\n *\n * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n *   Using Inline Doc Comments</a>\n */\nprivate Node transformParameter(AstNode node) {\n  Node irNode = justTransform(node);\n  Comment comment = node.getJsDocNode();\n  if (comment != null) {\n    JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.21290508683354,
      "mean_entropy": -0.013330753535141807
    },
    {
      "patch": "\n/**\n * Parameter NAMEs are special, because they can have inline type docs\n * attached.\n *\n * function f(/** string &#42;/ x) {}\n * annotates 'x' as a string.\n *\n * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n *   Using Inline Doc Comments</a>\n */\nprivate Node transformParameter(AstNode node) {\n    Node irNode = justTransform(node);\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n        JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n        if (info != null) {\n            irNode.setJSDocInfo(info);\n        }\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -4.138169221959561,
      "mean_entropy": -0.02492873025276844
    },
    {
      "patch": "\n/**\n * Parameter NAMEs are special, because they can have inline type docs\n * attached.\n *\n * function f(/** string &#42;/ x) {}\n * annotates 'x' as a string.\n *\n * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n *   Using Inline Doc Comments</a>\n */\nprivate Node transformParameter(AstNode node) {\n  Node irNode = justTransform(node);\n  Comment comment = node.getJsDocNode();\n  if (comment != null) {\n    JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.21290508683354,
      "mean_entropy": -0.013330753535141807
    },
    {
      "patch": "\n/**\n * Parameter NAMEs are special, because they can have inline type docs\n * attached.\n *\n * function f(/** string &#42;/ x) {}\n * annotates 'x' as a string.\n *\n * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n *   Using Inline Doc Comments</a>\n */\nprivate Node transformParameter(AstNode node) {\n  Node irNode = justTransform(node);\n  Comment comment = node.getJsDocNode();\n  if (comment != null) {\n    JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.2137602024397807,
      "mean_entropy": -0.013335904833974583
    },
    {
      "patch": "\n  /**\n   * Parameter NAMEs are special, because they can have inline type docs\n   * attached.\n   *\n   * function f(/** string &#42;/ x) {}\n   * annotates 'x' as a string.\n   *\n   * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n   *   Using Inline Doc Comments</a>\n   */\n  private Node transformParameter(AstNode node) {\n    Node irNode = justTransform(node);\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n      if (info != null) {\n        irNode.setJSDocInfo(info);\n      }\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.8578781846487082,
      "mean_entropy": -0.016055495419374767
    },
    {
      "patch": "\n  /**\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode\n   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n   */\n  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = comment.startsWith(\"/*!\") ? 2 : 3; // Adjust the number of opening chars based on the comment style\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -9.209775810579485,
      "mean_entropy": -0.02980509971061322
    },
    {
      "patch": "\n/**\n * Creates a JsDocInfoParser and parses the JsDoc string.\n *\n * Used both for handling individual JSDoc comments and for handling\n * file-level JSDoc comments (@fileoverview and @license).\n *\n * @param node The JsDoc Comment node to parse.\n * @param irNode\n * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n */\nprivate JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n  String comment = node.getValue();\n  int lineno = node.getLineno();\n  int position = node.getAbsolutePosition();\n\n  // The JsDocInfoParser expects the comment without the initial '/**'.\n  int numOpeningChars = 3;\n  if (comment.startsWith(\"/*!\")) {\n    numOpeningChars = 2;\n  }\n  JsDocInfoParser jsdocParser =\n    new JsDocInfoParser(\n        new JsDocTokenStream(comment.substring(numOpeningChars),\n                             lineno,\n                             position2charno(position) + numOpeningChars),\n        node,\n        irNode,\n        config,\n        errorReporter);\n  jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n  jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n  jsdocParser.parse();\n  return jsdocParser;\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -4.788046973027197,
      "mean_entropy": -0.016341457245826613
    },
    {
      "patch": "\n  /**\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode The IR node associated with the JsDoc comment.\n   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n   */\n  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -7.137515563303027,
      "mean_entropy": -0.024113228254402118
    },
    {
      "patch": "\n  /**\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode\n   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n   */\n  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = comment.startsWith(\"/*!\") ? 2 : 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -3.56544096672204,
      "mean_entropy": -0.012045408671358244
    },
    {
      "patch": "\n/**\n * Creates a JsDocInfoParser and parses the JsDoc string.\n *\n * Used both for handling individual JSDoc comments and for handling\n * file-level JSDoc comments (@fileoverview and @license).\n *\n * @param node The JsDoc Comment node to parse.\n * @param irNode\n * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n */\nprivate JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = comment.startsWith(\"/*!\") ? 3 : 2;\n    JsDocInfoParser jsdocParser =\n        new JsDocInfoParser(\n            new JsDocTokenStream(comment.substring(numOpeningChars),\n                    lineno,\n                    position2charno(position) + numOpeningChars),\n            node,\n            irNode,\n            config,\n            errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -8.860205859726047,
      "mean_entropy": -0.031308147914226314
    },
    {
      "patch": "\nprivate JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = comment.startsWith(\"/*!\") ? 2 : 3; // Adjust for /*! comment style\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -13.24450968924786,
      "mean_entropy": -0.07082625502271582
    },
    {
      "patch": "\n/**\n* Creates a JsDocInfoParser and parses the JsDoc string.\n*\n* Used both for handling individual JSDoc comments and for handling\n* file-level JSDoc comments (@fileoverview and @license).\n*\n* @param node The JsDoc Comment node to parse.\n* @param irNode\n* @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n* normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n*/\nprivate JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n  String comment = node.getValue();\n  int lineno = node.getLineno();\n  int position = node.getAbsolutePosition();\n\n  // The JsDocInfoParser expects the comment without the initial '/**'.\n  int numOpeningChars = 3;\n  if (comment.startsWith(\"/*!\")) {\n    numOpeningChars = 2;\n  }\n  JsDocInfoParser jsdocParser =\n    new JsDocInfoParser(\n        new JsDocTokenStream(comment.substring(numOpeningChars),\n                             lineno,\n                             position2charno(position) + numOpeningChars),\n        node,\n        irNode,\n        config,\n        errorReporter);\n  jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n  jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n  jsdocParser.parse();\n  return jsdocParser;\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -6.609726816921877,
      "mean_entropy": -0.02263605074288314
    },
    {
      "patch": "\n/**\n * Creates a JsDocInfoParser and parses the JsDoc string.\n *\n * Used both for handling individual JSDoc comments and for handling\n * file-level JSDoc comments (@fileoverview and @license).\n *\n * @param node The JsDoc Comment node to parse.\n * @param irNode\n * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n */\nprivate JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    // Check if the comment starts with '/**' or '/*!' and adjust the numOpeningChars accordingly\n    if (comment.startsWith(\"/*!\")) {\n        numOpeningChars = 2;\n    }\n    JsDocInfoParser jsdocParser =\n        new JsDocInfoParser(\n            new JsDocTokenStream(comment.substring(numOpeningChars),\n                                 lineno,\n                                 position2charno(position) + numOpeningChars),\n            node,\n            irNode,\n            config,\n            errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -13.986884491408793,
      "mean_entropy": -0.04426229269433162
    },
    {
      "patch": "\n/**\n * Creates a JsDocInfoParser and parses the JsDoc string.\n *\n * Used both for handling individual JSDoc comments and for handling\n * file-level JSDoc comments (@fileoverview and @license).\n *\n * @param node The JsDoc Comment node to parse.\n * @param irNode\n * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n */\nprivate JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n  String comment = node.getValue();\n  int lineno = node.getLineno();\n  int position = node.getAbsolutePosition();\n\n  // The JsDocInfoParser expects the comment without the initial '/**'.\n  int numOpeningChars = 3;\n  if (comment.startsWith(\"/*!\")) {\n    numOpeningChars = 2; // Adjust for '/*!' comments\n  }\n  JsDocInfoParser jsdocParser =\n    new JsDocInfoParser(\n        new JsDocTokenStream(comment.substring(numOpeningChars),\n                             lineno,\n                             position2charno(position) + numOpeningChars),\n        node,\n        irNode,\n        config,\n        errorReporter);\n  jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n  jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n  jsdocParser.parse();\n  return jsdocParser;\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -11.452706160621956,
      "mean_entropy": -0.0380488576764849
    },
    {
      "patch": "\n  /**\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode\n   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n   */\n  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = comment.startsWith(\"/*!\") ? 2 : 3; // Adjust based on the comment type\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -9.350284510693172,
      "mean_entropy": -0.030757514837806487
    },
    {
      "patch": "\n  /**\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode\n   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n   */\n  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    if (comment.startsWith(\"/*!\")) {\n        numOpeningChars = 2;\n    }\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -4.416414976926082,
      "mean_entropy": -0.014432728682764974
    },
    {
      "patch": "\n  /**\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode The IR node.\n   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n   */\n  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -6.245370775577634,
      "mean_entropy": -0.021535761295095292
    },
    {
      "patch": "\n  /**\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode\n   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n   */\n  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    if (comment.startsWith(\"/*!\")) {\n      numOpeningChars = 2;\n    }\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -3.6218105822741307,
      "mean_entropy": -0.011835982295013498
    },
    {
      "patch": "\nprivate JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = comment.startsWith(\"/*!\") ? 2 : 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -5.744803457346123,
      "mean_entropy": -0.03191557476303401
    },
    {
      "patch": "\n/**\n * Creates a JsDocInfoParser and parses the JsDoc string.\n *\n * Used both for handling individual JSDoc comments and for handling\n * file-level JSDoc comments (@fileoverview and @license).\n *\n * @param node The JsDoc Comment node to parse.\n * @param irNode The IR node to associate with the JsDoc.\n * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n */\nprivate JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n  String comment = node.getValue();\n  int lineno = node.getLineno();\n  int position = node.getAbsolutePosition();\n\n  // The JsDocInfoParser expects the comment without the initial '/**'.\n  int numOpeningChars = 3;\n  JsDocInfoParser jsdocParser =\n    new JsDocInfoParser(\n        new JsDocTokenStream(comment.substring(numOpeningChars),\n                             lineno,\n                             position2charno(position) + numOpeningChars),\n        node,\n        irNode,\n        config,\n        errorReporter);\n  jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n  jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n  jsdocParser.parse();\n  return jsdocParser;\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -9.514093886995997,
      "mean_entropy": -0.03361870631447349
    },
    {
      "patch": "\n/**\n * Creates a JsDocInfoParser and parses the JsDoc string.\n *\n * Used both for handling individual JSDoc comments and for handling\n * file-level JSDoc comments (@fileoverview and @license).\n *\n * @param node The JsDoc Comment node to parse.\n * @param irNode The IR node.\n * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n * normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n */\nprivate JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n  String comment = node.getValue();\n  int lineno = node.getLineno();\n  int position = node.getAbsolutePosition();\n\n  // The JsDocInfoParser expects the comment without the initial '/**'.\n  int numOpeningChars = 3;\n  JsDocInfoParser jsdocParser =\n    new JsDocInfoParser(\n        new JsDocTokenStream(comment.substring(numOpeningChars),\n                             lineno,\n                             position2charno(position) + numOpeningChars),\n        node,\n        irNode,\n        config,\n        errorReporter);\n  jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n  jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n  jsdocParser.parse();\n  return jsdocParser;\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -9.270847988341169,
      "mean_entropy": -0.033590028943265106
    },
    {
      "patch": "\n  /**\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode\n   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n   */\n  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    if (comment.startsWith(\"/*!\")) {\n        numOpeningChars = 2;\n    }\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -4.182875961820845,
      "mean_entropy": -0.013669529286996227
    },
    {
      "patch": "\n  /**\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @param irNode\n   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n   */\n  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    if (comment.startsWith(\"/*!\")) {\n      numOpeningChars = 2;\n    }\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          irNode,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -3.6228258647327616,
      "mean_entropy": -0.011839300211544973
    },
    {
      "patch": "\n  /**\n   * Expect the type to be anything but the null or void type. If the\n   * expectation is not met, issue a warning at the provided node's\n   * source code position. Note that a union type that includes the\n   * void type and at least one other type meets the expectation.\n   * @return Whether the expectation was met.\n   */\n  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.971718505501248,
      "mean_entropy": -0.009586188727423381
    },
    {
      "patch": "\n  /**\n   * Expect the type to be anything but the null or void type. If the\n   * expectation is not met, issue a warning at the provided node's\n   * source code position. Note that a union type that includes the\n   * void type and at least one other type meets the expectation.\n   * @return Whether the expectation was met.\n   */\n  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.971718505501248,
      "mean_entropy": -0.009586188727423381
    },
    {
      "patch": "\n/**\n * Expect the type to be anything but the null or void type. If the\n * expectation is not met, issue a warning at the provided node's\n * source code position. Note that a union type that includes the\n * void type and at least one other type meets the expectation.\n * @return Whether the expectation was met.\n */\nboolean expectNotNullOrUndefined(\n    NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n  if (!type.isNoType() && !type.isUnknownType() &&\n      (type.isSubtype(getNativeType(VOID_TYPE)) || type.isSubtype(getNativeType(NULL_TYPE))) &&\n      !containsForwardDeclaredUnresolvedName(type)) {\n\n    // There's one edge case right now that we don't handle well, and\n    // that we don't want to warn about.\n    // if (this.x == null) {\n    //   this.initializeX();\n    //   this.x.foo();\n    // }\n    // In this case, we incorrectly type x because of how we\n    // infer properties locally. See issue 109.\n    // http://code.google.com/p/closure-compiler/issues/detail?id=109\n    //\n    // We do not do this inference globally.\n    if (n.isGetProp() &&\n        !t.inGlobalScope() && type.isSubtype(getNativeType(NULL_TYPE))) {\n      return true;\n    }\n\n    mismatch(t, n, msg, type, expectedType);\n    return false;\n  }\n  return true;\n}\n\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -7.552376441256755,
      "mean_entropy": -0.02330980383103937
    },
    {
      "patch": "\n  /**\n   * Expect the type to be anything but the null or void type. If the\n   * expectation is not met, issue a warning at the provided node's\n   * source code position. Note that a union type that includes the\n   * void type and at least one other type meets the expectation.\n   * @return Whether the expectation was met.\n   */\n  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType() && !type.isVoidType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -5.4169157189918495,
      "mean_entropy": -0.01708806220502161
    },
    {
      "patch": "\n  /**\n   * Expect the type to be anything but the null or void type. If the\n   * expectation is not met, issue a warning at the provided node's\n   * source code position. Note that a union type that includes the\n   * void type and at least one other type meets the expectation.\n   * @return Whether the expectation was met.\n   */\n  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        (type.isSubtype(nullOrUndefined) || type.isVoidType()) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -3.9708831081740774,
      "mean_entropy": -0.012526445136195828
    },
    {
      "patch": "\n  /**\n   * Expect the type to be anything but the null or void type. If the\n   * expectation is not met, issue a warning at the provided node's\n   * source code position. Note that a union type that includes the\n   * void type and at least one other type meets the expectation.\n   * @return Whether the expectation was met.\n   */\n  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -2.971718505501248,
      "mean_entropy": -0.009586188727423381
    },
    {
      "patch": "\n/**\n * Expect the type to be anything but the null or void type. If the\n * expectation is not met, issue a warning at the provided node's\n * source code position. Note that a union type that includes the\n * void type and at least one other type meets the expectation.\n * @return Whether the expectation was met.\n */\nboolean expectNotNullOrUndefined(\n    NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n  if (!type.isNoType() && !type.isUnknownType() &&\n      type.isSubtype(nullOrUndefined) &&\n      !containsForwardDeclaredUnresolvedName(type)) {\n\n    // There's one edge case right now that we don't handle well, and\n    // that we don't want to warn about.\n    // if (this.x == null) {\n    //   this.initializeX();\n    //   this.x.foo();\n    // }\n    // In this case, we incorrectly type x because of how we\n    // infer properties locally. See issue 109.\n    // http://code.google.com/p/closure-compiler/issues/detail?id=109\n    //\n    // We do not do this inference globally.\n    if (n.isGetProp() &&\n        !t.inGlobalScope() && type.isNullType()) {\n      return true;\n    }\n\n    if (n.getJSDocInfo() == null) {\n      mismatch(t, n, msg, type, expectedType);\n    }\n    return false;\n  }\n  return true;\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -8.737485422556812,
      "mean_entropy": -0.027563045497024645
    },
    {
      "patch": "\n/**\n * Expect the type to be anything but the null or void type. If the\n * expectation is not met, issue a warning at the provided node's\n * source code position. Note that a union type that includes the\n * void type and at least one other type meets the expectation.\n * @return Whether the expectation was met.\n */\nboolean expectNotNullOrUndefined(\n    NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n  if (!type.isNoType() && !type.isUnknownType() &&\n      (type.isSubtype(nullOrUndefined) || type.isVoidType()) &&\n      !containsForwardDeclaredUnresolvedName(type)) {\n\n    // There's one edge case right now that we don't handle well, and\n    // that we don't want to warn about.\n    // if (this.x == null) {\n    //   this.initializeX();\n    //   this.x.foo();\n    // }\n    // In this case, we incorrectly type x because of how we\n    // infer properties locally. See issue 109.\n    // http://code.google.com/p/closure-compiler/issues/detail?id=109\n    //\n    // We do not do this inference globally.\n    if (n.isGetProp() &&\n        !t.inGlobalScope() && type.isNullType()) {\n      return true;\n    }\n\n    mismatch(t, n, msg, type, expectedType);\n    return false;\n  }\n  return true;\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -5.188423195337835,
      "mean_entropy": -0.01684552985499297
    },
    {
      "patch": "\n/**\n * Expect the type to be anything but the null or void type. If the\n * expectation is not met, issue a warning at the provided node's\n * source code position. Note that a union type that includes the\n * void type and at least one other type meets the expectation.\n * @return Whether the expectation was met.\n */\nboolean expectNotNullOrUndefined(\n    NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n  if (!type.isNoType() && !type.isUnknownType() &&\n      type.isSubtype(nullOrUndefined) &&\n      !containsForwardDeclaredUnresolvedName(type)) {\n\n    // There's one edge case right now that we don't handle well, and\n    // that we don't want to warn about.\n    // if (this.x == null) {\n    //   this.initializeX();\n    //   this.x.foo();\n    // }\n    // In this case, we incorrectly type x because of how we\n    // infer properties locally. See issue 109.\n    // http://code.google.com/p/closure-compiler/issues/detail?id=109\n    //\n    // We do not do this inference globally.\n    if (n.isGetProp() &&\n        !t.inGlobalScope() && type.isNullType()) {\n      return true;\n    }\n\n    mismatch(t, n, msg, type, expectedType);\n    return false;\n  }\n  return true;\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -5.189760763159224,
      "mean_entropy": -0.017241730110163535
    },
    {
      "patch": "\n  /**\n   * Expect the type to be anything but the null or void type. If the\n   * expectation is not met, issue a warning at the provided node's\n   * source code position. Note that a union type that includes the\n   * void type and at least one other type meets the expectation.\n   * @return Whether the expectation was met.\n   */\n  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        (type.isSubtype(nullOrUndefined) || type.isVoidType()) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 173,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
        [
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning4",
          "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning5"
        ]
      ],
      "sum_entropy": -3.834914486594889,
      "mean_entropy": -0.012097522039731511
    }
  ],
  "Closure_35": [
    {
      "patch": "\n  /**\n   * Expect that the property in an interface that this type implements is\n   * implemented and correctly typed.\n   */\n  private void expectInterfaceProperty(NodeTraversal t, Node n,\n      ObjectType instance, ObjectType implementedInterface, String prop) {\n    StaticSlot<JSType> propSlot = instance.getSlot(prop);\n    if (propSlot == null) {\n      // Not implemented\n      String sourceName = n.getSourceFileName();\n      sourceName = sourceName == null ? \"\" : sourceName;\n      registerMismatch(instance, implementedInterface,\n          report(JSError.make(sourceName, n,\n          INTERFACE_METHOD_NOT_IMPLEMENTED,\n          prop, implementedInterface.toString(), instance.toString())));\n    } else {\n      Node propNode = propSlot.getDeclaration() == null ?\n          null : propSlot.getDeclaration().getNode();\n\n      // Fall back on the constructor node if we can't find a node for the\n      // property.\n      propNode = propNode == null ? n : propNode;\n\n      JSType found = propSlot.getType();\n      JSType required\n          = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n      found = found.restrictByNotNullOrUndefined();\n      required = required.restrictByNotNullOrUndefined();\n      if (!found.canAssignTo(required)) {\n        // Implemented, but not correctly typed\n        FunctionType constructor =\n            implementedInterface.toObjectType().getConstructor();\n        registerMismatch(instance, implementedInterface,\n            report(t.makeError(propNode,\n            HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n            constructor.getTopMostDefiningType(prop).toString(),\n            required.toString(), found.toString())));\n      }\n    }\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.TypeCheckTest::testIssue669\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.TypeCheckTest::testIssue669",
        [
          "com.google.javascript.jscomp.TypeCheckTest::testIssue669"
        ]
      ],
      "sum_entropy": -3.335515239596371,
      "mean_entropy": -0.009927128689274914
    },
    {
      "patch": "\n  /**\n   * Expect that the property in an interface that this type implements is\n   * implemented and correctly typed.\n   */\n  private void expectInterfaceProperty(NodeTraversal t, Node n,\n      ObjectType instance, ObjectType implementedInterface, String prop) {\n    StaticSlot<JSType> propSlot = instance.getSlot(prop);\n    if (propSlot == null) {\n      // Not implemented\n      String sourceName = n.getSourceFileName();\n      sourceName = sourceName == null ? \"\" : sourceName;\n      registerMismatch(instance, implementedInterface,\n          report(JSError.make(sourceName, n,\n          INTERFACE_METHOD_NOT_IMPLEMENTED,\n          prop, implementedInterface.toString(), instance.toString())));\n    } else {\n      Node propNode = propSlot.getDeclaration() == null ?\n          null : propSlot.getDeclaration().getNode();\n\n      // Fall back on the constructor node if we can't find a node for the\n      // property.\n      propNode = propNode == null ? n : propNode;\n\n      JSType found = propSlot.getType();\n      JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n      found = found.restrictByNotNullOrUndefined();\n      required = required.restrictByNotNullOrUndefined();\n      if (!found.canAssignTo(required)) {\n        // Implemented, but not correctly typed\n        FunctionType constructor = implementedInterface.toObjectType().getConstructor();\n        registerMismatch(instance, implementedInterface,\n            report(t.makeError(propNode, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n            constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString())));\n      }\n    }\n  }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.TypeCheckTest::testIssue669\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.TypeCheckTest::testIssue669",
        [
          "com.google.javascript.jscomp.TypeCheckTest::testIssue669"
        ]
      ],
      "sum_entropy": -6.0920259086696715,
      "mean_entropy": -0.018404912110784506
    },
    {
      "patch": "\n  /**\n   * Expect that the property in an interface that this type implements is\n   * implemented and correctly typed.\n   */\n  private void expectInterfaceProperty(NodeTraversal t, Node n,\n      ObjectType instance, ObjectType implementedInterface, String prop) {\n    StaticSlot<JSType> propSlot = instance.getSlot(prop);\n    if (propSlot == null) {\n      // Not implemented\n      String sourceName = n.getSourceFileName();\n      sourceName = sourceName == null ? \"\" : sourceName;\n      registerMismatch(instance, implementedInterface,\n          report(JSError.make(sourceName, n,\n          INTERFACE_METHOD_NOT_IMPLEMENTED,\n          prop, implementedInterface.toString(), instance.toString())));\n    } else {\n      Node propNode = propSlot.getDeclaration() == null ?\n          null : propSlot.getDeclaration().getNode();\n\n      // Fall back on the constructor node if we can't find a node for the\n      // property.\n      propNode = propNode == null ? n : propNode;\n\n      JSType found = propSlot.getType();\n      JSType required\n          = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n      found = found.restrictByNotNullOrUndefined();\n      required = required.restrictByNotNullOrUndefined();\n      if (!found.isSubtype(required)) {\n        // Implemented, but not correctly typed\n        FunctionType constructor =\n            implementedInterface.toObjectType().getConstructor();\n        registerMismatch(instance, implementedInterface, report(t.makeError(propNode,\n            HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n            constructor.getTopMostDefiningType(prop).toString(),\n            required.toString(), found.toString())));\n      }\n    }\n  }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.TypeCheckTest::testIssue669\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.TypeCheckTest::testIssue669",
        [
          "com.google.javascript.jscomp.TypeCheckTest::testIssue669"
        ]
      ],
      "sum_entropy": -5.893891847931665,
      "mean_entropy": -0.01759370700875124
    },
    {
      "patch": "\n  /**\n   * Expect that the property in an interface that this type implements is\n   * implemented and correctly typed.\n   */\n  private void expectInterfaceProperty(NodeTraversal t, Node n,\n      ObjectType instance, ObjectType implementedInterface, String prop) {\n    StaticSlot<JSType> propSlot = instance.getSlot(prop);\n    if (propSlot == null) {\n      // Not implemented\n      String sourceName = n.getSourceFileName();\n      sourceName = sourceName == null ? \"\" : sourceName;\n      registerMismatch(instance, implementedInterface,\n          report(JSError.make(sourceName, n,\n          INTERFACE_METHOD_NOT_IMPLEMENTED,\n          prop, implementedInterface.toString(), instance.toString())));\n    } else {\n      Node propNode = propSlot.getDeclaration() == null ?\n          null : propSlot.getDeclaration().getNode();\n\n      // Fall back on the constructor node if we can't find a node for the\n      // property.\n      propNode = propNode == null ? n : propNode;\n\n      JSType found = propSlot.getType();\n      JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n      found = found.restrictByNotNullOrUndefined();\n      required = required.restrictByNotNullOrUndefined();\n      if (!found.canAssignTo(required)) {\n        // Implemented, but not correctly typed\n        FunctionType constructor = implementedInterface.toObjectType().getConstructor();\n        registerMismatch(instance, implementedInterface,\n            report(t.makeError(propNode, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n                constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString())));\n      }\n    }\n  }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.TypeCheckTest::testIssue669\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.TypeCheckTest::testIssue669",
        [
          "com.google.javascript.jscomp.TypeCheckTest::testIssue669"
        ]
      ],
      "sum_entropy": -8.709881630332669,
      "mean_entropy": -0.026313841783482384
    },
    {
      "patch": "\n/**\n * Expect that the property in an interface that this type implements is\n * implemented and correctly typed.\n */\nprivate void expectInterfaceProperty(NodeTraversal t, Node n,\n    ObjectType instance, ObjectType implementedInterface, String prop) {\n  StaticSlot<JSType> propSlot = instance.getSlot(prop);\n  if (propSlot == null) {\n    // Not implemented\n    String sourceName = n.getSourceFileName();\n    sourceName = sourceName == null ? \"\" : sourceName;\n    registerMismatch(instance, implementedInterface,\n        report(JSError.make(sourceName, n,\n            INTERFACE_METHOD_NOT_IMPLEMENTED,\n            prop, implementedInterface.toString(), instance.toString())));\n  } else {\n    Node propNode = propSlot.getDeclaration() == null ?\n        null : propSlot.getDeclaration().getNode();\n\n    // Fall back on the constructor node if we can't find a node for the\n    // property.\n    propNode = propNode == null ? n : propNode;\n\n    JSType found = propSlot.getType();\n    JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n    found = found.restrictByNotNullOrUndefined();\n    required = required.restrictByNotNullOrUndefined();\n    if (!found.canAssignTo(required)) {\n      // Implemented, but not correctly typed\n      FunctionType constructor =\n          implementedInterface.toObjectType().getConstructor();\n      registerMismatch(found, required, report(t.makeError(propNode,\n          HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n          constructor.getTopMostDefiningType(prop).toString(),\n          required.toString(), found.toString())));\n    }\n  }\n}\n\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.TypeCheckTest::testIssue669\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.TypeCheckTest::testIssue669",
        [
          "com.google.javascript.jscomp.TypeCheckTest::testIssue669"
        ]
      ],
      "sum_entropy": -9.755351254554157,
      "mean_entropy": -0.029741924556567552
    },
    {
      "patch": "\n  /**\n   * Expect that the property in an interface that this type implements is\n   * implemented and correctly typed.\n   */\n  private void expectInterfaceProperty(NodeTraversal t, Node n,\n      ObjectType instance, ObjectType implementedInterface, String prop) {\n    StaticSlot<JSType> propSlot = instance.getSlot(prop);\n    if (propSlot == null) {\n      // Not implemented\n      String sourceName = n.getSourceFileName();\n      sourceName = sourceName == null ? \"\" : sourceName;\n      registerMismatch(instance, implementedInterface,\n          report(JSError.make(sourceName, n,\n          INTERFACE_METHOD_NOT_IMPLEMENTED,\n          prop, implementedInterface.toString(), instance.toString())));\n    } else {\n      Node propNode = propSlot.getDeclaration() == null ?\n          null : propSlot.getDeclaration().getNode();\n\n      // Fall back on the constructor node if we can't find a node for the\n      // property.\n      propNode = propNode == null ? n : propNode;\n\n      JSType found = propSlot.getType();\n      JSType required\n          = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n      found = found.restrictByNotNullOrUndefined();\n      required = required.restrictByNotNullOrUndefined();\n      if (!found.isSubtype(required)) {\n        // Implemented, but not correctly typed\n        FunctionType constructor =\n            implementedInterface.toObjectType().getConstructor();\n        registerMismatch(found, required, report(t.makeError(propNode,\n            HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n            constructor.getTopMostDefiningType(prop).toString(),\n            required.toString(), found.toString())));\n      }\n    }\n  }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.javascript.jscomp.TypeCheckTest::testIssue669\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.javascript.jscomp.TypeCheckTest::testIssue669",
        [
          "com.google.javascript.jscomp.TypeCheckTest::testIssue669"
        ]
      ],
      "sum_entropy": -6.098766800066363,
      "mean_entropy": -0.018259780838522043
    }
  ],
  "Codec_7": [
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.3238029695172295,
      "mean_entropy": -0.011031691412643579
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }    \n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -2.7086382228522297,
      "mean_entropy": -0.022954561210612116
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.3238029695172295,
      "mean_entropy": -0.011031691412643579
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.3238029695172295,
      "mean_entropy": -0.011031691412643579
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.3238029695172295,
      "mean_entropy": -0.011031691412643579
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.3238029695172295,
      "mean_entropy": -0.011031691412643579
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */\n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -4.842960852164829,
      "mean_entropy": -0.04174966251866232
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */\n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -3.054658354074829,
      "mean_entropy": -0.025886935204023975
    },
    {
      "patch": "\n/**\n * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n * url-safe variation emits - and _ instead of + and / characters.\n *\n * @param binaryData binary data to encode\n * @return String containing Base64 characters\n * @since 1.4\n */\npublic static String encodeBase64URLSafeString(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -4.545566190085199,
      "mean_entropy": -0.043707367212357684
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.3238029695172295,
      "mean_entropy": -0.011031691412643579
    },
    {
      "patch": "\n/**\n * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n * url-safe variation emits - and _ instead of + and / characters.\n *\n * @param binaryData\n *            binary data to encode\n * @return String containing Base64 characters\n * @since 1.4\n */\npublic static String encodeBase64URLSafeString(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -2.6595345301914692,
      "mean_entropy": -0.024855462898985693
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.3238029695172295,
      "mean_entropy": -0.011031691412643579
    },
    {
      "patch": "\n/**\n * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n * url-safe variation emits - and _ instead of + and / characters.\n *\n * @param binaryData\n *            binary data to encode\n * @return String containing Base64 characters\n * @since 1.4\n */    \npublic static String encodeBase64URLSafeString(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -3.5627876865466908,
      "mean_entropy": -0.03298877487543232
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.3238029695172295,
      "mean_entropy": -0.011031691412643579
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.3238029695172295,
      "mean_entropy": -0.011031691412643579
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.3238029695172295,
      "mean_entropy": -0.011031691412643579
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.45824065336757,
      "mean_entropy": -0.01215200544472975
    },
    {
      "patch": "\n/**\n * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n * url-safe variation emits - and _ instead of + and / characters.\n *\n * @param binaryData\n *            binary data to encode\n * @return String containing Base64 characters\n * @since 1.4\n */    \npublic static String encodeBase64URLSafeString(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n}    \n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -2.6267148612691096,
      "mean_entropy": -0.024098301479533117
    },
    {
      "patch": "\n/**\n * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n * url-safe variation emits - and _ instead of + and / characters.\n *\n * @param binaryData\n *            binary data to encode\n * @return String containing Base64 characters\n * @since 1.4\n */    \npublic static String encodeBase64URLSafeString(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n}    \n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -2.6267148612691096,
      "mean_entropy": -0.024098301479533117
    },
    {
      "patch": "\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    \n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.45824065336757,
      "mean_entropy": -0.01215200544472975
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7836455857891494,
      "mean_entropy": -0.0015395787540061876
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7836455857891494,
      "mean_entropy": -0.0015395787540061876
    },
    {
      "patch": "\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -2.7845550460667305,
      "mean_entropy": -0.01232104002684394
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7836455857891494,
      "mean_entropy": -0.0015395787540061876
    },
    {
      "patch": "\npublic Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n    if (lineSeparator == null) {\n        lineLength = 0;  // disable chunk-separating\n        lineSeparator = new byte[0];  // this just gets ignored\n    }\n    this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n    this.lineSeparator = new byte[lineSeparator.length];\n    System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n    if (lineLength > 0) {\n        this.encodeSize = 4 + lineSeparator.length;\n    } else {\n        this.encodeSize = 4;\n    }\n    this.decodeSize = this.encodeSize - 1;\n    if (containsBase64Byte(lineSeparator)) {\n        String sep = StringUtils.newStringUtf8(lineSeparator);\n        throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n    }\n    this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -3.9175940948894703,
      "mean_entropy": -0.01733448714552863
    },
    {
      "patch": "\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -2.7845550460667305,
      "mean_entropy": -0.01232104002684394
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7836455857891494,
      "mean_entropy": -0.0015395787540061876
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7836455857891494,
      "mean_entropy": -0.0015395787540061876
    },
    {
      "patch": "\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -2.7845550460667305,
      "mean_entropy": -0.01232104002684394
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7836455857891494,
      "mean_entropy": -0.0015395787540061876
    },
    {
      "patch": "\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -2.7845550460667305,
      "mean_entropy": -0.01232104002684394
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7836455857891494,
      "mean_entropy": -0.0015395787540061876
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7836455857891494,
      "mean_entropy": -0.0015395787540061876
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7836455857891494,
      "mean_entropy": -0.0015395787540061876
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7836455857891494,
      "mean_entropy": -0.0015395787540061876
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7836455857891494,
      "mean_entropy": -0.0015395787540061876
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7533699599625797,
      "mean_entropy": -0.0014800981531681331
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7533699599625797,
      "mean_entropy": -0.0014800981531681331
    },
    {
      "patch": "\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n     * STANDARD_ENCODE_TABLE.\n     * </p>\n     * <p>\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n     * </p>\n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param lineLength\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n     * @param lineSeparator\n     *            Each line of encoded data will end with this sequence of bytes.\n     * @param urlSafe\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n     *            operations. Decoding seamlessly handles both modes.\n     * @throws IllegalArgumentException\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\n     * @since 1.4\n     */\n    public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n        if (lineSeparator == null) {\n            lineLength = 0;  // disable chunk-separating\n            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n        }\n        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n        this.lineSeparator = new byte[lineSeparator.length];\n        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n        if (lineLength > 0) {\n            this.encodeSize = 4 + lineSeparator.length;\n        } else {\n            this.encodeSize = 4;\n        }\n        this.decodeSize = this.encodeSize - 1;\n        if (containsBase64Byte(lineSeparator)) {\n            String sep = StringUtils.newStringUtf8(lineSeparator);\n            throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n        }\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -0.7533699599625797,
      "mean_entropy": -0.0014800981531681331
    },
    {
      "patch": "\n/**\n * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n * <p>\n * When encoding the line length and line separator are given in the constructor, and the encoding table is\n * STANDARD_ENCODE_TABLE.\n * </p>\n * <p>\n * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n * </p>\n * <p>\n * When decoding all variants are supported.\n * </p>\n * \n * @param lineLength\n *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n * @param lineSeparator\n *            Each line of encoded data will end with this sequence of bytes.\n * @param urlSafe\n *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n *            operations. Decoding seamlessly handles both modes.\n * @throws IllegalArgumentException\n *             The provided lineSeparator included some base64 characters. That's not going to work!\n * @since 1.4\n */\npublic Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n    if (lineSeparator == null) {\n        lineLength = 0;  // disable chunk-separating\n        lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n    }\n    this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n    this.lineSeparator = new byte[lineSeparator.length];\n    System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n    if (lineLength > 0) {\n        this.encodeSize = 4 + lineSeparator.length;\n    } else {\n        this.encodeSize = 4;\n    }\n    this.decodeSize = this.encodeSize - 1;\n    if (containsBase64Byte(lineSeparator)) {\n        String sep = StringUtils.newStringUtf8(lineSeparator);\n        throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n    }\n    this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -3.630964791009062,
      "mean_entropy": -0.0075331219730478466
    },
    {
      "patch": "\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.0600645920442302,
      "mean_entropy": -0.013087217185731238
    },
    {
      "patch": "\n/**\n * Decodes a String containing characters in the Base64 alphabet.\n *\n * @param pArray\n *            A String containing Base64 character data\n * @return a byte array containing binary data\n * @since 1.4\n */\npublic byte[] decode(String pArray) {\n    return decode(StringUtils.getBytesUtf8(pArray));\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -2.87251764346804,
      "mean_entropy": -0.0404579949784231
    },
    {
      "patch": "\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.0600645920442302,
      "mean_entropy": -0.013087217185731238
    },
    {
      "patch": "\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.0600645920442302,
      "mean_entropy": -0.013087217185731238
    },
    {
      "patch": "\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return Base64.decodeBase64(StringUtils.getBytesUtf8(pArray));\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.9649380469451296,
      "mean_entropy": -0.023116918199354467
    },
    {
      "patch": "\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.0600645920442302,
      "mean_entropy": -0.013087217185731238
    },
    {
      "patch": "\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return Base64.decodeBase64(StringUtils.getBytesUtf8(pArray));\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.9649380469451296,
      "mean_entropy": -0.023116918199354467
    },
    {
      "patch": "\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.0600645920442302,
      "mean_entropy": -0.013087217185731238
    },
    {
      "patch": "\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return Base64.decodeBase64(StringUtils.getBytesUtf8(pArray));\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.9649380469451296,
      "mean_entropy": -0.023116918199354467
    },
    {
      "patch": "\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.0600645920442302,
      "mean_entropy": -0.013087217185731238
    },
    {
      "patch": "\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return decode(StringUtils.getBytesUtf8(pArray));\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.1339256486562301,
      "mean_entropy": -0.01399908208217568
    },
    {
      "patch": "\n    /**\n     * Decodes a String containing characters in the Base64 alphabet.\n     *\n     * @param pArray\n     *            A String containing Base64 character data\n     * @return a byte array containing binary data\n     * @since 1.4\n     */\n    public byte[] decode(String pArray) {\n        return Base64.decodeBase64(StringUtils.getBytesUtf8(pArray));\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -1.91963129269903,
      "mean_entropy": -0.022583897561165057
    },
    {
      "patch": "\n/**\n * Decodes a String containing characters in the Base64 alphabet.\n *\n * @param pArray\n *            A String containing Base64 character data\n * @return a byte array containing binary data\n * @since 1.4\n */\npublic byte[] decode(String pArray) {\n    return Base64.decodeBase64(StringUtils.getBytesUtf8(pArray));\n}\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.codec.binary.Base64Test::testByteToStringVariations\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
        [
          "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations",
          "org.apache.commons.codec.binary.Base64Test::testRfc4648Section10Encode"
        ]
      ],
      "sum_entropy": -3.5550007316831005,
      "mean_entropy": -0.04740000975577467
    }
  ],
  "Compress_10": [
    {
      "patch": "\n    /**\n     * Reads an individual entry of the central directory, creates a\n     * ZipArchiveEntry from it and adds it to the global maps.\n     *\n     * @param noUTF8Flag map used to collect entries that don't have\n     * their UTF-8 flag set and whose name will be set by data read\n     * from the local file header later.  The current entry may be\n     * added to this map.\n     */\n    private void readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag) throws IOException {\n        byte[] cfh = new byte[CFH_LEN];\n\n        archive.readFully(cfh);\n        int off = 0;\n        ZipArchiveEntry ze = new ZipArchiveEntry();\n\n        int versionMadeBy = ZipShort.getValue(cfh, off);\n        off += SHORT;\n        ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n        off += SHORT; // skip version info\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        ze.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        ze.setMethod(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n        ze.setTime(time);\n        off += WORD;\n\n        ze.setCrc(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setCompressedSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        int fileNameLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int commentLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int diskStart = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        byte[] fileName = new byte[fileNameLen];\n        archive.readFully(fileName);\n        ze.setName(entryEncoding.decode(fileName), fileName);\n\n        // LFH offset,\n        OffsetEntry offset = new OffsetEntry();\n        offset.headerOffset = ZipLong.getValue(cfh, off);\n        // data offset will be filled later\n        entries.put(ze, offset);\n\n        nameMap.put(ze.getName(), ze);\n\n        byte[] cdExtraData = new byte[extraLen];\n        archive.readFully(cdExtraData);\n        ze.setCentralDirectoryExtra(cdExtraData);\n\n        setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n\n        byte[] comment = new byte[commentLen];\n        archive.readFully(comment);\n        ze.setComment(entryEncoding.decode(comment));\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            noUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n        }\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testReadWinZipArchive\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testReadWinZipArchive",
        [
          "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testReadWinZipArchive"
        ]
      ],
      "sum_entropy": -6.225176314816473,
      "mean_entropy": -0.009127824508528552
    },
    {
      "patch": "\n    /**\n     * Opens the given file for reading, assuming the specified\n     * encoding for file names.\n     *\n     * @param f the archive.\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     *\n     * @throws IOException if an error occurs while reading the file.\n     */\n    public ZipFile(File f, String encoding, boolean useUnicodeExtraFields)\n        throws IOException {\n        this.archiveName = f.getAbsolutePath();\n        this.encoding = encoding;\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        archive = new RandomAccessFile(f, \"r\");\n        boolean success = false;\n        try {\n            Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag =\n                populateFromCentralDirectory();\n            resolveLocalFileHeaderData(entriesWithoutUTF8Flag);\n            success = true;\n        } finally {\n            if (!success) {\n                try {\n                    closed = true;\n                    archive.close();\n                } catch (IOException e2) { // NOPMD\n                    // swallow, throw the original exception instead\n                }\n            }\n        }\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testReadWinZipArchive\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testReadWinZipArchive",
        [
          "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testReadWinZipArchive"
        ]
      ],
      "sum_entropy": -4.12776140962615,
      "mean_entropy": -0.014848062624554497
    }
  ],
  "Compress_17": [
    {
      "patch": "\n    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * In addition there are\n     * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n     * that seem to have parts of their header cleared to zero (no detectable\n     * magic bytes, etc.) but still have a reasonable-looking checksum field\n     * present. It looks like we can detect such cases reasonably well by\n     * checking whether the stored checksum is <em>greater than</em> the\n     * computed unsigned checksum. That check is unlikely to pass on some\n     * random file header, as it would need to have a valid sequence of\n     * octal digits in just the right place.\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -4.6975567240709655,
      "mean_entropy": -0.006908171653045537
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int CHKSUM_OFFSET = 148; // Offset for checksum in tar header\n        int CHKSUMLEN = 8; // Length of the checksum field\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                    digits++;\n                } else if (digits == 6) {\n                    break; // Exit the loop once we have processed the first 6 octal digits\n                }\n                b = ' '; // Replace the checksum digits with space\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -33.77307382489173,
      "mean_entropy": -0.13673309240846854
    },
    {
      "patch": "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    final int CHKSUM_OFFSET = 148;\n    final int CHKSUMLEN = 8;\n\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                digits = 6; // only look at the first octal digit sequence\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n\n    return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -7.148168814531165,
      "mean_entropy": -0.03234465526937179
    },
    {
      "patch": "\n    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * In addition there are\n     * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n     * that seem to have parts of their header cleared to zero (no detectable\n     * magic bytes, etc.) but still have a reasonable-looking checksum field\n     * present. It looks like we can detect such cases reasonably well by\n     * checking whether the stored checksum is <em>greater than</em> the\n     * computed unsigned checksum. That check is unlikely to pass on some\n     * random file header, as it would need to have a valid sequence of\n     * octal digits in just the right place.\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        int CHKSUM_OFFSET = 148;\n        int CHKSUMLEN = 8;\n        \n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -7.022765288611284,
      "mean_entropy": -0.010342806021518828
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n        \n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b & 0xFF; // Masking with 0xFF to treat bytes as unsigned\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -12.91937537609261,
      "mean_entropy": -0.05209425554876052
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b & 0xff; // mask the sign bit to treat bytes as unsigned\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -13.999926665866715,
      "mean_entropy": -0.057142557819864145
    },
    {
      "patch": "\n    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * In addition there are\n     * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n     * that seem to have parts of their header cleared to zero (no detectable\n     * magic bytes, etc.) but still have a reasonable-looking checksum field\n     * present. It looks like we can detect such cases reasonably well by\n     * checking whether the stored checksum is <em>greater than</em> the\n     * computed unsigned checksum. That check is unlikely to pass on some\n     * random file header, as it would need to have a valid sequence of\n     * octal digits in just the right place.\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148; // Define the offset where the checksum starts\n        final int CHKSUMLEN = 8; // Define the length of the checksum field\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -13.060694733896673,
      "mean_entropy": -0.018684827945488803
    },
    {
      "patch": "\n    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * In addition there are\n     * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n     * that seem to have parts of their header cleared to zero (no detectable\n     * magic bytes, etc.) but still have a reasonable-looking checksum field\n     * present. It looks like we can detect such cases reasonably well by\n     * checking whether the stored checksum is <em>greater than</em> the\n     * computed unsigned checksum. That check is unlikely to pass on some\n     * random file header, as it would need to have a valid sequence of\n     * octal digits in just the right place.\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                    digits++;\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += (0xff & b);\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -7.721892214438079,
      "mean_entropy": -0.011611867991636209
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                    digits++;\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -7.050071557624783,
      "mean_entropy": -0.030388239472520614
    },
    {
      "patch": "\n    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * In addition there are\n     * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n     * that seem to have parts of their header cleared to zero (no detectable\n     * magic bytes, etc.) but still have a reasonable-looking checksum field\n     * present. It looks like we can detect such cases reasonably well by\n     * checking whether the stored checksum is <em>greater than</em> the\n     * computed unsigned checksum. That check is unlikely to pass on some\n     * random file header, as it would need to have a valid sequence of\n     * octal digits in just the right place.\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                    digits++;\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += (0xff & b);\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -7.721892214438079,
      "mean_entropy": -0.011611867991636209
    },
    {
      "patch": "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                digits = 6; // only look at the first octal digit sequence\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b & 0xff;\n    }\n\n    return storedSum == unsignedSum || storedSum == signedSum\n            || storedSum > unsignedSum; // COMPRESS-177\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -8.567708931874154,
      "mean_entropy": -0.04022398559565331
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        int CHKSUM_OFFSET = 148; // Adding CHKSUM_OFFSET definition\n        int CHKSUMLEN = 8; // Adding CHKSUMLEN definition\n\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -17.197357440314086,
      "mean_entropy": -0.07287015864539867
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                    digits++;\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b & 0xff;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -11.503043239491422,
      "mean_entropy": -0.061186400210060755
    },
    {
      "patch": "\n    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * In addition there are\n     * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n     * that seem to have parts of their header cleared to zero (no detectable\n     * magic bytes, etc.) but still have a reasonable-looking checksum field\n     * present. It looks like we can detect such cases reasonably well by\n     * checking whether the stored checksum is <em>greater than</em> the\n     * computed unsigned checksum. That check is unlikely to pass on some\n     * random file header, as it would need to have a valid sequence of\n     * octal digits in just the right place.\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -4.6975567240709655,
      "mean_entropy": -0.006908171653045537
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        int CHKSUM_OFFSET = 148; // Offset for the checksum in the header\n        int CHKSUMLEN = 8; // Length of the checksum\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b & 0xFF; // Masking to get unsigned value for signed byte\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -21.837200542013466,
      "mean_entropy": -0.08496965191444929
    },
    {
      "patch": "\n/**\n * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n * <blockquote>\n * The checksum is calculated by taking the sum of the unsigned byte values\n * of the header block with the eight checksum bytes taken to be ascii\n * spaces (decimal value 32). It is stored as a six digit octal number with\n * leading zeroes followed by a NUL and then a space. Various\n * implementations do not adhere to this format. For better compatibility,\n * ignore leading and trailing whitespace, and get the first six digits. In\n * addition, some historic tar implementations treated bytes as signed.\n * Implementations typically calculate the checksum both ways, and treat it\n * as good if either the signed or unsigned sum matches the included\n * checksum.\n * </blockquote>\n * <p>\n * In addition there are\n * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n * that seem to have parts of their header cleared to zero (no detectable\n * magic bytes, etc.) but still have a reasonable-looking checksum field\n * present. It looks like we can detect such cases reasonably well by\n * checking whether the stored checksum is <em>greater than</em> the\n * computed unsigned checksum. That check is unlikely to pass on some\n * random file header, as it would need to have a valid sequence of\n * octal digits in just the right place.\n * <p>\n * The return value of this method should be treated as a best-effort\n * heuristic rather than an absolute and final truth. The checksum\n * verification logic may well evolve over time as more special cases\n * are encountered.\n *\n * @param header tar header\n * @return whether the checksum is reasonably good\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n * @since 1.5\n */\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits++ < 6) {\n                storedSum = storedSum * 8 + b - '0';\n            } else if (digits > 0) {\n                digits = 6; // only look at the first octal digit sequence\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b & 0xff;\n    }\n\n    return storedSum == unsignedSum || storedSum == signedSum\n            || storedSum > unsignedSum; // COMPRESS-177\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -9.391742470158176,
      "mean_entropy": -0.014978855614287362
    },
    {
      "patch": "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + (b - '0');\n                digits++;\n            } else if (digits > 0) {\n                digits = 6; // only look at the first octal digit sequence\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n\n    return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n}\n\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -8.419064419215559,
      "mean_entropy": -0.04126992362360568
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += (0xff & b);\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -9.970835974629471,
      "mean_entropy": -0.044913675561394015
    },
    {
      "patch": "\n    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * In addition there are\n     * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n     * that seem to have parts of their header cleared to zero (no detectable\n     * magic bytes, etc.) but still have a reasonable-looking checksum field\n     * present. It looks like we can detect such cases reasonably well by\n     * checking whether the stored checksum is <em>greater than</em> the\n     * computed unsigned checksum. That check is unlikely to pass on some\n     * random file header, as it would need to have a valid sequence of\n     * octal digits in just the right place.\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                    digits++;\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += (0xff & b);\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197"
        ]
      ],
      "sum_entropy": -7.925704068869301,
      "mean_entropy": -0.011918351983262106
    }
  ],
  "Compress_19": [
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -2.5225742908783113,
      "mean_entropy": -0.0059635326025491995
    },
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -2.5225742908783113,
      "mean_entropy": -0.0059635326025491995
    },
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC_SHORT; // Changed ZIP64_MAGIC to ZIP64_MAGIC_SHORT\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -5.8350153165695415,
      "mean_entropy": -0.013413828313952969
    },
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            }\n            if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            }\n            if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -4.9076326961541605,
      "mean_entropy": -0.011601968548827803
    },
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -4.819846666462722,
      "mean_entropy": -0.011503214001104349
    },
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getSize().getLongValue());\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                ze.setSize(z64.getCompressedSize().getLongValue());\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -5.535163298286372,
      "mean_entropy": -0.013210413599728812
    },
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC_SHORT; // Changed to ZIP64_MAGIC_SHORT\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT); // Changed to ZIP64_MAGIC_SHORT\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -8.103623580784273,
      "mean_entropy": -0.018417326319964258
    },
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -4.02956086365724,
      "mean_entropy": -0.009526148613846904
    },
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -2.5225742908783113,
      "mean_entropy": -0.0059635326025491995
    },
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC_SHORT; // Change ZIP64_MAGIC to ZIP64_MAGIC_SHORT here\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT); // Change ZIP64_MAGIC to ZIP64_MAGIC_SHORT here\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -11.56203147839106,
      "mean_entropy": -0.025693403285313464
    },
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -2.5225742908783113,
      "mean_entropy": -0.0059635326025491995
    },
    {
      "patch": "\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -5.673136042967368,
      "mean_entropy": -0.02353998358077746
    },
    {
      "patch": "\n    /**\n     * If the entry holds a Zip64 extended information extra field,\n     * read sizes from there if the entry's sizes are set to\n     * 0xFFFFFFFFF, do the same for the offset of the local file\n     * header.\n     *\n     * <p>Ensures the Zip64 extra either knows both compressed and\n     * uncompressed size or neither of both as the internal logic in\n     * ExtraFieldUtils forces the field to create local header data\n     * even if they are never used - and here a field with only one\n     * size would be invalid.</p>\n     */\n    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -2.6310015047329793,
      "mean_entropy": -0.006219861713316736
    },
    {
      "patch": "\n    /**\n     * When using random access output, write the local file header\n     * and potentially the ZIP64 extra containing the correct CRC and\n     * compressed/uncompressed sizes.\n     */\n    private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n        throws IOException {\n        long save = raf.getFilePointer();\n\n        raf.seek(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            // seek to ZIP64 extra, skip header and size information\n            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n                     + getName(entry.entry).limit() + 2 * SHORT);\n            // inside the ZIP64 extra uncompressed size comes\n            // first, unlike the LFH, CD, or data descriptor\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                // do some cleanup:\n                // * rewrite version needed to extract\n                raf.seek(entry.localDataStart  - 5 * SHORT);\n                writeOut(ZipShort.getBytes(INITIAL_VERSION));\n\n                // * remove ZIP64 extra so it doesn't get written\n                //   to the central directory\n                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n                                             .HEADER_ID);\n                entry.entry.setExtra();\n\n                // * reset hasUsedZip64 if it has been set because\n                //   of this entry\n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        raf.seek(save);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -5.364058647061824,
      "mean_entropy": -0.012388126205685504
    },
    {
      "patch": "\n    /**\n     * When using random access output, write the local file header\n     * and potentially the ZIP64 extra containing the correct CRC and\n     * compressed/uncompressed sizes.\n     */\n    private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n        throws IOException {\n        long save = raf.getFilePointer();\n\n        raf.seek(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            // seek to ZIP64 extra, skip header and size information\n            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n                     + getName(entry.entry).limit() + 2 * SHORT);\n            // inside the ZIP64 extra uncompressed size comes\n            // first, unlike the LFH, CD or data descriptor\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                // do some cleanup:\n                // * rewrite version needed to extract\n                raf.seek(entry.localDataStart  - 5 * SHORT);\n                writeOut(ZipShort.getBytes(INITIAL_VERSION));\n\n                // * remove ZIP64 extra so it doesn't get written\n                //   to the central directory\n                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n                                             .HEADER_ID);\n                entry.entry.setExtra();\n\n                // * reset hasUsedZip64 if it has been set because\n                //   of this entry\n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        raf.seek(save);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -4.68784612847236,
      "mean_entropy": -0.010978562361761968
    },
    {
      "patch": "\n    /**\n     * When using random access output, write the local file header\n     * and potentially the ZIP64 extra containing the correct CRC and\n     * compressed/uncompressed sizes.\n     */\n    private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n        throws IOException {\n        long save = raf.getFilePointer();\n\n        raf.seek(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            // seek to ZIP64 extra, skip header and size information\n            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n                     + getName(entry.entry).limit() + 2 * SHORT);\n            // inside the ZIP64 extra uncompressed size comes\n            // first, unlike the LFH, CD or data descriptor\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                // do some cleanup:\n                // * rewrite version needed to extract\n                raf.seek(entry.localDataStart  - 5 * SHORT);\n                writeOut(ZipShort.getBytes(INITIAL_VERSION));\n\n                // * remove ZIP64 extra so it doesn't get written\n                //   to the central directory\n                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n                                             .HEADER_ID);\n\n                // * reset hasUsedZip64 if it has been set because\n                //   of this entry\n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        raf.seek(save);\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -6.156172042749911,
      "mean_entropy": -0.014622736443586486
    },
    {
      "patch": "\n    /**\n     * When using random access output, write the local file header\n     * and potentially the ZIP64 extra containing the correct CRC and\n     * compressed/uncompressed sizes.\n     */\n    private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n        throws IOException {\n        long save = raf.getFilePointer();\n\n        raf.seek(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            // seek to ZIP64 extra, skip header and size information\n            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n                     + getName(entry.entry).remaining() + 2 * SHORT);\n            // inside the ZIP64 extra uncompressed size comes\n            // first, unlike the LFH, CD, or data descriptor\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                // do some cleanup:\n                // * rewrite version needed to extract\n                raf.seek(entry.localDataStart  - 5 * SHORT);\n                writeOut(ZipShort.getBytes(INITIAL_VERSION));\n\n                // * remove ZIP64 extra so it doesn't get written\n                //   to the central directory\n                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n                                             .HEADER_ID);\n                entry.entry.setExtra();\n\n                // * reset hasUsedZip64 if it has been set because\n                //   of this entry\n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        raf.seek(save);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -6.260816742030363,
      "mean_entropy": -0.014628076500070942
    },
    {
      "patch": "\n    /**\n     * When using random access output, write the local file header\n     * and potentially the ZIP64 extra containing the correct CRC and\n     * compressed/uncompressed sizes.\n     */\n    private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n        throws IOException {\n        long save = raf.getFilePointer();\n\n        raf.seek(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            // seek to ZIP64 extra, skip header and size information\n            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n                     + getName(entry.entry).limit() + 2 * SHORT);\n            // inside the ZIP64 extra uncompressed size comes\n            // first, unlike the LFH, CD, or data descriptor\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                // do some cleanup:\n                // * rewrite version needed to extract\n                raf.seek(entry.localDataStart - 5 * SHORT);\n                writeOut(ZipShort.getBytes(INITIAL_VERSION));\n\n                // * remove ZIP64 extra so it doesn't get written\n                //   to the central directory\n                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n                                             .HEADER_ID);\n                entry.entry.setExtra();\n\n                // * reset hasUsedZip64 if it has been set because\n                //   of this entry\n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        raf.seek(save);\n    }\n\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -6.411576975579339,
      "mean_entropy": -0.014945400875476316
    },
    {
      "patch": "\n    /**\n     * When using random access output, write the local file header\n     * and potentially the ZIP64 extra containing the correct CRC and\n     * compressed/uncompressed sizes.\n     */\n    private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n        throws IOException {\n        long save = raf.getFilePointer();\n\n        raf.seek(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            // seek to ZIP64 extra, skip header and size information\n            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n                     + getName(entry.entry).limit() + 2 * SHORT);\n            // inside the ZIP64 extra uncompressed size comes\n            // first, unlike the LFH, CD, or data descriptor\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                // do some cleanup:\n                // * rewrite version needed to extract\n                raf.seek(entry.localDataStart  - 5 * SHORT);\n                writeOut(ZipShort.getBytes(INITIAL_VERSION));\n\n                // * remove ZIP64 extra so it doesn't get written\n                //   to the central directory\n                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n                                             .HEADER_ID);\n                entry.entry.setExtra();\n\n                // * reset hasUsedZip64 if it has been set because\n                //   of this entry\n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        raf.seek(save);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -5.364058647061824,
      "mean_entropy": -0.012388126205685504
    },
    {
      "patch": "\n    /**\n     * When using random access output, write the local file header\n     * and potentially the ZIP64 extra containing the correct CRC and\n     * compressed/uncompressed sizes.\n     */\n    private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n        throws IOException {\n        long save = raf.getFilePointer();\n\n        raf.seek(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            // seek to ZIP64 extra, skip header and size information\n            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n                     + getName(entry.entry).limit() + 2 * SHORT);\n            // inside the ZIP64 extra uncompressed size comes\n            // first, unlike the LFH, CD or data descriptor\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                // do some cleanup:\n                // * rewrite version needed to extract\n                raf.seek(entry.localDataStart  - 5 * SHORT);\n                writeOut(ZipShort.getBytes(INITIAL_VERSION));\n\n                // * remove ZIP64 extra so it doesn't get written\n                //   to the central directory\n                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n                                             .HEADER_ID);\n                entry.entry.setExtra();\n\n                // * reset hasUsedZip64 if it has been set because\n                //   of this entry\n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        raf.seek(save);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -5.477853619324216,
      "mean_entropy": -0.01268021671139865
    },
    {
      "patch": "\n    /**\n     * When using random access output, write the local file header\n     * and potentially the ZIP64 extra containing the correct CRC and\n     * compressed/uncompressed sizes.\n     */\n    private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n        throws IOException {\n        long save = raf.getFilePointer();\n\n        raf.seek(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            // seek to ZIP64 extra, skip header and size information\n            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n                     + getName(entry.entry).limit() + 2 * SHORT);\n            // inside the ZIP64 extra uncompressed size comes\n            // first, unlike the LFH, CD or data descriptor\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                // do some cleanup:\n                // * rewrite version needed to extract\n                raf.seek(entry.localDataStart  - 5 * SHORT);\n                writeOut(ZipShort.getBytes(INITIAL_VERSION));\n\n                // * remove ZIP64 extra so it doesn't get written\n                //   to the central directory\n                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n                                             .HEADER_ID);\n                entry.entry.setExtra();\n\n                // * reset hasUsedZip64 if it has been set because\n                //   of this entry\n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        raf.seek(save);\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -7.822146172517399,
      "mean_entropy": -0.018106819843790273
    },
    {
      "patch": "\n    /**\n     * When using random access output, write the local file header\n     * and potentially the ZIP64 extra containing the correct CRC and\n     * compressed/uncompressed sizes.\n     */\n    private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n        throws IOException {\n        long save = raf.getFilePointer();\n\n        raf.seek(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n            writeOut(ZipLong.ZIP64_MAGIC.getBytes());\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            // seek to ZIP64 extra, skip header and size information\n            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n                     + getName(entry.entry).limit() + 2 * SHORT);\n            // inside the ZIP64 extra uncompressed size comes\n            // first, unlike the LFH, CD, or data descriptor\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                // do some cleanup:\n                // * rewrite version needed to extract\n                raf.seek(entry.localDataStart - 5 * SHORT);\n                writeOut(ZipShort.getBytes(INITIAL_VERSION));\n\n                // * remove ZIP64 extra so it doesn't get written\n                //   to the central directory\n                entry.entry.removeExtraField(new Zip64ExtendedInformationExtraField()\n                                             .getHeaderId());\n                entry.entry.setExtra();\n\n                // * reset hasUsedZip64 if it has been set because\n                //   of this entry\n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        raf.seek(save);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -8.166588405520226,
      "mean_entropy": -0.019080814031589313
    },
    {
      "patch": "\n    /**\n     * When using random access output, write the local file header\n     * and potentially the ZIP64 extra containing the correct CRC and\n     * compressed/uncompressed sizes.\n     */\n    private void rewriteSizesAndCrc(boolean actuallyNeedsZip64)\n        throws IOException {\n        long save = raf.getFilePointer();\n\n        raf.seek(entry.localDataStart);\n        writeOut(ZipLong.getBytes(entry.entry.getCrc()));\n        if (!hasZip64Extra(entry.entry) || !actuallyNeedsZip64) {\n            writeOut(ZipLong.getBytes(entry.entry.getCompressedSize()));\n            writeOut(ZipLong.getBytes(entry.entry.getSize()));\n        } else {\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n        }\n\n        if (hasZip64Extra(entry.entry)) {\n            // seek to ZIP64 extra, skip header and size information\n            raf.seek(entry.localDataStart + 3 * WORD + 2 * SHORT\n                     + getName(entry.entry).limit() + 2 * SHORT);\n            // inside the ZIP64 extra uncompressed size comes\n            // first, unlike the LFH, CD or data descriptor\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getSize()));\n            writeOut(ZipEightByteInteger.getBytes(entry.entry.getCompressedSize()));\n\n            if (!actuallyNeedsZip64) {\n                // do some cleanup:\n                // * rewrite version needed to extract\n                raf.seek(entry.localDataStart  - 5 * SHORT);\n                writeOut(ZipShort.getBytes(INITIAL_VERSION));\n\n                // * remove ZIP64 extra so it doesn't get written\n                //   to the central directory\n                entry.entry.removeExtraField(Zip64ExtendedInformationExtraField\n                                             .HEADER_ID);\n                entry.entry.setExtra();\n\n                // * reset hasUsedZip64 if it has been set because\n                //   of this entry\n                if (entry.causedUseOfZip64) {\n                    hasUsedZip64 = false;\n                }\n            }\n        }\n        raf.seek(save);\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -5.178861726963603,
      "mean_entropy": -0.011988105849452783
    },
    {
      "patch": "\n    /**\n     * Not really for external usage, but marked \"package\" visibility\n     * to help us JUnit it.   Trims a byte array of leading zeroes while\n     * also enforcing a minimum length, and thus it really trims AND pads\n     * at the same time.\n     *\n     * @param array byte[] array to trim & pad.\n     * @return trimmed & padded byte[] array.\n     */\n    static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\n        if (array == null) {\n            return array;\n        }\n\n        int pos = 0;\n        for (byte b : array) {\n            if (b == 0) {\n                pos++;\n            } else {\n                break;\n            }\n        }\n\n        // Setting the minimum length to 1\n        final int MIN_LENGTH = 1;\n\n        byte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\n        int startPos = trimmedArray.length - (array.length - pos);\n        System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\n        return trimmedArray;\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -9.40035765493209,
      "mean_entropy": -0.03983202396157665
    },
    {
      "patch": "\n    /**\n     * Not really for external usage, but marked \"package\" visibility\n     * to help us JUnit it. Trims a byte array of leading zeroes while\n     * also enforcing a minimum length, and thus it really trims AND pads\n     * at the same time.\n     *\n     * @param array byte[] array to trim & pad.\n     * @return trimmed & padded byte[] array.\n     */\n    static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\n        if (array == null) {\n            return array;\n        }\n\n        int pos = 0;\n        for (byte b : array) {\n            if (b == 0) {\n                pos++;\n            } else {\n                break;\n            }\n        }\n\n        final int MIN_LENGTH = 1;\n\n        byte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\n        int startPos = trimmedArray.length - (array.length - pos);\n        System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\n        return trimmedArray;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -5.30591219719452,
      "mean_entropy": -0.023581831987531197
    },
    {
      "patch": "\n    static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\n        if (array == null) {\n            return null;\n        }\n\n        int pos = 0;\n        for (byte b : array) {\n            if (b == 0) {\n                pos++;\n            } else {\n                break;\n            }\n        }\n\n        final int MIN_LENGTH = 1;\n\n        byte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\n        int startPos = trimmedArray.length - (array.length - pos);\n        System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\n        return trimmedArray;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -4.212571195577109,
      "mean_entropy": -0.030748694858227073
    },
    {
      "patch": "\n    /**\n     * Not really for external usage, but marked \"package\" visibility\n     * to help us JUnit it.   Trims a byte array of leading zeroes while\n     * also enforcing a minimum length, and thus it really trims AND pads\n     * at the same time.\n     *\n     * @param array byte[] array to trim & pad.\n     * @return trimmed & padded byte[] array.\n     */\n    static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\n        if (array == null) {\n            return array;\n        }\n\n        int pos = 0;\n        for (byte b : array) {\n            if (b == 0) {\n                pos++;\n            } else {\n                break;\n            }\n        }\n\n        final int MIN_LENGTH = 1;\n\n        byte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\n        int startPos = trimmedArray.length - (array.length - pos);\n        System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\n        return trimmedArray;\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField",
        [
          "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField"
        ]
      ],
      "sum_entropy": -4.033514167705881,
      "mean_entropy": -0.017847407821707437
    }
  ],
  "Compress_24": [
    {
      "patch": "\n    /**\n     * Creates a new ArchiveEntry. The entryName must be an ASCII encoded string.\n     * \n     * @see org.apache.commons.compress.archivers.ArchiveOutputStream#createArchiveEntry(java.io.File, java.lang.String)\n     */\n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        CpioArchiveEntry entry = new CpioArchiveEntry(inputFile, entryName);\n        entry.setSize(inputFile.length()); // Set size of the entry\n        return entry;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -11.119104815919599,
      "mean_entropy": -0.08619461097612093
    },
    {
      "patch": "\n    /**\n     * Creates a new ArchiveEntry. The entryName must be an ASCII encoded string.\n     * \n     * @see org.apache.commons.compress.archivers.ArchiveOutputStream#createArchiveEntry(java.io.File, java.lang.String)\n     */\n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        CpioArchiveEntry cpioEntry = new CpioArchiveEntry(inputFile, entryName);\n        cpioEntry.setSize(inputFile.length());\n        return cpioEntry;\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -3.4965528618361,
      "mean_entropy": -0.027316819233094532
    },
    {
      "patch": "\n/**\n * Creates a new ArchiveEntry. The entryName must be an ASCII encoded string.\n * \n * @see org.apache.commons.compress.archivers.ArchiveOutputStream#createArchiveEntry(java.io.File, java.lang.String)\n */\n@Override\npublic ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n        throws IOException {\n    if(finished) {\n        throw new IOException(\"Stream has already been finished\");\n    }\n    CpioArchiveEntry cpioEntry = new CpioArchiveEntry(inputFile, entryName);\n    cpioEntry.setMode(CpioConstants.C_ISREG);\n    return cpioEntry;\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -8.402119675647292,
      "mean_entropy": -0.0683099160621731
    },
    {
      "patch": "\n    /**\n     * Creates a new ArchiveEntry. The entryName must be an ASCII encoded string.\n     * \n     * @see org.apache.commons.compress.archivers.ArchiveOutputStream#createArchiveEntry(java.io.File, java.lang.String)\n     */\n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        CpioArchiveEntry cpioArchiveEntry = new CpioArchiveEntry(inputFile, entryName);\n        cpioArchiveEntry.setSize(inputFile.length());\n        return cpioArchiveEntry;\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -6.495873564401601,
      "mean_entropy": -0.049586821102302295
    },
    {
      "patch": "\n    /**\n     * Creates a new ArchiveEntry. The entryName must be an ASCII encoded string.\n     * \n     * @see org.apache.commons.compress.archivers.ArchiveOutputStream#createArchiveEntry(java.io.File, java.lang.String)\n     */\n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        CpioArchiveEntry cpioEntry = new CpioArchiveEntry(inputFile, entryName);\n        cpioEntry.setMode(CpioConstants.C_ISREG);\n        return cpioEntry;\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -5.698020668728199,
      "mean_entropy": -0.0431668232479409
    },
    {
      "patch": "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    final int CHKSUM_OFFSET = 148; // Offset of the checksum field in the tar header\n    final int CHKSUMLEN = 8; // Length of the checksum field\n\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + (b - '0');\n                digits++;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n\n    return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -10.828012615708465,
      "mean_entropy": -0.051075531206172003
    },
    {
      "patch": "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    final int CHKSUM_OFFSET = 148;\n    final int CHKSUMLEN = 8;\n\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits++ < 6) {\n                storedSum = storedSum * 8 + b - '0';\n            } else if (digits > 0) {\n                digits = 6; // only look at the first octal digit sequence\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b & 0xFF; // Masking with 0xFF to treat bytes as unsigned\n    }\n\n    return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -13.606166678093754,
      "mean_entropy": -0.057409985983517944
    },
    {
      "patch": "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    final int CHKSUM_OFFSET = 148; // Constant for the offset of the checksum field in the header\n    final int CHKSUMLEN = 8; // Constant for the length of the checksum field\n\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits++ < 6) {\n                storedSum = storedSum * 8 + b - '0';\n            } else if (digits > 0) {\n                digits = 6; // only look at the first octal digit sequence\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b & 0xff; // Ensure byte is treated as unsigned\n    }\n\n    return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -16.652250951415326,
      "mean_entropy": -0.06556004311580838
    },
    {
      "patch": "\n/**\n * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n * <blockquote>\n * The checksum is calculated by taking the sum of the unsigned byte values\n * of the header block with the eight checksum bytes taken to be ascii\n * spaces (decimal value 32). It is stored as a six digit octal number with\n * leading zeroes followed by a NUL and then a space. Various\n * implementations do not adhere to this format. For better compatibility,\n * ignore leading and trailing whitespace, and get the first six digits. In\n * addition, some historic tar implementations treated bytes as signed.\n * Implementations typically calculate the checksum both ways, and treat it\n * as good if either the signed or unsigned sum matches the included\n * checksum.\n * </blockquote>\n * <p>\n * In addition there are\n * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n * that seem to have parts of their header cleared to zero (no detectable\n * magic bytes, etc.) but still have a reasonable-looking checksum field\n * present. It looks like we can detect such cases reasonably well by\n * checking whether the stored checksum is <em>greater than</em> the\n * computed unsigned checksum. That check is unlikely to pass on some\n * random file header, as it would need to have a valid sequence of\n * octal digits in just the right place.\n * <p>\n * The return value of this method should be treated as a best-effort\n * heuristic rather than an absolute and final truth. The checksum\n * verification logic may well evolve over time as more special cases\n * are encountered.\n *\n * @param header tar header\n * @return whether the checksum is reasonably good\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n * @since 1.5\n */\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + (b - '0');\n                digits++;\n            } else if (digits > 0) {\n                digits = 6; // only look at the first octal digit sequence\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n\n    return storedSum == unsignedSum || storedSum == signedSum\n            || storedSum > unsignedSum; // COMPRESS-177\n}\n\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -8.602562600065387,
      "mean_entropy": -0.013698348089276093
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                    digits++;\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -8.177512246107472,
      "mean_entropy": -0.04172200125565037
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n        \n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                    digits++;\n                } else if (digits > 0) {\n                    break; // Stop if more than 6 digits found\n                }\n                b = ' '; // Treat checksum bytes as spaces\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b & 0xff;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -23.983701389548955,
      "mean_entropy": -0.10337802323081446
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148; // Offset for the checksum in the header\n        final int CHKSUMLEN = 8; // Length of the checksum field\n\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                    digits++;\n                } else if (digits > 0) {\n                    digits = 6; // Only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -13.984144164790012,
      "mean_entropy": -0.05661596827850207
    },
    {
      "patch": "\n    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * In addition there are\n     * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n     * that seem to have parts of their header cleared to zero (no detectable\n     * magic bytes, etc.) but still have a reasonable-looking checksum field\n     * present. It looks like we can detect such cases reasonably well by\n     * checking whether the stored checksum is <em>greater than</em> the\n     * computed unsigned checksum. That check is unlikely to pass on some\n     * random file header, as it would need to have a valid sequence of\n     * octal digits in just the right place.\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n        \n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -5.2693866809501655,
      "mean_entropy": -0.00773771906160083
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b & 0xff; // Ensure b is treated as an unsigned byte\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -14.1748155226144,
      "mean_entropy": -0.06031836392601873
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148; // Offset of the checksum in the header\n        final int CHKSUMLEN = 8; // Length of the checksum field\n\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                    digits++;\n                }\n                b = ' ';\n            }\n            unsignedSum += (b & 0xff); // Masking to get unsigned value\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -17.332322273906275,
      "mean_entropy": -0.07842679761948541
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n        \n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                    digits++;\n                } else {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -11.314019758710455,
      "mean_entropy": -0.04984149673440729
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                    digits++;\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -7.685117893320646,
      "mean_entropy": -0.033125508160864854
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148; // Move the CHKSUM_OFFSET declaration here\n        final int CHKSUMLEN = 8; // Define CHKSUMLEN\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b & 0xff; // Ensure proper sign extension\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -27.09639287142652,
      "mean_entropy": -0.1097019954308766
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148; // Offset for the checksum field\n        final int CHKSUMLEN = 8; // Length of the checksum field\n\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                    digits++;\n                } else if (digits > 0) {\n                    digits = 6; // Only look at the first octal digit sequence\n                }\n                b = ' '; // Treat the checksum bytes as ASCII spaces\n            }\n            unsignedSum += 0xff & b; // Calculate unsigned sum\n            signedSum += b; // Calculate signed sum\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum || storedSum > unsignedSum;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -21.958267410093747,
      "mean_entropy": -0.08544072922215466
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        int CHKSUM_OFFSET = 148; // Added CHKSUM_OFFSET definition\n        int CHKSUMLEN = 8; // Added CHKSUMLEN definition\n\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b & 0xff; // Ensure byte is treated as unsigned\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -17.002523826896905,
      "mean_entropy": -0.06720365148971108
    },
    {
      "patch": "\n    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * In addition there are\n     * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n     * that seem to have parts of their header cleared to zero (no detectable\n     * magic bytes, etc.) but still have a reasonable-looking checksum field\n     * present. It looks like we can detect such cases reasonably well by\n     * checking whether the stored checksum is <em>greater than</em> the\n     * computed unsigned checksum. That check is unlikely to pass on some\n     * random file header, as it would need to have a valid sequence of\n     * octal digits in just the right place.\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148; // Offset for the checksum field\n        final int CHKSUMLEN = 8; // Length of the checksum field\n\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -10.090735673882511,
      "mean_entropy": -0.014477382602413933
    },
    {
      "patch": "\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148;\n        final int CHKSUMLEN = 8;\n\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b & 0xff;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -8.292459149652245,
      "mean_entropy": -0.03653065704692619
    },
    {
      "patch": "\n    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * In addition there are\n     * <a href=\"https://issues.apache.org/jira/browse/COMPRESS-117\">some tar files</a>\n     * that seem to have parts of their header cleared to zero (no detectable\n     * magic bytes, etc.) but still have a reasonable-looking checksum field\n     * present. It looks like we can detect such cases reasonably well by\n     * checking whether the stored checksum is <em>greater than</em> the\n     * computed unsigned checksum. That check is unlikely to pass on some\n     * random file header, as it would need to have a valid sequence of\n     * octal digits in just the right place.\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        final int CHKSUM_OFFSET = 148; // Offset for checksum in tar header\n        final int CHKSUMLEN = 8; // Length of checksum field in tar header\n\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6; // only look at the first octal digit sequence\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n\n        return storedSum == unsignedSum || storedSum == signedSum\n                || storedSum > unsignedSum; // COMPRESS-177\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -10.0283593983172,
      "mean_entropy": -0.014367277074953009
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        if (name == null) {\n            return false;\n        }\n\n        return enc.canEncode(name);\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -5.591229265779709,
      "mean_entropy": -0.05948116240191179
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n        enc.reset();\n\n        return enc.canEncode(name);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -5.818130956246129,
      "mean_entropy": -0.06687506846259919
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        return enc.canEncode(CharBuffer.wrap(name));\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -2.5275856362897087,
      "mean_entropy": -0.03045283899144227
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        return enc.canEncode(name);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -2.2177719735514994,
      "mean_entropy": -0.027722149669393743
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        return enc.canEncode(CharBuffer.wrap(name));\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -3.1901349330105293,
      "mean_entropy": -0.03709459224430848
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        return enc.canEncode(CharBuffer.wrap(name));\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -3.1901349330105293,
      "mean_entropy": -0.03709459224430848
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        return enc.canEncode(CharBuffer.wrap(name));\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -2.7968109360574993,
      "mean_entropy": -0.03369651730189758
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        return enc.canEncode(CharBuffer.wrap(name));\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -2.5275856362897087,
      "mean_entropy": -0.03045283899144227
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        // Catching potential exceptions when checking for encoding\n        try {\n            return enc.canEncode(name);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -17.688016988752057,
      "mean_entropy": -0.16377793508103758
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        return enc.canEncode(CharBuffer.wrap(name));\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -2.7968109360574993,
      "mean_entropy": -0.03369651730189758
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        return enc.canEncode(name);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -3.3598201025485,
      "mean_entropy": -0.04047976027166868
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        // Wrap the encoding operation in a try-catch block to handle potential exceptions\n        try {\n            return enc.canEncode(name);\n        } catch (Exception e) {\n            // Handle the exception, for example, by returning false\n            return false;\n        }\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -17.706272897416362,
      "mean_entropy": -0.1394194716331997
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n        enc.reset(); // Reset the encoder before use\n\n        return enc.canEncode(name);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -8.88733818541013,
      "mean_entropy": -0.0945461509086184
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        enc.reset(); // Resetting the encoder before encoding the name\n        return enc.canEncode(name);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -10.080897721830182,
      "mean_entropy": -0.10392678063742455
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        return enc.canEncode(name);\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -2.0399802921924794,
      "mean_entropy": -0.025499753652405994
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#canEncode(java.lang.String)\n     */\n    public boolean canEncode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n        enc.reset(); // Reset encoder before using it\n\n        return enc.canEncode(name);\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -8.32629068774868,
      "mean_entropy": -0.08857756050796467
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.position() + 1);\n\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -10.10686967432978,
      "mean_entropy": -0.03609596312260636
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() * 4); // Changed allocation logic\n\n        while (cb.hasRemaining()) { // Changed to hasRemaining()\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                   + (int) (cb.remaining() * enc.maxBytesPerChar())); // Adjusted buffer growth\n\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -30.4557823120912,
      "mean_entropy": -0.10118200103684784
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() * 4); // Allocate a larger buffer to avoid overflow\n\n        while (cb.hasRemaining()) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2); // Grow buffer size\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -17.460085238826924,
      "mean_entropy": -0.057434490917193826
    },
    {
      "patch": "\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() * 4);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.capacity() + res.length() * 6);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2);\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -15.526972261733281,
      "mean_entropy": -0.05793646366318388
    },
    {
      "patch": "\npublic ByteBuffer encode(String name) {\n    CharsetEncoder enc = this.charset.newEncoder();\n\n    enc.onMalformedInput(CodingErrorAction.REPORT);\n    enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n    CharBuffer cb = CharBuffer.wrap(name);\n    ByteBuffer out = ByteBuffer.allocate(name.length() * 2); // fixed the buffer allocation size\n\n    while (cb.remaining() > 0) {\n        CoderResult res = enc.encode(cb, out, true);\n\n        if (res.isUnmappable() || res.isMalformed()) {\n\n            // write the unmappable characters in utf-16\n            // pseudo-URL encoding style to ByteBuffer.\n            if (res.length() * 6 > out.remaining()) {\n                out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6);\n            }\n\n            for (int i = 0; i < res.length(); ++i) {\n                ZipEncodingHelper.appendSurrogate(out, cb.get());\n            }\n\n        } else if (res.isOverflow()) {\n\n            out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2); // fixed the buffer growth\n\n        } else if (res.isUnderflow()) {\n\n            enc.flush(out);\n            break;\n\n        }\n    }\n\n    out.limit(out.position());\n    out.rewind();\n    return out;\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -20.956995408083873,
      "mean_entropy": -0.0745800548330387
    },
    {
      "patch": "\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() * 6); // Changed allocation size calculation\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2); // Changed to grow buffer by doubling the capacity\n\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -26.99113134769625,
      "mean_entropy": -0.10883520704716229
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -5.7640539727304505,
      "mean_entropy": -0.018775420106613844
    },
    {
      "patch": "\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() * 4); // Change from (name.length() + (name.length() + 1) / 2) to (name.length() * 4)\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2); // Change from growBuffer(out, 0) to growBuffer(out, out.capacity() * 2)\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -17.095455227632677,
      "mean_entropy": -0.05325686986801457
    },
    {
      "patch": "\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() * 4); // Changed the allocation strategy\n\n        while (cb.hasRemaining()) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2); // Changed the buffer growth strategy\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n            }\n        }\n\n        out.flip();\n        return out;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -20.985820974160486,
      "mean_entropy": -0.07687113909948896
    },
    {
      "patch": "\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() * 6); // Fixed the allocation size\n\n        while (cb.hasRemaining()) { // Changed to hasRemaining() for clarity\n\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2); // Fixed the buffer growth logic\n\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -26.974463621889917,
      "mean_entropy": -0.10102795364003714
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() * 2); // Changed the calculation for buffer size\n\n        while (cb.hasRemaining()) { // Changed to use hasRemaining() for CharBuffer\n\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.position());\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -22.61305612195983,
      "mean_entropy": -0.07414116761298305
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() * 2); // Fixing buffer size calculation\n\n        while (cb.hasRemaining()) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, out.position());\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -19.30399905300404,
      "mean_entropy": -0.06521621301690554
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -5.517461273044629,
      "mean_entropy": -0.017972186557148627
    },
    {
      "patch": "\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() * 6); // Modified line\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                // write the unmappable characters in utf-16 pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.capacity() + res.length() * 6); // Modified line\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2); // Modified line\n\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 12,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal"
        ]
      ],
      "sum_entropy": -20.947808908195018,
      "mean_entropy": -0.07508175235912193
    }
  ],
  "Compress_44": [
    {
      "patch": "\n    private void nextBlock() throws IOException {\n        maybeFinishCurrentBlock();\n        long len = ByteUtils.fromLittleEndian(supplier, 4);\n        boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n        int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n        if (realLen == 0) {\n            verifyContentChecksum();\n            if (!decompressConcatenated) {\n                endReached = true;\n            } else {\n                init(false);\n            }\n            return;\n        }\n        InputStream capped = new BoundedInputStream(in, realLen);\n        if (expectBlockChecksum) {\n            capped = new ChecksumCalculatingInputStream(blockHash, capped);\n        }\n        if (uncompressed) {\n            inUncompressed = true;\n            currentBlock = capped;\n        } else {\n            inUncompressed = false;\n            BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n            if (expectBlockDependency) {\n                s.prefill(blockDependencyBuffer);\n            }\n            currentBlock = s;\n        }\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -1.852270076888641,
      "mean_entropy": -0.008088515619601052
    },
    {
      "patch": "\n    private void nextBlock() throws IOException {\n        maybeFinishCurrentBlock();\n        long len = ByteUtils.fromLittleEndian(supplier, 4);\n        boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n        int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n        if (realLen == 0) {\n            verifyContentChecksum();\n            if (!decompressConcatenated) {\n                endReached = true;\n            } else {\n                init(false);\n            }\n            return;\n        }\n        InputStream capped = new BoundedInputStream(in, realLen);\n        if (expectBlockChecksum) {\n            capped = new ChecksumCalculatingInputStream(blockHash, capped);\n        }\n        if (uncompressed) {\n            inUncompressed = true;\n            currentBlock = capped;\n        } else {\n            inUncompressed = false;\n            BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n            if (expectBlockDependency) {\n                s.prefill(blockDependencyBuffer);\n            }\n            currentBlock = s;\n        }\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -1.852270076888641,
      "mean_entropy": -0.008088515619601052
    },
    {
      "patch": "\n    private void nextBlock() throws IOException {\n        maybeFinishCurrentBlock();\n        long len = ByteUtils.fromLittleEndian(supplier, 4);\n        boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n        int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n        if (realLen == 0) {\n            verifyContentChecksum();\n            if (!decompressConcatenated) {\n                endReached = true;\n            } else {\n                init(false);\n            }\n            return;\n        }\n        InputStream capped = new BoundedInputStream(in, realLen);\n        if (expectBlockChecksum) {\n            capped = new ChecksumCalculatingInputStream(blockHash, capped) {\n                @Override\n                public long getValue() {\n                    return 0; // Fix for the NullPointerException issue\n                }\n            };\n        }\n        if (uncompressed) {\n            inUncompressed = true;\n            currentBlock = capped;\n        } else {\n            inUncompressed = false;\n            BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n            if (expectBlockDependency) {\n                s.prefill(blockDependencyBuffer);\n            }\n            currentBlock = s;\n        }\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -9.109596315911142,
      "mean_entropy": -0.0355843606090279
    },
    {
      "patch": "\n    private void nextBlock() throws IOException {\n        maybeFinishCurrentBlock();\n        long len = ByteUtils.fromLittleEndian(supplier, 4);\n        boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n        int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n        if (realLen == 0) {\n            verifyContentChecksum();\n            if (!decompressConcatenated) {\n                endReached = true;\n            } else {\n                init(false);\n            }\n            return;\n        }\n        InputStream capped = new BoundedInputStream(in, realLen);\n        if (expectBlockChecksum) {\n            capped = new ChecksumCalculatingInputStream(blockHash, capped) {\n                @Override\n                public long getValue() {\n                    return 0L; // Fixing the NullPointerException issue by providing a default value\n                }\n            };\n        }\n        if (uncompressed) {\n            inUncompressed = true;\n            currentBlock = capped;\n        } else {\n            inUncompressed = false;\n            BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n            if (expectBlockDependency) {\n                s.prefill(blockDependencyBuffer);\n            }\n            currentBlock = s;\n        }\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -12.265937559773233,
      "mean_entropy": -0.04681655557165356
    },
    {
      "patch": "\n    private void nextBlock() throws IOException {\n        maybeFinishCurrentBlock();\n        long len = ByteUtils.fromLittleEndian(supplier, 4);\n        boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n        int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n        if (realLen == 0) {\n            verifyContentChecksum();\n            if (!decompressConcatenated) {\n                endReached = true;\n            } else {\n                init(false);\n            }\n            return;\n        }\n        InputStream capped = new BoundedInputStream(in, realLen);\n        if (expectBlockChecksum) {\n            capped = new ChecksumCalculatingInputStream(blockHash, capped);\n        }\n        if (uncompressed) {\n            inUncompressed = true;\n            currentBlock = capped;\n        } else {\n            inUncompressed = false;\n            BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n            if (expectBlockDependency) {\n                s.prefill(blockDependencyBuffer);\n            }\n            currentBlock = s;\n        }\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -1.852270076888641,
      "mean_entropy": -0.008088515619601052
    },
    {
      "patch": "\nprivate void nextBlock() throws IOException {\n    maybeFinishCurrentBlock();\n    long len = ByteUtils.fromLittleEndian(supplier, 4);\n    boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n    int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n    if (realLen == 0) {\n        verifyContentChecksum();\n        if (!decompressConcatenated) {\n            endReached = true;\n        } else {\n            init(false);\n        }\n        return;\n    }\n    InputStream capped = new BoundedInputStream(in, realLen);\n    if (expectBlockChecksum) {\n        capped = new ChecksumCalculatingInputStream(blockHash, capped);\n    }\n    if (uncompressed) {\n        inUncompressed = true;\n        currentBlock = capped;\n    } else {\n        inUncompressed = false;\n        BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n        if (expectBlockDependency) {\n            s.prefill(blockDependencyBuffer);\n        }\n        currentBlock = s;\n    }\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -3.2312118959376788,
      "mean_entropy": -0.014234413638491978
    },
    {
      "patch": "\nprivate void nextBlock() throws IOException {\n    maybeFinishCurrentBlock();\n    long len = ByteUtils.fromLittleEndian(supplier, 4);\n    boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n    int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n    if (realLen == 0) {\n        verifyContentChecksum();\n        if (!decompressConcatenated) {\n            endReached = true;\n        } else {\n            init(false);\n        }\n        return;\n    }\n    InputStream capped = new BoundedInputStream(in, realLen);\n    if (expectBlockChecksum) {\n        capped = new ChecksumCalculatingInputStream(blockHash, capped) {\n            @Override\n            public long getValue() {\n                return 0L; // Dummy implementation to prevent NullPointerException\n            }\n        };\n    }\n    if (uncompressed) {\n        inUncompressed = true;\n        currentBlock = capped;\n    } else {\n        inUncompressed = false;\n        BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n        if (expectBlockDependency) {\n            s.prefill(blockDependencyBuffer);\n        }\n        currentBlock = s;\n    }\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -10.993913281682925,
      "mean_entropy": -0.04311338541836441
    },
    {
      "patch": "\n    private void nextBlock() throws IOException {\n        maybeFinishCurrentBlock();\n        long len = ByteUtils.fromLittleEndian(supplier, 4);\n        boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n        int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n        if (realLen == 0) {\n            verifyContentChecksum();\n            if (!decompressConcatenated) {\n                endReached = true;\n            } else {\n                init(false);\n            }\n            return;\n        }\n        InputStream capped = new BoundedInputStream(in, realLen);\n        if (expectBlockChecksum) {\n            capped = new ChecksumCalculatingInputStream(blockHash, capped);\n        }\n        if (uncompressed) {\n            inUncompressed = true;\n            currentBlock = capped;\n        } else {\n            inUncompressed = false;\n            BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n            if (expectBlockDependency) {\n                s.prefill(blockDependencyBuffer);\n            }\n            currentBlock = s;\n        }\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -1.82935738241679,
      "mean_entropy": -0.007988460185226157
    },
    {
      "patch": "\n    private void nextBlock() throws IOException {\n        maybeFinishCurrentBlock();\n        long len = ByteUtils.fromLittleEndian(supplier, 4);\n        boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n        int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n        if (realLen == 0) {\n            verifyContentChecksum();\n            if (!decompressConcatenated) {\n                endReached = true;\n            } else {\n                init(false);\n            }\n            return;\n        }\n        InputStream capped = new BoundedInputStream(in, realLen);\n        if (expectBlockChecksum) {\n            capped = new ChecksumCalculatingInputStream(blockHash, capped);\n        }\n        if (uncompressed) {\n            inUncompressed = true;\n            currentBlock = capped;\n        } else {\n            inUncompressed = false;\n            BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n            if (expectBlockDependency) {\n                s.prefill(blockDependencyBuffer);\n            }\n            currentBlock = s;\n        }\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -1.82935738241679,
      "mean_entropy": -0.007988460185226157
    },
    {
      "patch": "\n    private void nextBlock() throws IOException {\n        maybeFinishCurrentBlock();\n        long len = ByteUtils.fromLittleEndian(supplier, 4);\n        boolean uncompressed = (len & UNCOMPRESSED_FLAG_MASK) != 0;\n        int realLen = (int) (len & (~UNCOMPRESSED_FLAG_MASK));\n        if (realLen == 0) {\n            verifyContentChecksum();\n            if (!decompressConcatenated) {\n                endReached = true;\n            } else {\n                init(false);\n            }\n            return;\n        }\n        InputStream capped = new BoundedInputStream(in, realLen);\n        if (expectBlockChecksum) {\n            capped = new ChecksumCalculatingInputStream(blockHash, capped);\n        }\n        if (uncompressed) {\n            inUncompressed = true;\n            currentBlock = capped;\n        } else {\n            inUncompressed = false;\n            BlockLZ4CompressorInputStream s = new BlockLZ4CompressorInputStream(capped);\n            if (expectBlockDependency) {\n                s.prefill(blockDependencyBuffer);\n            }\n            currentBlock = s;\n        }\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -1.82935738241679,
      "mean_entropy": -0.007988460185226157
    },
    {
      "patch": "\n    final void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                        final int lastShadow) {\n        final int[] runningOrder = this.mainSort_runningOrder;\n        final int[] copy = this.mainSort_copy;\n        final boolean[] bigDone = this.mainSort_bigDone;\n        final int[] ftab = this.ftab;\n        final byte[] block = dataShadow.block;\n        final int[] fmap = dataShadow.fmap;\n        final char[] quadrant = this.quadrant;\n        final int workLimitShadow = this.workLimit;\n        final boolean firstAttemptShadow = this.firstAttempt;\n\n        // LBZ2: Set up the 2-byte frequency table\n        for (int i = 65537; --i >= 0;) {\n            ftab[i] = 0;\n        }\n\n        /*\n         * In the various block-sized structures, live data runs from 0 to\n         * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n         * for block.\n         */\n        for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n        }\n        for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n            quadrant[i] = 0;\n        }\n        block[0] = block[lastShadow + 1];\n\n        // LBZ2: Complete the initial radix sort:\n\n        int c1 = block[0] & 0xff;\n        for (int i = 0; i <= lastShadow; i++) {\n            final int c2 = block[i + 1] & 0xff;\n            ftab[(c1 << 8) + c2]++;\n            c1 = c2;\n        }\n\n        for (int i = 1; i <= 65536; i++) {\n            ftab[i] += ftab[i - 1];\n        }\n\n        c1 = block[1] & 0xff;\n        for (int i = 0; i < lastShadow; i++) {\n            final int c2 = block[i + 2] & 0xff;\n            fmap[--ftab[(c1 << 8) + c2]] = i;\n            c1 = c2;\n        }\n\n        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n        /*\n         * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n         * running order, from smallest to largest big bucket.\n         */\n        for (int i = 256; --i >= 0;) {\n            bigDone[i] = false;\n            runningOrder[i] = i;\n        }\n\n        // h = 364, 121, 40, 13, 4, 1\n        for (int h = 364; h != 1;) { //NOSONAR\n            h /= 3;\n            for (int i = h; i <= 255; i++) {\n                final int vv = runningOrder[i];\n                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n                final int b = h - 1;\n                int j = i;\n                for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                        - h]) {\n                    runningOrder[j] = ro;\n                    j -= h;\n                    if (j <= b) {\n                        break;\n                    }\n                }\n                runningOrder[j] = vv;\n            }\n        }\n\n        /*\n         * LBZ2: The main sorting loop.\n         */\n        for (int i = 0; i <= 255; i++) {\n            /*\n             * LBZ2: Process big buckets, starting with the least full.\n             */\n            final int ss = runningOrder[i];\n\n            // Step 1:\n            /*\n             * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n             * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n             * already completed many of the small buckets [ss, j], so we don't\n             * have to sort them at all.\n             */\n            for (int j = 0; j <= 255; j++) {\n                final int sb = (ss << 8) + j;\n                final int ftab_sb = ftab[sb];\n                if ((ftab_sb & SETMASK) != SETMASK) {\n                    final int lo = ftab_sb & CLEARMASK;\n                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                    if (hi > lo) {\n                        mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                        if (firstAttemptShadow\n                                && (this.workDone > workLimitShadow)) {\n                            return;\n                        }\n                    }\n                    ftab[sb] = ftab_sb | SETMASK;\n                }\n            }\n\n            // Step 2:\n            // LBZ2: Now scan this big bucket so as to synthesise the\n            // sorted order for small buckets [t, ss] for all t != ss.\n\n            for (int j = 0; j <= 255; j++) {\n                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n            }\n\n            for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n                final int fmap_j = fmap[j];\n                c1 = block[fmap_j] & 0xff;\n                if (!bigDone[c1]) {\n                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                    copy[c1]++;\n                }\n            }\n\n            for (int j = 256; --j >= 0;) {\n                ftab[(j << 8) + ss] |= SETMASK;\n            }\n\n            // Step 3:\n            /*\n             * LBZ2: The ss big bucket is now done. Record this fact, and update the\n             * quadrant descriptors. Remember to update quadrants in the\n             * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n             * skips this updating for the last bucket processed, since updating\n             * for the last bucket is pointless.\n             */\n            bigDone[ss] = true;\n\n            if (i < 255) {\n                final int bbStart = ftab[ss << 8] & CLEARMASK;\n                final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                int shifts = 0;\n\n                while ((bbSize >> shifts) > 65534) {\n                    shifts++;\n                }\n\n                for (int j = 0; j < bbSize; j++) {\n                    final int a2update = fmap[bbStart + j];\n                    final char qVal = (char) (j >> shifts);\n                    quadrant[a2update] = qVal;\n                    if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                        quadrant[a2update + lastShadow + 1] = qVal;\n                    }\n                }\n            }\n\n        }\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -3.8113487367238923,
      "mean_entropy": -0.0023239931321487146
    },
    {
      "patch": "\nfinal void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                    final int lastShadow) {\n    final int[] runningOrder = this.mainSort_runningOrder;\n    final int[] copy = this.mainSort_copy;\n    final boolean[] bigDone = this.mainSort_bigDone;\n    final int[] ftab = this.ftab;\n    final byte[] block = dataShadow.block;\n    final int[] fmap = dataShadow.fmap;\n    final char[] quadrant = this.quadrant;\n    final int workLimitShadow = this.workLimit;\n    final boolean firstAttemptShadow = this.firstAttempt;\n\n    // LBZ2: Set up the 2-byte frequency table\n    for (int i = 65537; --i >= 0;) {\n        ftab[i] = 0;\n    }\n\n    /*\n     * In the various block-sized structures, live data runs from 0 to\n     * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n     * for block.\n     */\n    for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n        block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n    }\n    for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n        quadrant[i] = 0;\n    }\n    block[0] = block[lastShadow + 1];\n\n    // LBZ2: Complete the initial radix sort:\n\n    int c1 = block[0] & 0xff;\n    for (int i = 0; i <= lastShadow; i++) {\n        final int c2 = block[i + 1] & 0xff;\n        ftab[(c1 << 8) + c2]++;\n        c1 = c2;\n    }\n\n    for (int i = 1; i <= 65536; i++) {\n        ftab[i] += ftab[i - 1];\n    }\n\n    c1 = block[1] & 0xff;\n    for (int i = 0; i < lastShadow; i++) {\n        final int c2 = block[i + 2] & 0xff;\n        fmap[--ftab[(c1 << 8) + c2]] = i;\n        c1 = c2;\n    }\n\n    fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n    /*\n     * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n     * running order, from smallest to largest big bucket.\n     */\n    for (int i = 256; --i >= 0;) {\n        bigDone[i] = false;\n        runningOrder[i] = i;\n    }\n\n    // h = 364, 121, 40, 13, 4, 1\n    for (int h = 364; h != 1;) { //NOSONAR\n        h /= 3;\n        for (int i = h; i <= 255; i++) {\n            final int vv = runningOrder[i];\n            final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n            final int b = h - 1;\n            int j = i;\n            for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                                                                                                            - h]) {\n                runningOrder[j] = ro;\n                j -= h;\n                if (j <= b) {\n                    break;\n                }\n            }\n            runningOrder[j] = vv;\n        }\n    }\n\n    /*\n     * LBZ2: The main sorting loop.\n     */\n    for (int i = 0; i <= 255; i++) {\n        /*\n         * LBZ2: Process big buckets, starting with the least full.\n         */\n        final int ss = runningOrder[i];\n\n        // Step 1:\n        /*\n         * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n         * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n         * already completed many of the small buckets [ss, j], so we don't\n         * have to sort them at all.\n         */\n        for (int j = 0; j <= 255; j++) {\n            final int sb = (ss << 8) + j;\n            final int ftab_sb = ftab[sb];\n            if ((ftab_sb & SETMASK) != SETMASK) {\n                final int lo = ftab_sb & CLEARMASK;\n                final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                if (hi > lo) {\n                    mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                    if (firstAttemptShadow\n                        && (this.workDone > workLimitShadow)) {\n                        return;\n                    }\n                }\n                ftab[sb] = ftab_sb | SETMASK;\n            }\n        }\n\n        // Step 2:\n        // LBZ2: Now scan this big bucket so as to synthesise the\n        // sorted order for small buckets [t, ss] for all t != ss.\n\n        for (int j = 0; j <= 255; j++) {\n            copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n        }\n\n        for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n            final int fmap_j = fmap[j];\n            c1 = block[fmap_j] & 0xff;\n            if (!bigDone[c1]) {\n                fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                copy[c1]++;\n            }\n        }\n\n        for (int j = 256; --j >= 0;) {\n            ftab[(j << 8) + ss] |= SETMASK;\n        }\n\n        // Step 3:\n        /*\n         * LBZ2: The ss big bucket is now done. Record this fact, and update the\n         * quadrant descriptors. Remember to update quadrants in the\n         * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n         * skips this updating for the last bucket processed, since updating\n         * for the last bucket is pointless.\n         */\n        bigDone[ss] = true;\n\n        if (i < 255) {\n            final int bbStart = ftab[ss << 8] & CLEARMASK;\n            final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n            int shifts = 0;\n\n            while ((bbSize >> shifts) > 65534) {\n                shifts++;\n            }\n\n            for (int j = 0; j < bbSize; j++) {\n                final int a2update = fmap[bbStart + j];\n                final char qVal = (char) (j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                    quadrant[a2update + lastShadow + 1] = qVal;\n                }\n            }\n        }\n\n    }\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -3.40499195470711,
      "mean_entropy": -0.0020774813634576632
    },
    {
      "patch": "\nfinal void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                    final int lastShadow) {\n    final int[] runningOrder = this.mainSort_runningOrder;\n    final int[] copy = this.mainSort_copy;\n    final boolean[] bigDone = this.mainSort_bigDone;\n    final int[] ftab = this.ftab;\n    final byte[] block = dataShadow.block;\n    final int[] fmap = dataShadow.fmap;\n    final char[] quadrant = this.quadrant;\n    final int workLimitShadow = this.workLimit;\n    final boolean firstAttemptShadow = this.firstAttempt;\n\n    // LBZ2: Set up the 2-byte frequency table\n    for (int i = 65537; --i >= 0;) {\n        ftab[i] = 0;\n    }\n\n    /*\n     * In the various block-sized structures, live data runs from 0 to\n     * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n     * for block.\n     */\n    for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n        block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n    }\n    for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES +1; --i >= 0;) {\n        quadrant[i] = 0;\n    }\n    block[0] = block[lastShadow + 1];\n\n    // LBZ2: Complete the initial radix sort:\n\n    int c1 = block[0] & 0xff;\n    for (int i = 0; i <= lastShadow; i++) {\n        final int c2 = block[i + 1] & 0xff;\n        ftab[(c1 << 8) + c2]++;\n        c1 = c2;\n    }\n\n    for (int i = 1; i <= 65536; i++) {\n        ftab[i] += ftab[i - 1];\n    }\n\n    c1 = block[1] & 0xff;\n    for (int i = 0; i < lastShadow; i++) {\n        final int c2 = block[i + 2] & 0xff;\n        fmap[--ftab[(c1 << 8) + c2]] = i;\n        c1 = c2;\n    }\n\n    fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n    /*\n     * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n     * running order, from smallest to largest big bucket.\n     */\n    for (int i = 256; --i >= 0;) {\n        bigDone[i] = false;\n        runningOrder[i] = i;\n    }\n\n    // h = 364, 121, 40, 13, 4, 1\n    for (int h = 364; h != 1;) { //NOSONAR\n        h /= 3;\n        for (int i = h; i <= 255; i++) {\n            final int vv = runningOrder[i];\n            final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n            final int b = h - 1;\n            int j = i;\n            for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                                                                                                            - h]) {\n                runningOrder[j] = ro;\n                j -= h;\n                if (j <= b) {\n                    break;\n                }\n            }\n            runningOrder[j] = vv;\n        }\n    }\n\n    /*\n     * LBZ2: The main sorting loop.\n     */\n    for (int i = 0; i <= 255; i++) {\n        /*\n         * LBZ2: Process big buckets, starting with the least full.\n         */\n        final int ss = runningOrder[i];\n\n        // Step 1:\n        /*\n         * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n         * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n         * already completed many of the small buckets [ss, j], so we don't\n         * have to sort them at all.\n         */\n        for (int j = 0; j <= 255; j++) {\n            final int sb = (ss << 8) + j;\n            final int ftab_sb = ftab[sb];\n            if ((ftab_sb & SETMASK) != SETMASK) {\n                final int lo = ftab_sb & CLEARMASK;\n                final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                if (hi > lo) {\n                    mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                    if (firstAttemptShadow\n                        && (this.workDone > workLimitShadow)) {\n                        return;\n                    }\n                }\n                ftab[sb] = ftab_sb | SETMASK;\n            }\n        }\n\n        // Step 2:\n        // LBZ2: Now scan this big bucket so as to synthesise the\n        // sorted order for small buckets [t, ss] for all t != ss.\n\n        for (int j = 0; j <= 255; j++) {\n            copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n        }\n\n        for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n            final int fmap_j = fmap[j];\n            c1 = block[fmap_j] & 0xff;\n            if (!bigDone[c1]) {\n                fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                copy[c1]++;\n            }\n        }\n\n        for (int j = 256; --j >= 0;) {\n            ftab[(j << 8) + ss] |= SETMASK;\n        }\n\n        // Step 3:\n        /*\n         * LBZ2: The ss big bucket is now done. Record this fact, and update the\n         * quadrant descriptors. Remember to update quadrants in the\n         * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n         * skips this updating for the last bucket processed, since updating\n         * for the last bucket is pointless.\n         */\n        bigDone[ss] = true;\n\n        if (i < 255) {\n            final int bbStart = ftab[ss << 8] & CLEARMASK;\n            final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n            int shifts = 0;\n\n            while ((bbSize >> shifts) > 65534) {\n                shifts++;\n            }\n\n            for (int j = 0; j < bbSize; j++) {\n                final int a2update = fmap[bbStart + j];\n                final char qVal = (char) (j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                    quadrant[a2update + lastShadow + 1] = qVal;\n                }\n            }\n        }\n\n    }\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -4.037672321512648,
      "mean_entropy": -0.002465001417284889
    },
    {
      "patch": "\nfinal void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                    final int lastShadow) {\n    final int[] runningOrder = this.mainSort_runningOrder;\n    final int[] copy = this.mainSort_copy;\n    final boolean[] bigDone = this.mainSort_bigDone;\n    final int[] ftab = this.ftab;\n    final byte[] block = dataShadow.block;\n    final int[] fmap = dataShadow.fmap;\n    final char[] quadrant = this.quadrant;\n    final int workLimitShadow = this.workLimit;\n    final boolean firstAttemptShadow = this.firstAttempt;\n\n    // LBZ2: Set up the 2-byte frequency table\n    for (int i = 65537; --i >= 0;) {\n        ftab[i] = 0;\n    }\n\n    /*\n     * In the various block-sized structures, live data runs from 0 to\n     * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n     * for block.\n     */\n    for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n        block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n    }\n    for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n        quadrant[i] = 0;\n    }\n    block[0] = block[lastShadow + 1];\n\n    // LBZ2: Complete the initial radix sort:\n\n    int c1 = block[0] & 0xff;\n    for (int i = 0; i <= lastShadow; i++) {\n        final int c2 = block[i + 1] & 0xff;\n        ftab[(c1 << 8) + c2]++;\n        c1 = c2;\n    }\n\n    for (int i = 1; i <= 65536; i++) {\n        ftab[i] += ftab[i - 1];\n    }\n\n    c1 = block[1] & 0xff;\n    for (int i = 0; i < lastShadow; i++) {\n        final int c2 = block[i + 2] & 0xff;\n        fmap[--ftab[(c1 << 8) + c2]] = i;\n        c1 = c2;\n    }\n\n    fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n    /*\n     * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n     * running order, from smallest to largest big bucket.\n     */\n    for (int i = 256; --i >= 0;) {\n        bigDone[i] = false;\n        runningOrder[i] = i;\n    }\n\n    // h = 364, 121, 40, 13, 4, 1\n    for (int h = 364; h != 1;) { //NOSONAR\n        h /= 3;\n        for (int i = h; i <= 255; i++) {\n            final int vv = runningOrder[i];\n            final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n            final int b = h - 1;\n            int j = i;\n            for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                                                                                                            - h]) {\n                runningOrder[j] = ro;\n                j -= h;\n                if (j <= b) {\n                    break;\n                }\n            }\n            runningOrder[j] = vv;\n        }\n    }\n\n    /*\n     * LBZ2: The main sorting loop.\n     */\n    for (int i = 0; i <= 255; i++) {\n        /*\n         * LBZ2: Process big buckets, starting with the least full.\n         */\n        final int ss = runningOrder[i];\n\n        // Step 1:\n        /*\n         * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n         * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n         * already completed many of the small buckets [ss, j], so we don't\n         * have to sort them at all.\n         */\n        for (int j = 0; j <= 255; j++) {\n            final int sb = (ss << 8) + j;\n            final int ftab_sb = ftab[sb];\n            if ((ftab_sb & SETMASK) != SETMASK) {\n                final int lo = ftab_sb & CLEARMASK;\n                final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                if (hi > lo) {\n                    mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                    if (firstAttemptShadow && (this.workDone > workLimitShadow)) {\n                        return;\n                    }\n                }\n                ftab[sb] = ftab_sb | SETMASK;\n            }\n        }\n\n        // Step 2:\n        // LBZ2: Now scan this big bucket so as to synthesise the\n        // sorted order for small buckets [t, ss] for all t != ss.\n\n        for (int j = 0; j <= 255; j++) {\n            copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n        }\n\n        for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n            final int fmap_j = fmap[j];\n            c1 = block[fmap_j] & 0xff;\n            if (!bigDone[c1]) {\n                fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                copy[c1]++;\n            }\n        }\n\n        for (int j = 256; --j >= 0;) {\n            ftab[(j << 8) + ss] |= SETMASK;\n        }\n\n        // Step 3:\n        /*\n         * LBZ2: The ss big bucket is now done. Record this fact, and update the\n         * quadrant descriptors. Remember to update quadrants in the\n         * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n         * skips this updating for the last bucket processed, since updating\n         * for the last bucket is pointless.\n         */\n        bigDone[ss] = true;\n\n        if (i < 255) {\n            final int bbStart = ftab[ss << 8] & CLEARMASK;\n            final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n            int shifts = 0;\n\n            while ((bbSize >> shifts) > 65534) {\n                shifts++;\n            }\n\n            for (int j = 0; j < bbSize; j++) {\n                final int a2update = fmap[bbStart + j];\n                final char qVal = (char) (j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                    quadrant[a2update + lastShadow + 1] = qVal;\n                }\n            }\n        }\n\n    }\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -4.653889703001254,
      "mean_entropy": -0.002842938120342855
    },
    {
      "patch": "\nfinal void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                    final int lastShadow) {\n    final int[] runningOrder = this.mainSort_runningOrder;\n    final int[] copy = this.mainSort_copy;\n    final boolean[] bigDone = this.mainSort_bigDone;\n    final int[] ftab = this.ftab;\n    final byte[] block = dataShadow.block;\n    final int[] fmap = dataShadow.fmap;\n    final char[] quadrant = this.quadrant;\n    final int workLimitShadow = this.workLimit;\n    final boolean firstAttemptShadow = this.firstAttempt;\n\n    // LBZ2: Set up the 2-byte frequency table\n    for (int i = 65537; --i >= 0;) {\n        ftab[i] = 0;\n    }\n\n    /*\n     * In the various block-sized structures, live data runs from 0 to\n     * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n     * for block.\n     */\n    for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n        block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n    }\n    for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n        quadrant[i] = 0;\n    }\n    block[0] = block[lastShadow + 1];\n\n    // LBZ2: Complete the initial radix sort:\n\n    int c1 = block[0] & 0xff;\n    for (int i = 0; i <= lastShadow; i++) {\n        final int c2 = block[i + 1] & 0xff;\n        ftab[(c1 << 8) + c2]++;\n        c1 = c2;\n    }\n\n    for (int i = 1; i <= 65536; i++) {\n        ftab[i] += ftab[i - 1];\n    }\n\n    c1 = block[1] & 0xff;\n    for (int i = 0; i < lastShadow; i++) {\n        final int c2 = block[i + 2] & 0xff;\n        fmap[--ftab[(c1 << 8) + c2]] = i;\n        c1 = c2;\n    }\n\n    fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n    /*\n     * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n     * running order, from smallest to largest big bucket.\n     */\n    for (int i = 256; --i >= 0;) {\n        bigDone[i] = false;\n        runningOrder[i] = i;\n    }\n\n    // h = 364, 121, 40, 13, 4, 1\n    for (int h = 364; h != 1;) { //NOSONAR\n        h /= 3;\n        for (int i = h; i <= 255; i++) {\n            final int vv = runningOrder[i];\n            final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n            final int b = h - 1;\n            int j = i;\n            for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                                                                                                            - h]) {\n                runningOrder[j] = ro;\n                j -= h;\n                if (j <= b) {\n                    break;\n                }\n            }\n            runningOrder[j] = vv;\n        }\n    }\n\n    /*\n     * LBZ2: The main sorting loop.\n     */\n    for (int i = 0; i <= 255; i++) {\n        /*\n         * LBZ2: Process big buckets, starting with the least full.\n         */\n        final int ss = runningOrder[i];\n\n        // Step 1:\n        /*\n         * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n         * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n         * already completed many of the small buckets [ss, j], so we don't\n         * have to sort them at all.\n         */\n        for (int j = 0; j <= 255; j++) {\n            final int sb = (ss << 8) + j;\n            final int ftab_sb = ftab[sb];\n            if ((ftab_sb & SETMASK) != SETMASK) {\n                final int lo = ftab_sb & CLEARMASK;\n                final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                if (hi > lo) {\n                    mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                    if (firstAttemptShadow && (this.workDone > workLimitShadow)) {\n                        return;\n                    }\n                }\n                ftab[sb] = ftab_sb | SETMASK;\n            }\n        }\n\n        // Step 2:\n        // LBZ2: Now scan this big bucket so as to synthesise the\n        // sorted order for small buckets [t, ss] for all t != ss.\n\n        for (int j = 0; j <= 255; j++) {\n            copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n        }\n\n        for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n            final int fmap_j = fmap[j];\n            c1 = block[fmap_j] & 0xff;\n            if (!bigDone[c1]) {\n                fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                copy[c1]++;\n            }\n        }\n\n        for (int j = 256; --j >= 0;) {\n            ftab[(j << 8) + ss] |= SETMASK;\n        }\n\n        // Step 3:\n        /*\n         * LBZ2: The ss big bucket is now done. Record this fact, and update the\n         * quadrant descriptors. Remember to update quadrants in the\n         * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n         * skips this updating for the last bucket processed, since updating\n         * for the last bucket is pointless.\n         */\n        bigDone[ss] = true;\n\n        if (i < 255) {\n            final int bbStart = ftab[ss << 8] & CLEARMASK;\n            final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n            int shifts = 0;\n\n            while ((bbSize >> shifts) > 65534) {\n                shifts++;\n            }\n\n            for (int j = 0; j < bbSize; j++) {\n                final int a2update = fmap[bbStart + j];\n                final char qVal = (char) (j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                    quadrant[a2update + lastShadow + 1] = qVal;\n                }\n            }\n        }\n\n    }\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -4.653889703001254,
      "mean_entropy": -0.002842938120342855
    },
    {
      "patch": "\nfinal void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                    final int lastShadow) {\n    final int[] runningOrder = this.mainSort_runningOrder;\n    final int[] copy = this.mainSort_copy;\n    final boolean[] bigDone = this.mainSort_bigDone;\n    final int[] ftab = this.ftab;\n    final byte[] block = dataShadow.block;\n    final int[] fmap = dataShadow.fmap;\n    final char[] quadrant = this.quadrant;\n    final int workLimitShadow = this.workLimit;\n    final boolean firstAttemptShadow = this.firstAttempt;\n\n    // LBZ2: Set up the 2-byte frequency table\n    for (int i = 65537; --i >= 0;) {\n        ftab[i] = 0;\n    }\n\n    /*\n     * In the various block-sized structures, live data runs from 0 to\n     * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n     * for block.\n     */\n    for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n        block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n    }\n    for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n        quadrant[i] = 0;\n    }\n    block[0] = block[lastShadow + 1];\n\n    // LBZ2: Complete the initial radix sort:\n\n    int c1 = block[0] & 0xff;\n    for (int i = 0; i <= lastShadow; i++) {\n        final int c2 = block[i + 1] & 0xff;\n        ftab[(c1 << 8) + c2]++;\n        c1 = c2;\n    }\n\n    for (int i = 1; i <= 65536; i++) {\n        ftab[i] += ftab[i - 1];\n    }\n\n    c1 = block[1] & 0xff;\n    for (int i = 0; i < lastShadow; i++) {\n        final int c2 = block[i + 2] & 0xff;\n        fmap[--ftab[(c1 << 8) + c2]] = i;\n        c1 = c2;\n    }\n\n    fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n    /*\n     * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n     * running order, from smallest to largest big bucket.\n     */\n    for (int i = 256; --i >= 0;) {\n        bigDone[i] = false;\n        runningOrder[i] = i;\n    }\n\n    // h = 364, 121, 40, 13, 4, 1\n    for (int h = 364; h != 1;) { //NOSONAR\n        h /= 3;\n        for (int i = h; i <= 255; i++) {\n            final int vv = runningOrder[i];\n            final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n            final int b = h - 1;\n            int j = i;\n            for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j - h]) {\n                runningOrder[j] = ro;\n                j -= h;\n                if (j <= b) {\n                    break;\n                }\n            }\n            runningOrder[j] = vv;\n        }\n    }\n\n    /*\n     * LBZ2: The main sorting loop.\n     */\n    for (int i = 0; i <= 255; i++) {\n        /*\n         * LBZ2: Process big buckets, starting with the least full.\n         */\n        final int ss = runningOrder[i];\n\n        // Step 1:\n        /*\n         * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n         * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n         * already completed many of the small buckets [ss, j], so we don't\n         * have to sort them at all.\n         */\n        for (int j = 0; j <= 255; j++) {\n            final int sb = (ss << 8) + j;\n            final int ftab_sb = ftab[sb];\n            if ((ftab_sb & SETMASK) != SETMASK) {\n                final int lo = ftab_sb & CLEARMASK;\n                final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                if (hi > lo) {\n                    mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                    if (firstAttemptShadow && (this.workDone > workLimitShadow)) {\n                        return;\n                    }\n                }\n                ftab[sb] = ftab_sb | SETMASK;\n            }\n        }\n\n        // Step 2:\n        // LBZ2: Now scan this big bucket so as to synthesise the\n        // sorted order for small buckets [t, ss] for all t != ss.\n\n        for (int j = 0; j <= 255; j++) {\n            copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n        }\n\n        for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n            final int fmap_j = fmap[j];\n            c1 = block[fmap_j] & 0xff;\n            if (!bigDone[c1]) {\n                fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                copy[c1]++;\n            }\n        }\n\n        for (int j = 256; --j >= 0;) {\n            ftab[(j << 8) + ss] |= SETMASK;\n        }\n\n        // Step 3:\n        /*\n         * LBZ2: The ss big bucket is now done. Record this fact, and update the\n         * quadrant descriptors. Remember to update quadrants in the\n         * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n         * skips this updating for the last bucket processed, since updating\n         * for the last bucket is pointless.\n         */\n        bigDone[ss] = true;\n\n        if (i < 255) {\n            final int bbStart = ftab[ss << 8] & CLEARMASK;\n            final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n            int shifts = 0;\n\n            while ((bbSize >> shifts) > 65534) {\n                shifts++;\n            }\n\n            for (int j = 0; j < bbSize; j++) {\n                final int a2update = fmap[bbStart + j];\n                final char qVal = (char) (j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                    quadrant[a2update + lastShadow + 1] = qVal;\n                }\n            }\n        }\n\n    }\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -3.5626176155882185,
      "mean_entropy": -0.0021803045383036834
    },
    {
      "patch": "\n    final void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                        final int lastShadow) {\n        final int[] runningOrder = this.mainSort_runningOrder;\n        final int[] copy = this.mainSort_copy;\n        final boolean[] bigDone = this.mainSort_bigDone;\n        final int[] ftab = this.ftab;\n        final byte[] block = dataShadow.block;\n        final int[] fmap = dataShadow.fmap;\n        final char[] quadrant = this.quadrant;\n        final int workLimitShadow = this.workLimit;\n        final boolean firstAttemptShadow = this.firstAttempt;\n\n        // LBZ2: Set up the 2-byte frequency table\n        for (int i = 65537; --i >= 0;) {\n            ftab[i] = 0;\n        }\n\n        /*\n         * In the various block-sized structures, live data runs from 0 to\n         * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n         * for block.\n         */\n        for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n        }\n        for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n            quadrant[i] = 0;\n        }\n        block[0] = block[lastShadow + 1];\n\n        // LBZ2: Complete the initial radix sort:\n\n        int c1 = block[0] & 0xff;\n        for (int i = 0; i <= lastShadow; i++) {\n            final int c2 = block[i + 1] & 0xff;\n            ftab[(c1 << 8) + c2]++;\n            c1 = c2;\n        }\n\n        for (int i = 1; i <= 65536; i++) {\n            ftab[i] += ftab[i - 1];\n        }\n\n        c1 = block[1] & 0xff;\n        for (int i = 0; i < lastShadow; i++) {\n            final int c2 = block[i + 2] & 0xff;\n            fmap[--ftab[(c1 << 8) + c2]] = i;\n            c1 = c2;\n        }\n\n        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n        /*\n         * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n         * running order, from smallest to largest big bucket.\n         */\n        for (int i = 256; --i >= 0;) {\n            bigDone[i] = false;\n            runningOrder[i] = i;\n        }\n\n        // h = 364, 121, 40, 13, 4, 1\n        for (int h = 364; h != 1;) { //NOSONAR\n            h /= 3;\n            for (int i = h; i <= 255; i++) {\n                final int vv = runningOrder[i];\n                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n                final int b = h - 1;\n                int j = i;\n                for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                                                                                                                - h]) {\n                    runningOrder[j] = ro;\n                    j -= h;\n                    if (j <= b) {\n                        break;\n                    }\n                }\n                runningOrder[j] = vv;\n            }\n        }\n\n        /*\n         * LBZ2: The main sorting loop.\n         */\n        for (int i = 0; i <= 255; i++) {\n            /*\n             * LBZ2: Process big buckets, starting with the least full.\n             */\n            final int ss = runningOrder[i];\n\n            // Step 1:\n            /*\n             * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n             * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n             * already completed many of the small buckets [ss, j], so we don't\n             * have to sort them at all.\n             */\n            for (int j = 0; j <= 255; j++) {\n                final int sb = (ss << 8) + j;\n                final int ftab_sb = ftab[sb];\n                if ((ftab_sb & SETMASK) != SETMASK) {\n                    final int lo = ftab_sb & CLEARMASK;\n                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                    if (hi > lo) {\n                        mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                        if (firstAttemptShadow\n                            && (this.workDone > workLimitShadow)) {\n                            return;\n                        }\n                    }\n                    ftab[sb] = ftab_sb | SETMASK;\n                }\n            }\n\n            // Step 2:\n            // LBZ2: Now scan this big bucket so as to synthesise the\n            // sorted order for small buckets [t, ss] for all t != ss.\n\n            for (int j = 0; j <= 255; j++) {\n                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n            }\n\n            for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n                final int fmap_j = fmap[j];\n                c1 = block[fmap_j] & 0xff;\n                if (!bigDone[c1]) {\n                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                    copy[c1]++;\n                }\n            }\n\n            for (int j = 256; --j >= 0;) {\n                ftab[(j << 8) + ss] |= SETMASK;\n            }\n\n            // Step 3:\n            /*\n             * LBZ2: The ss big bucket is now done. Record this fact, and update the\n             * quadrant descriptors. Remember to update quadrants in the\n             * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n             * skips this updating for the last bucket processed, since updating\n             * for the last bucket is pointless.\n             */\n            bigDone[ss] = true;\n\n            if (i < 255) {\n                final int bbStart = ftab[ss << 8] & CLEARMASK;\n                final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                int shifts = 0;\n\n                while ((bbSize >> shifts) > 65534) {\n                    shifts++;\n                }\n\n                for (int j = 0; j < bbSize; j++) {\n                    final int a2update = fmap[bbStart + j];\n                    final char qVal = (char) (j >> shifts);\n                    quadrant[a2update] = qVal;\n                    if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                        quadrant[a2update + lastShadow + 1] = qVal;\n                    }\n                }\n            }\n\n        }\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -3.8569149508251104,
      "mean_entropy": -0.0023503442722883064
    },
    {
      "patch": "\n    final void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                        final int lastShadow) {\n        final int[] runningOrder = this.mainSort_runningOrder;\n        final int[] copy = this.mainSort_copy;\n        final boolean[] bigDone = this.mainSort_bigDone;\n        final int[] ftab = this.ftab;\n        final byte[] block = dataShadow.block;\n        final int[] fmap = dataShadow.fmap;\n        final char[] quadrant = this.quadrant;\n        final int workLimitShadow = this.workLimit;\n        final boolean firstAttemptShadow = this.firstAttempt;\n\n        // LBZ2: Set up the 2-byte frequency table\n        for (int i = 65537; --i >= 0;) {\n            ftab[i] = 0;\n        }\n\n        /*\n         * In the various block-sized structures, live data runs from 0 to\n         * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n         * for block.\n         */\n        for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n        }\n        for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n            quadrant[i] = 0;\n        }\n        block[0] = block[lastShadow + 1];\n\n        // LBZ2: Complete the initial radix sort:\n\n        int c1 = block[0] & 0xff;\n        for (int i = 0; i <= lastShadow; i++) {\n            final int c2 = block[i + 1] & 0xff;\n            ftab[(c1 << 8) + c2]++;\n            c1 = c2;\n        }\n\n        for (int i = 1; i <= 65536; i++) {\n            ftab[i] += ftab[i - 1];\n        }\n\n        c1 = block[1] & 0xff;\n        for (int i = 0; i < lastShadow; i++) {\n            final int c2 = block[i + 2] & 0xff;\n            fmap[--ftab[(c1 << 8) + c2]] = i;\n            c1 = c2;\n        }\n\n        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n        /*\n         * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n         * running order, from smallest to largest big bucket.\n         */\n        for (int i = 256; --i >= 0;) {\n            bigDone[i] = false;\n            runningOrder[i] = i;\n        }\n\n        // h = 364, 121, 40, 13, 4, 1\n        for (int h = 364; h != 1;) { //NOSONAR\n            h /= 3;\n            for (int i = h; i <= 255; i++) {\n                final int vv = runningOrder[i];\n                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n                final int b = h - 1;\n                int j = i;\n                for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                        - h]) {\n                    runningOrder[j] = ro;\n                    j -= h;\n                    if (j <= b) {\n                        break;\n                    }\n                }\n                runningOrder[j] = vv;\n            }\n        }\n\n        /*\n         * LBZ2: The main sorting loop.\n         */\n        for (int i = 0; i <= 255; i++) {\n            /*\n             * LBZ2: Process big buckets, starting with the least full.\n             */\n            final int ss = runningOrder[i];\n\n            // Step 1:\n            /*\n             * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n             * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n             * already completed many of the small buckets [ss, j], so we don't\n             * have to sort them at all.\n             */\n            for (int j = 0; j <= 255; j++) {\n                final int sb = (ss << 8) + j;\n                final int ftab_sb = ftab[sb];\n                if ((ftab_sb & SETMASK) != SETMASK) {\n                    final int lo = ftab_sb & CLEARMASK;\n                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                    if (hi > lo) {\n                        mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                        if (firstAttemptShadow\n                                && (this.workDone > workLimitShadow)) {\n                            return;\n                        }\n                    }\n                    ftab[sb] = ftab_sb | SETMASK;\n                }\n            }\n\n            // Step 2:\n            // LBZ2: Now scan this big bucket so as to synthesise the\n            // sorted order for small buckets [t, ss] for all t != ss.\n\n            for (int j = 0; j <= 255; j++) {\n                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n            }\n\n            for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n                final int fmap_j = fmap[j];\n                c1 = block[fmap_j] & 0xff;\n                if (!bigDone[c1]) {\n                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                    copy[c1]++;\n                }\n            }\n\n            for (int j = 256; --j >= 0;) {\n                ftab[(j << 8) + ss] |= SETMASK;\n            }\n\n            // Step 3:\n            /*\n             * LBZ2: The ss big bucket is now done. Record this fact, and update the\n             * quadrant descriptors. Remember to update quadrants in the\n             * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n             * skips this updating for the last bucket processed, since updating\n             * for the last bucket is pointless.\n             */\n            bigDone[ss] = true;\n\n            if (i < 255) {\n                final int bbStart = ftab[ss << 8] & CLEARMASK;\n                final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                int shifts = 0;\n\n                while ((bbSize >> shifts) > 65534) {\n                    shifts++;\n                }\n\n                for (int j = 0; j < bbSize; j++) {\n                    final int a2update = fmap[bbStart + j];\n                    final char qVal = (char) (j >> shifts);\n                    quadrant[a2update] = qVal;\n                    if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                        quadrant[a2update + lastShadow + 1] = qVal;\n                    }\n                }\n            }\n\n        }\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -3.8113487367238923,
      "mean_entropy": -0.0023239931321487146
    },
    {
      "patch": "\nfinal void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                    final int lastShadow) {\n    final int[] runningOrder = this.mainSort_runningOrder;\n    final int[] copy = this.mainSort_copy;\n    final boolean[] bigDone = this.mainSort_bigDone;\n    final int[] ftab = this.ftab;\n    final byte[] block = dataShadow.block;\n    final int[] fmap = dataShadow.fmap;\n    final char[] quadrant = this.quadrant;\n    final int workLimitShadow = this.workLimit;\n    final boolean firstAttemptShadow = this.firstAttempt;\n\n    // LBZ2: Set up the 2-byte frequency table\n    for (int i = 65537; --i >= 0;) {\n        ftab[i] = 0;\n    }\n\n    /*\n     * In the various block-sized structures, live data runs from 0 to\n     * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n     * for block.\n     */\n    for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n        block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n    }\n    for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n        quadrant[i] = 0;\n    }\n    block[0] = block[lastShadow + 1];\n\n    // LBZ2: Complete the initial radix sort:\n\n    int c1 = block[0] & 0xff;\n    for (int i = 0; i <= lastShadow; i++) {\n        final int c2 = block[i + 1] & 0xff;\n        ftab[(c1 << 8) + c2]++;\n        c1 = c2;\n    }\n\n    for (int i = 1; i <= 65536; i++) {\n        ftab[i] += ftab[i - 1];\n    }\n\n    c1 = block[1] & 0xff;\n    for (int i = 0; i < lastShadow; i++) {\n        final int c2 = block[i + 2] & 0xff;\n        fmap[--ftab[(c1 << 8) + c2]] = i;\n        c1 = c2;\n    }\n\n    fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n    /*\n     * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n     * running order, from smallest to largest big bucket.\n     */\n    for (int i = 256; --i >= 0;) {\n        bigDone[i] = false;\n        runningOrder[i] = i;\n    }\n\n    // h = 364, 121, 40, 13, 4, 1\n    for (int h = 364; h != 1;) { //NOSONAR\n        h /= 3;\n        for (int i = h; i <= 255; i++) {\n            final int vv = runningOrder[i];\n            final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n            final int b = h - 1;\n            int j = i;\n            for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                                                                                                            - h]) {\n                runningOrder[j] = ro;\n                j -= h;\n                if (j <= b) {\n                    break;\n                }\n            }\n            runningOrder[j] = vv;\n        }\n    }\n\n    /*\n     * LBZ2: The main sorting loop.\n     */\n    for (int i = 0; i <= 255; i++) {\n        /*\n         * LBZ2: Process big buckets, starting with the least full.\n         */\n        final int ss = runningOrder[i];\n\n        // Step 1:\n        /*\n         * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n         * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n         * already completed many of the small buckets [ss, j], so we don't\n         * have to sort them at all.\n         */\n        for (int j = 0; j <= 255; j++) {\n            final int sb = (ss << 8) + j;\n            final int ftab_sb = ftab[sb];\n            if ((ftab_sb & SETMASK) != SETMASK) {\n                final int lo = ftab_sb & CLEARMASK;\n                final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                if (hi > lo) {\n                    mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                    if (firstAttemptShadow\n                        && (this.workDone > workLimitShadow)) {\n                        return;\n                    }\n                }\n                ftab[sb] = ftab_sb | SETMASK;\n            }\n        }\n\n        // Step 2:\n        // LBZ2: Now scan this big bucket so as to synthesise the\n        // sorted order for small buckets [t, ss] for all t != ss.\n\n        for (int j = 0; j <= 255; j++) {\n            copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n        }\n\n        for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n            final int fmap_j = fmap[j];\n            c1 = block[fmap_j] & 0xff;\n            if (!bigDone[c1]) {\n                fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                copy[c1]++;\n            }\n        }\n\n        for (int j = 256; --j >= 0;) {\n            ftab[(j << 8) + ss] |= SETMASK;\n        }\n\n        // Step 3:\n        /*\n         * LBZ2: The ss big bucket is now done. Record this fact, and update the\n         * quadrant descriptors. Remember to update quadrants in the\n         * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n         * skips this updating for the last bucket processed, since updating\n         * for the last bucket is pointless.\n         */\n        bigDone[ss] = true;\n\n        if (i < 255) {\n            final int bbStart = ftab[ss << 8] & CLEARMASK;\n            final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n            int shifts = 0;\n\n            while ((bbSize >> shifts) > 65534) {\n                shifts++;\n            }\n\n            for (int j = 0; j < bbSize; j++) {\n                final int a2update = fmap[bbStart + j];\n                final char qVal = (char) (j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                    quadrant[a2update + lastShadow + 1] = qVal;\n                }\n            }\n        }\n\n    }\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -3.40499195470711,
      "mean_entropy": -0.0020774813634576632
    },
    {
      "patch": "\n    final void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                        final int lastShadow) {\n        final int[] runningOrder = this.mainSort_runningOrder;\n        final int[] copy = this.mainSort_copy;\n        final boolean[] bigDone = this.mainSort_bigDone;\n        final int[] ftab = this.ftab;\n        final byte[] block = dataShadow.block;\n        final int[] fmap = dataShadow.fmap;\n        final char[] quadrant = this.quadrant;\n        final int workLimitShadow = this.workLimit;\n        final boolean firstAttemptShadow = this.firstAttempt;\n\n        // LBZ2: Set up the 2-byte frequency table\n        for (int i = 65537; --i >= 0;) {\n            ftab[i] = 0;\n        }\n\n        /*\n         * In the various block-sized structures, live data runs from 0 to\n         * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n         * for block.\n         */\n        for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n        }\n        for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n            quadrant[i] = 0;\n        }\n        block[0] = block[lastShadow + 1];\n\n        // LBZ2: Complete the initial radix sort:\n\n        int c1 = block[0] & 0xff;\n        for (int i = 0; i <= lastShadow; i++) {\n            final int c2 = block[i + 1] & 0xff;\n            ftab[(c1 << 8) + c2]++;\n            c1 = c2;\n        }\n\n        for (int i = 1; i <= 65536; i++) {\n            ftab[i] += ftab[i - 1];\n        }\n\n        c1 = block[1] & 0xff;\n        for (int i = 0; i < lastShadow; i++) {\n            final int c2 = block[i + 2] & 0xff;\n            fmap[--ftab[(c1 << 8) + c2]] = i;\n            c1 = c2;\n        }\n\n        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n        /*\n         * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n         * running order, from smallest to largest big bucket.\n         */\n        for (int i = 256; --i >= 0;) {\n            bigDone[i] = false;\n            runningOrder[i] = i;\n        }\n\n        // h = 364, 121, 40, 13, 4, 1\n        for (int h = 364; h != 1;) { //NOSONAR\n            h /= 3;\n            for (int i = h; i <= 255; i++) {\n                final int vv = runningOrder[i];\n                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n                final int b = h - 1;\n                int j = i;\n                for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                        - h]) {\n                    runningOrder[j] = ro;\n                    j -= h;\n                    if (j <= b) {\n                        break;\n                    }\n                }\n                runningOrder[j] = vv;\n            }\n        }\n\n        /*\n         * LBZ2: The main sorting loop.\n         */\n        for (int i = 0; i <= 255; i++) {\n            /*\n             * LBZ2: Process big buckets, starting with the least full.\n             */\n            final int ss = runningOrder[i];\n\n            // Step 1:\n            /*\n             * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n             * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n             * already completed many of the small buckets [ss, j], so we don't\n             * have to sort them at all.\n             */\n            for (int j = 0; j <= 255; j++) {\n                final int sb = (ss << 8) + j;\n                final int ftab_sb = ftab[sb];\n                if ((ftab_sb & SETMASK) != SETMASK) {\n                    final int lo = ftab_sb & CLEARMASK;\n                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                    if (hi > lo) {\n                        mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                        if (firstAttemptShadow && (this.workDone > workLimitShadow)) {\n                            return;\n                        }\n                    }\n                    ftab[sb] = ftab_sb | SETMASK;\n                }\n            }\n\n            // Step 2:\n            // LBZ2: Now scan this big bucket so as to synthesise the\n            // sorted order for small buckets [t, ss] for all t != ss.\n\n            for (int j = 0; j <= 255; j++) {\n                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n            }\n\n            for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n                final int fmap_j = fmap[j];\n                c1 = block[fmap_j] & 0xff;\n                if (!bigDone[c1]) {\n                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                    copy[c1]++;\n                }\n            }\n\n            for (int j = 256; --j >= 0;) {\n                ftab[(j << 8) + ss] |= SETMASK;\n            }\n\n            // Step 3:\n            /*\n             * LBZ2: The ss big bucket is now done. Record this fact, and update the\n             * quadrant descriptors. Remember to update quadrants in the\n             * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n             * skips this updating for the last bucket processed, since updating\n             * for the last bucket is pointless.\n             */\n            bigDone[ss] = true;\n\n            if (i < 255) {\n                final int bbStart = ftab[ss << 8] & CLEARMASK;\n                final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                int shifts = 0;\n\n                while ((bbSize >> shifts) > 65534) {\n                    shifts++;\n                }\n\n                for (int j = 0; j < bbSize; j++) {\n                    final int a2update = fmap[bbStart + j];\n                    final char qVal = (char) (j >> shifts);\n                    quadrant[a2update] = qVal;\n                    if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                        quadrant[a2update + lastShadow + 1] = qVal;\n                    }\n                }\n            }\n\n        }\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -5.028603120365469,
      "mean_entropy": -0.003069965274948394
    },
    {
      "patch": "\n    final void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                        final int lastShadow) {\n        final int[] runningOrder = this.mainSort_runningOrder;\n        final int[] copy = this.mainSort_copy;\n        final boolean[] bigDone = this.mainSort_bigDone;\n        final int[] ftab = this.ftab;\n        final byte[] block = dataShadow.block;\n        final int[] fmap = dataShadow.fmap;\n        final char[] quadrant = this.quadrant;\n        final int workLimitShadow = this.workLimit;\n        final boolean firstAttemptShadow = this.firstAttempt;\n\n        // LBZ2: Set up the 2-byte frequency table\n        for (int i = 65537; --i >= 0;) {\n            ftab[i] = 0;\n        }\n\n        /*\n         * In the various block-sized structures, live data runs from 0 to\n         * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n         * for block.\n         */\n        for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n        }\n        for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n            quadrant[i] = 0;\n        }\n        block[0] = block[lastShadow + 1];\n\n        // LBZ2: Complete the initial radix sort:\n\n        int c1 = block[0] & 0xff;\n        for (int i = 0; i <= lastShadow; i++) {\n            final int c2 = block[i + 1] & 0xff;\n            ftab[(c1 << 8) + c2]++;\n            c1 = c2;\n        }\n\n        for (int i = 1; i <= 65536; i++) {\n            ftab[i] += ftab[i - 1];\n        }\n\n        c1 = block[1] & 0xff;\n        for (int i = 0; i < lastShadow; i++) {\n            final int c2 = block[i + 2] & 0xff;\n            fmap[--ftab[(c1 << 8) + c2]] = i;\n            c1 = c2;\n        }\n\n        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n        /*\n         * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n         * running order, from smallest to largest big bucket.\n         */\n        for (int i = 256; --i >= 0;) {\n            bigDone[i] = false;\n            runningOrder[i] = i;\n        }\n\n        // h = 364, 121, 40, 13, 4, 1\n        for (int h = 364; h != 1;) { //NOSONAR\n            h /= 3;\n            for (int i = h; i <= 255; i++) {\n                final int vv = runningOrder[i];\n                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n                final int b = h - 1;\n                int j = i;\n                for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j - h]) {\n                    runningOrder[j] = ro;\n                    j -= h;\n                    if (j <= b) {\n                        break;\n                    }\n                }\n                runningOrder[j] = vv;\n            }\n        }\n\n        /*\n         * LBZ2: The main sorting loop.\n         */\n        for (int i = 0; i <= 255; i++) {\n            /*\n             * LBZ2: Process big buckets, starting with the least full.\n             */\n            final int ss = runningOrder[i];\n\n            // Step 1:\n            /*\n             * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n             * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n             * already completed many of the small buckets [ss, j], so we don't\n             * have to sort them at all.\n             */\n            for (int j = 0; j <= 255; j++) {\n                final int sb = (ss << 8) + j;\n                final int ftab_sb = ftab[sb];\n                if ((ftab_sb & SETMASK) != SETMASK) {\n                    final int lo = ftab_sb & CLEARMASK;\n                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                    if (hi > lo) {\n                        mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                        if (firstAttemptShadow && (this.workDone > workLimitShadow)) {\n                            return;\n                        }\n                    }\n                    ftab[sb] = ftab_sb | SETMASK;\n                }\n            }\n\n            // Step 2:\n            // LBZ2: Now scan this big bucket so as to synthesise the\n            // sorted order for small buckets [t, ss] for all t != ss.\n\n            for (int j = 0; j <= 255; j++) {\n                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n            }\n\n            for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n                final int fmap_j = fmap[j];\n                c1 = block[fmap_j] & 0xff;\n                if (!bigDone[c1]) {\n                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                    copy[c1]++;\n                }\n            }\n\n            for (int j = 256; --j >= 0;) {\n                ftab[(j << 8) + ss] |= SETMASK;\n            }\n\n            // Step 3:\n            /*\n             * LBZ2: The ss big bucket is now done. Record this fact, and update the\n             * quadrant descriptors. Remember to update quadrants in the\n             * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n             * skips this updating for the last bucket processed, since updating\n             * for the last bucket is pointless.\n             */\n            bigDone[ss] = true;\n\n            if (i < 255) {\n                final int bbStart = ftab[ss << 8] & CLEARMASK;\n                final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                int shifts = 0;\n\n                while ((bbSize >> shifts) > 65534) {\n                    shifts++;\n                }\n\n                for (int j = 0; j < bbSize; j++) {\n                    final int a2update = fmap[bbStart + j];\n                    final char qVal = (char) (j >> shifts);\n                    quadrant[a2update] = qVal;\n                    if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                        quadrant[a2update + lastShadow + 1] = qVal;\n                    }\n                }\n            }\n\n        }\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -4.31974716986401,
      "mean_entropy": -0.0026404322554180993
    },
    {
      "patch": "\n    final void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                        final int lastShadow) {\n        final int[] runningOrder = this.mainSort_runningOrder;\n        final int[] copy = this.mainSort_copy;\n        final boolean[] bigDone = this.mainSort_bigDone;\n        final int[] ftab = this.ftab;\n        final byte[] block = dataShadow.block;\n        final int[] fmap = dataShadow.fmap;\n        final char[] quadrant = this.quadrant;\n        final int workLimitShadow = this.workLimit;\n        final boolean firstAttemptShadow = this.firstAttempt;\n\n        // LBZ2: Set up the 2-byte frequency table\n        for (int i = 65537; --i >= 0;) {\n            ftab[i] = 0;\n        }\n\n        /*\n         * In the various block-sized structures, live data runs from 0 to\n         * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n         * for block.\n         */\n        for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n            block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n        }\n        for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n            quadrant[i] = 0;\n        }\n        block[0] = block[lastShadow + 1];\n\n        // LBZ2: Complete the initial radix sort:\n\n        int c1 = block[0] & 0xff;\n        for (int i = 0; i <= lastShadow; i++) {\n            final int c2 = block[i + 1] & 0xff;\n            ftab[(c1 << 8) + c2]++;\n            c1 = c2;\n        }\n\n        for (int i = 1; i <= 65536; i++) {\n            ftab[i] += ftab[i - 1];\n        }\n\n        c1 = block[1] & 0xff;\n        for (int i = 0; i < lastShadow; i++) {\n            final int c2 = block[i + 2] & 0xff;\n            fmap[--ftab[(c1 << 8) + c2]] = i;\n            c1 = c2;\n        }\n\n        fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n        /*\n         * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n         * running order, from smallest to largest big bucket.\n         */\n        for (int i = 256; --i >= 0;) {\n            bigDone[i] = false;\n            runningOrder[i] = i;\n        }\n\n        // h = 364, 121, 40, 13, 4, 1\n        for (int h = 364; h != 1;) { //NOSONAR\n            h /= 3;\n            for (int i = h; i <= 255; i++) {\n                final int vv = runningOrder[i];\n                final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n                final int b = h - 1;\n                int j = i;\n                for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                        - h]) {\n                    runningOrder[j] = ro;\n                    j -= h;\n                    if (j <= b) {\n                        break;\n                    }\n                }\n                runningOrder[j] = vv;\n            }\n        }\n\n        /*\n         * LBZ2: The main sorting loop.\n         */\n        for (int i = 0; i <= 255; i++) {\n            /*\n             * LBZ2: Process big buckets, starting with the least full.\n             */\n            final int ss = runningOrder[i];\n\n            // Step 1:\n            /*\n             * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n             * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n             * already completed many of the small buckets [ss, j], so we don't\n             * have to sort them at all.\n             */\n            for (int j = 0; j <= 255; j++) {\n                final int sb = (ss << 8) + j;\n                final int ftab_sb = ftab[sb];\n                if ((ftab_sb & SETMASK) != SETMASK) {\n                    final int lo = ftab_sb & CLEARMASK;\n                    final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                    if (hi > lo) {\n                        mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                        if (firstAttemptShadow\n                                && (this.workDone > workLimitShadow)) {\n                            return;\n                        }\n                    }\n                    ftab[sb] = ftab_sb | SETMASK;\n                }\n            }\n\n            // Step 2:\n            // LBZ2: Now scan this big bucket so as to synthesise the\n            // sorted order for small buckets [t, ss] for all t != ss.\n\n            for (int j = 0; j <= 255; j++) {\n                copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n            }\n\n            for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n                final int fmap_j = fmap[j];\n                c1 = block[fmap_j] & 0xff;\n                if (!bigDone[c1]) {\n                    fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                    copy[c1]++;\n                }\n            }\n\n            for (int j = 256; --j >= 0;) {\n                ftab[(j << 8) + ss] |= SETMASK;\n            }\n\n            // Step 3:\n            /*\n             * LBZ2: The ss big bucket is now done. Record this fact, and update the\n             * quadrant descriptors. Remember to update quadrants in the\n             * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n             * skips this updating for the last bucket processed, since updating\n             * for the last bucket is pointless.\n             */\n            bigDone[ss] = true;\n\n            if (i < 255) {\n                final int bbStart = ftab[ss << 8] & CLEARMASK;\n                final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n                int shifts = 0;\n\n                while ((bbSize >> shifts) > 65534) {\n                    shifts++;\n                }\n\n                for (int j = 0; j < bbSize; j++) {\n                    final int a2update = fmap[bbStart + j];\n                    final char qVal = (char) (j >> shifts);\n                    quadrant[a2update] = qVal;\n                    if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                        quadrant[a2update + lastShadow + 1] = qVal;\n                    }\n                }\n            }\n\n        }\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -3.8113487367238923,
      "mean_entropy": -0.0023239931321487146
    },
    {
      "patch": "\nfinal void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                    final int lastShadow) {\n    final int[] runningOrder = this.mainSort_runningOrder;\n    final int[] copy = this.mainSort_copy;\n    final boolean[] bigDone = this.mainSort_bigDone;\n    final int[] ftab = this.ftab;\n    final byte[] block = dataShadow.block;\n    final int[] fmap = dataShadow.fmap;\n    final char[] quadrant = this.quadrant;\n    final int workLimitShadow = this.workLimit;\n    final boolean firstAttemptShadow = this.firstAttempt;\n\n    // LBZ2: Set up the 2-byte frequency table\n    for (int i = 65537; --i >= 0;) {\n        ftab[i] = 0;\n    }\n\n    /*\n     * In the various block-sized structures, live data runs from 0 to\n     * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n     * for block.\n     */\n    for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n        block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n    }\n    for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n        quadrant[i] = 0;\n    }\n    block[0] = block[lastShadow + 1];\n\n    // LBZ2: Complete the initial radix sort:\n\n    int c1 = block[0] & 0xff;\n    for (int i = 0; i <= lastShadow; i++) {\n        final int c2 = block[i + 1] & 0xff;\n        ftab[(c1 << 8) + c2]++;\n        c1 = c2;\n    }\n\n    for (int i = 1; i <= 65536; i++) {\n        ftab[i] += ftab[i - 1];\n    }\n\n    c1 = block[1] & 0xff;\n    for (int i = 0; i < lastShadow; i++) {\n        final int c2 = block[i + 2] & 0xff;\n        fmap[--ftab[(c1 << 8) + c2]] = i;\n        c1 = c2;\n    }\n\n    fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n    /*\n     * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n     * running order, from smallest to largest big bucket.\n     */\n    for (int i = 256; --i >= 0;) {\n        bigDone[i] = false;\n        runningOrder[i] = i;\n    }\n\n    // h = 364, 121, 40, 13, 4, 1\n    for (int h = 364; h != 1;) { //NOSONAR\n        h /= 3;\n        for (int i = h; i <= 255; i++) {\n            final int vv = runningOrder[i];\n            final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n            final int b = h - 1;\n            int j = i;\n            for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                                                                                                            - h]) {\n                runningOrder[j] = ro;\n                j -= h;\n                if (j <= b) {\n                    break;\n                }\n            }\n            runningOrder[j] = vv;\n        }\n    }\n\n    /*\n     * LBZ2: The main sorting loop.\n     */\n    for (int i = 0; i <= 255; i++) {\n        /*\n         * LBZ2: Process big buckets, starting with the least full.\n         */\n        final int ss = runningOrder[i];\n\n        // Step 1:\n        /*\n         * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n         * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n         * already completed many of the small buckets [ss, j], so we don't\n         * have to sort them at all.\n         */\n        for (int j = 0; j <= 255; j++) {\n            final int sb = (ss << 8) + j;\n            final int ftab_sb = ftab[sb];\n            if ((ftab_sb & SETMASK) != SETMASK) {\n                final int lo = ftab_sb & CLEARMASK;\n                final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                if (hi > lo) {\n                    mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                    if (firstAttemptShadow\n                        && (this.workDone > workLimitShadow)) {\n                        return;\n                    }\n                }\n                ftab[sb] = ftab_sb | SETMASK;\n            }\n        }\n\n        // Step 2:\n        // LBZ2: Now scan this big bucket so as to synthesise the\n        // sorted order for small buckets [t, ss] for all t != ss.\n\n        for (int j = 0; j <= 255; j++) {\n            copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n        }\n\n        for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n            final int fmap_j = fmap[j];\n            c1 = block[fmap_j] & 0xff;\n            if (!bigDone[c1]) {\n                fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                copy[c1]++;\n            }\n        }\n\n        for (int j = 256; --j >= 0;) {\n            ftab[(j << 8) + ss] |= SETMASK;\n        }\n\n        // Step 3:\n        /*\n         * LBZ2: The ss big bucket is now done. Record this fact, and update the\n         * quadrant descriptors. Remember to update quadrants in the\n         * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n         * skips this updating for the last bucket processed, since updating\n         * for the last bucket is pointless.\n         */\n        bigDone[ss] = true;\n\n        if (i < 255) {\n            final int bbStart = ftab[ss << 8] & CLEARMASK;\n            final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n            int shifts = 0;\n\n            while ((bbSize >> shifts) > 65534) {\n                shifts++;\n            }\n\n            for (int j = 0; j < bbSize; j++) {\n                final int a2update = fmap[bbStart + j];\n                final char qVal = (char) (j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                    quadrant[a2update + lastShadow + 1] = qVal;\n                }\n            }\n        }\n\n    }\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -3.405130625623732,
      "mean_entropy": -0.0020775659704842784
    },
    {
      "patch": "\nfinal void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                    final int lastShadow) {\n    final int[] runningOrder = this.mainSort_runningOrder;\n    final int[] copy = this.mainSort_copy;\n    final boolean[] bigDone = this.mainSort_bigDone;\n    final int[] ftab = this.ftab;\n    final byte[] block = dataShadow.block;\n    final int[] fmap = dataShadow.fmap;\n    final char[] quadrant = this.quadrant;\n    final int workLimitShadow = this.workLimit;\n    final boolean firstAttemptShadow = this.firstAttempt;\n\n    // LBZ2: Set up the 2-byte frequency table\n    for (int i = 65537; --i >= 0;) {\n        ftab[i] = 0;\n    }\n\n    /*\n     * In the various block-sized structures, live data runs from 0 to\n     * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n     * for block.\n     */\n    for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n        block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n    }\n    for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n        quadrant[i] = 0;\n    }\n    block[0] = block[lastShadow + 1];\n\n    // LBZ2: Complete the initial radix sort:\n\n    int c1 = block[0] & 0xff;\n    for (int i = 0; i <= lastShadow; i++) {\n        final int c2 = block[i + 1] & 0xff;\n        ftab[(c1 << 8) + c2]++;\n        c1 = c2;\n    }\n\n    for (int i = 1; i <= 65536; i++) {\n        ftab[i] += ftab[i - 1];\n    }\n\n    c1 = block[1] & 0xff;\n    for (int i = 0; i < lastShadow; i++) {\n        final int c2 = block[i + 2] & 0xff;\n        fmap[--ftab[(c1 << 8) + c2]] = i;\n        c1 = c2;\n    }\n\n    fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n    /*\n     * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n     * running order, from smallest to largest big bucket.\n     */\n    for (int i = 256; --i >= 0;) {\n        bigDone[i] = false;\n        runningOrder[i] = i;\n    }\n\n    // h = 364, 121, 40, 13, 4, 1\n    for (int h = 364; h != 1;) { //NOSONAR\n        h /= 3;\n        for (int i = h; i <= 255; i++) {\n            final int vv = runningOrder[i];\n            final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n            final int b = h - 1;\n            int j = i;\n            for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                                                                                                            - h]) {\n                runningOrder[j] = ro;\n                j -= h;\n                if (j <= b) {\n                    break;\n                }\n            }\n            runningOrder[j] = vv;\n        }\n    }\n\n    /*\n     * LBZ2: The main sorting loop.\n     */\n    for (int i = 0; i <= 255; i++) {\n        /*\n         * LBZ2: Process big buckets, starting with the least full.\n         */\n        final int ss = runningOrder[i];\n\n        // Step 1:\n        /*\n         * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n         * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n         * already completed many of the small buckets [ss, j], so we don't\n         * have to sort them at all.\n         */\n        for (int j = 0; j <= 255; j++) {\n            final int sb = (ss << 8) + j;\n            final int ftab_sb = ftab[sb];\n            if ((ftab_sb & SETMASK) != SETMASK) {\n                final int lo = ftab_sb & CLEARMASK;\n                final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                if (hi > lo) {\n                    mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                    if (firstAttemptShadow && (this.workDone > workLimitShadow)) {\n                        return;\n                    }\n                }\n                ftab[sb] = ftab_sb | SETMASK;\n            }\n        }\n\n        // Step 2:\n        // LBZ2: Now scan this big bucket so as to synthesise the\n        // sorted order for small buckets [t, ss] for all t != ss.\n\n        for (int j = 0; j <= 255; j++) {\n            copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n        }\n\n        for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n            final int fmap_j = fmap[j];\n            c1 = block[fmap_j] & 0xff;\n            if (!bigDone[c1]) {\n                fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                copy[c1]++;\n            }\n        }\n\n        for (int j = 256; --j >= 0;) {\n            ftab[(j << 8) + ss] |= SETMASK;\n        }\n\n        // Step 3:\n        /*\n         * LBZ2: The ss big bucket is now done. Record this fact, and update the\n         * quadrant descriptors. Remember to update quadrants in the\n         * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n         * skips this updating for the last bucket processed, since updating\n         * for the last bucket is pointless.\n         */\n        bigDone[ss] = true;\n\n        if (i < 255) {\n            final int bbStart = ftab[ss << 8] & CLEARMASK;\n            final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n            int shifts = 0;\n\n            while ((bbSize >> shifts) > 65534) {\n                shifts++;\n            }\n\n            for (int j = 0; j < bbSize; j++) {\n                final int a2update = fmap[bbStart + j];\n                final char qVal = (char) (j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                    quadrant[a2update + lastShadow + 1] = qVal;\n                }\n            }\n        }\n\n    }\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -4.565900329607697,
      "mean_entropy": -0.00278918773952822
    },
    {
      "patch": "\nfinal void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                    final int lastShadow) {\n    final int[] runningOrder = this.mainSort_runningOrder;\n    final int[] copy = this.mainSort_copy;\n    final boolean[] bigDone = this.mainSort_bigDone;\n    final int[] ftab = this.ftab;\n    final byte[] block = dataShadow.block;\n    final int[] fmap = dataShadow.fmap;\n    final char[] quadrant = this.quadrant;\n    final int workLimitShadow = this.workLimit;\n    final boolean firstAttemptShadow = this.firstAttempt;\n\n    // LBZ2: Set up the 2-byte frequency table\n    for (int i = 65537; --i >= 0;) {\n        ftab[i] = 0;\n    }\n\n    /*\n     * In the various block-sized structures, live data runs from 0 to\n     * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n     * for block.\n     */\n    for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n        block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n    }\n    for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES + 1; --i >= 0;) {\n        quadrant[i] = 0;\n    }\n    block[0] = block[lastShadow + 1];\n\n    // LBZ2: Complete the initial radix sort:\n\n    int c1 = block[0] & 0xff;\n    for (int i = 0; i <= lastShadow; i++) {\n        final int c2 = block[i + 1] & 0xff;\n        ftab[(c1 << 8) + c2]++;\n        c1 = c2;\n    }\n\n    for (int i = 1; i <= 65536; i++) {\n        ftab[i] += ftab[i - 1];\n    }\n\n    c1 = block[1] & 0xff;\n    for (int i = 0; i < lastShadow; i++) {\n        final int c2 = block[i + 2] & 0xff;\n        fmap[--ftab[(c1 << 8) + c2]] = i;\n        c1 = c2;\n    }\n\n    fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n    /*\n     * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n     * running order, from smallest to largest big bucket.\n     */\n    for (int i = 256; --i >= 0;) {\n        bigDone[i] = false;\n        runningOrder[i] = i;\n    }\n\n    // h = 364, 121, 40, 13, 4, 1\n    for (int h = 364; h != 1;) { //NOSONAR\n        h /= 3;\n        for (int i = h; i <= 255; i++) {\n            final int vv = runningOrder[i];\n            final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n            final int b = h - 1;\n            int j = i;\n            for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                                                                                                            - h]) {\n                runningOrder[j] = ro;\n                j -= h;\n                if (j <= b) {\n                    break;\n                }\n            }\n            runningOrder[j] = vv;\n        }\n    }\n\n    /*\n     * LBZ2: The main sorting loop.\n     */\n    for (int i = 0; i <= 255; i++) {\n        /*\n         * LBZ2: Process big buckets, starting with the least full.\n         */\n        final int ss = runningOrder[i];\n\n        // Step 1:\n        /*\n         * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n         * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n         * already completed many of the small buckets [ss, j], so we don't\n         * have to sort them at all.\n         */\n        for (int j = 0; j <= 255; j++) {\n            final int sb = (ss << 8) + j;\n            final int ftab_sb = ftab[sb];\n            if ((ftab_sb & SETMASK) != SETMASK) {\n                final int lo = ftab_sb & CLEARMASK;\n                final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                if (hi > lo) {\n                    mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                    if (firstAttemptShadow\n                        && (this.workDone > workLimitShadow)) {\n                        return;\n                    }\n                }\n                ftab[sb] = ftab_sb | SETMASK;\n            }\n        }\n\n        // Step 2:\n        // LBZ2: Now scan this big bucket so as to synthesise the\n        // sorted order for small buckets [t, ss] for all t != ss.\n\n        for (int j = 0; j <= 255; j++) {\n            copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n        }\n\n        for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n            final int fmap_j = fmap[j];\n            c1 = block[fmap_j] & 0xff;\n            if (!bigDone[c1]) {\n                fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                copy[c1]++;\n            }\n        }\n\n        for (int j = 256; --j >= 0;) {\n            ftab[(j << 8) + ss] |= SETMASK;\n        }\n\n        // Step 3:\n        /*\n         * LBZ2: The ss big bucket is now done. Record this fact, and update the\n         * quadrant descriptors. Remember to update quadrants in the\n         * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n         * skips this updating for the last bucket processed, since updating\n         * for the last bucket is pointless.\n         */\n        bigDone[ss] = true;\n\n        if (i < 255) {\n            final int bbStart = ftab[ss << 8] & CLEARMASK;\n            final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n            int shifts = 0;\n\n            while ((bbSize >> shifts) > 65534) {\n                shifts++;\n            }\n\n            for (int j = 0; j < bbSize; j++) {\n                final int a2update = fmap[bbStart + j];\n                final char qVal = (char) (j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                    quadrant[a2update + lastShadow + 1] = qVal;\n                }\n            }\n        }\n\n    }\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -3.405130625623732,
      "mean_entropy": -0.0020775659704842784
    },
    {
      "patch": "\nfinal void mainSort(final BZip2CompressorOutputStream.Data dataShadow,\n                    final int lastShadow) {\n    final int[] runningOrder = this.mainSort_runningOrder;\n    final int[] copy = this.mainSort_copy;\n    final boolean[] bigDone = this.mainSort_bigDone;\n    final int[] ftab = this.ftab;\n    final byte[] block = dataShadow.block;\n    final int[] fmap = dataShadow.fmap;\n    final char[] quadrant = this.quadrant;\n    final int workLimitShadow = this.workLimit;\n    final boolean firstAttemptShadow = this.firstAttempt;\n\n    // LBZ2: Set up the 2-byte frequency table\n    for (int i = 65537; --i >= 0;) {\n        ftab[i] = 0;\n    }\n\n    /*\n     * In the various block-sized structures, live data runs from 0 to\n     * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area\n     * for block.\n     */\n    for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {\n        block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];\n    }\n    for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES; --i >= 0;) {\n        quadrant[i] = 0;\n    }\n    block[0] = block[lastShadow + 1];\n\n    // LBZ2: Complete the initial radix sort:\n\n    int c1 = block[0] & 0xff;\n    for (int i = 0; i <= lastShadow; i++) {\n        final int c2 = block[i + 1] & 0xff;\n        ftab[(c1 << 8) + c2]++;\n        c1 = c2;\n    }\n\n    for (int i = 1; i <= 65536; i++) {\n        ftab[i] += ftab[i - 1];\n    }\n\n    c1 = block[1] & 0xff;\n    for (int i = 0; i < lastShadow; i++) {\n        final int c2 = block[i + 2] & 0xff;\n        fmap[--ftab[(c1 << 8) + c2]] = i;\n        c1 = c2;\n    }\n\n    fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;\n\n    /*\n     * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the\n     * running order, from smallest to largest big bucket.\n     */\n    for (int i = 256; --i >= 0;) {\n        bigDone[i] = false;\n        runningOrder[i] = i;\n    }\n\n    // h = 364, 121, 40, 13, 4, 1\n    for (int h = 364; h != 1;) { //NOSONAR\n        h /= 3;\n        for (int i = h; i <= 255; i++) {\n            final int vv = runningOrder[i];\n            final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];\n            final int b = h - 1;\n            int j = i;\n            for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j\n                                                                                                            - h]) {\n                runningOrder[j] = ro;\n                j -= h;\n                if (j <= b) {\n                    break;\n                }\n            }\n            runningOrder[j] = vv;\n        }\n    }\n\n    /*\n     * LBZ2: The main sorting loop.\n     */\n    for (int i = 0; i <= 255; i++) {\n        /*\n         * LBZ2: Process big buckets, starting with the least full.\n         */\n        final int ss = runningOrder[i];\n\n        // Step 1:\n        /*\n         * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small\n         * buckets [ss, j]. Hopefully previous pointer-scanning phases have\n         * already completed many of the small buckets [ss, j], so we don't\n         * have to sort them at all.\n         */\n        for (int j = 0; j <= 255; j++) {\n            final int sb = (ss << 8) + j;\n            final int ftab_sb = ftab[sb];\n            if ((ftab_sb & SETMASK) != SETMASK) {\n                final int lo = ftab_sb & CLEARMASK;\n                final int hi = (ftab[sb + 1] & CLEARMASK) - 1;\n                if (hi > lo) {\n                    mainQSort3(dataShadow, lo, hi, 2, lastShadow);\n                    if (firstAttemptShadow\n                        && (this.workDone > workLimitShadow)) {\n                        return;\n                    }\n                }\n                ftab[sb] = ftab_sb | SETMASK;\n            }\n        }\n\n        // Step 2:\n        // LBZ2: Now scan this big bucket so as to synthesise the\n        // sorted order for small buckets [t, ss] for all t != ss.\n\n        for (int j = 0; j <= 255; j++) {\n            copy[j] = ftab[(j << 8) + ss] & CLEARMASK;\n        }\n\n        for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {\n            final int fmap_j = fmap[j];\n            c1 = block[fmap_j] & 0xff;\n            if (!bigDone[c1]) {\n                fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);\n                copy[c1]++;\n            }\n        }\n\n        for (int j = 256; --j >= 0;) {\n            ftab[(j << 8) + ss] |= SETMASK;\n        }\n\n        // Step 3:\n        /*\n         * LBZ2: The ss big bucket is now done. Record this fact, and update the\n         * quadrant descriptors. Remember to update quadrants in the\n         * overshoot area too, if necessary. The \"if (i < 255)\" test merely\n         * skips this updating for the last bucket processed, since updating\n         * for the last bucket is pointless.\n         */\n        bigDone[ss] = true;\n\n        if (i < 255) {\n            final int bbStart = ftab[ss << 8] & CLEARMASK;\n            final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;\n            int shifts = 0;\n\n            while ((bbSize >> shifts) > 65534) {\n                shifts++;\n            }\n\n            for (int j = 0; j < bbSize; j++) {\n                final int a2update = fmap[bbStart + j];\n                final char qVal = (char) (j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {\n                    quadrant[a2update + lastShadow + 1] = qVal;\n                }\n            }\n        }\n\n    }\n}\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 3,
      "passing_trigger": 0,
      "total_relevant": 5,
      "failing_relevant": 3,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
        [
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionTwo",
          "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionThree"
        ]
      ],
      "sum_entropy": -5.24712257604391,
      "mean_entropy": -0.0032072876381686495
    }
  ],
  "Compress_7": [
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, out.position());\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -6.15756725461168,
      "mean_entropy": -0.020389295545071788
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, out.position());\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -4.647360435398002,
      "mean_entropy": -0.01533782321913532
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 6);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -4.007080598260588,
      "mean_entropy": -0.013312560127111588
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() * 6); // Increased initial buffer size\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.position() + 1); // Increased buffer growth size\n\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -20.968382139679836,
      "mean_entropy": -0.0680791627911683
    },
    {
      "patch": "\n    /**\n     * @see org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length() + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n                // write the unmappable characters in utf-16 pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n                out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2);\n            } else if (res.isUnderflow()) {\n                enc.flush(out);\n                break;\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -6.71572150067212,
      "mean_entropy": -0.022460607025659263
    },
    {
      "patch": "\n/**\n * @see\n * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n */\npublic ByteBuffer encode(String name) {\n    CharsetEncoder enc = this.charset.newEncoder();\n\n    enc.onMalformedInput(CodingErrorAction.REPORT);\n    enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n    CharBuffer cb = CharBuffer.wrap(name);\n    ByteBuffer out = ByteBuffer.allocate(name.length()\n                                         + (name.length() + 1) / 2);\n\n    while (cb.remaining() > 0) {\n        CoderResult res = enc.encode(cb, out, true);\n\n        if (res.isUnmappable() || res.isMalformed()) {\n\n            // write the unmappable characters in utf-16\n            // pseudo-URL encoding style to ByteBuffer.\n            if (res.length() * 6 > out.remaining()) {\n                out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                   + res.length() * 6);\n            }\n\n            for (int i = 0; i < res.length(); ++i) {\n                ZipEncodingHelper.appendSurrogate(out, cb.get());\n            }\n\n        } else if (res.isOverflow()) {\n\n            out = ZipEncodingHelper.growBuffer(out, out.capacity() * 2);\n\n        } else if (res.isUnderflow()) {\n\n            enc.flush(out);\n            break;\n\n        }\n    }\n\n    out.limit(out.position());\n    out.rewind();\n    return out;\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -7.4282825571543825,
      "mean_entropy": -0.024678679591875023
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 6);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, out.position());\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -6.243848481441786,
      "mean_entropy": -0.020743682662597296
    },
    {
      "patch": "\n    /**\n     * @see\n     * org.apache.commons.compress.archivers.zip.ZipEncoding#encode(java.lang.String)\n     */\n    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out, true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 6);\n                }\n\n                for (int i = 0; i < res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, out.position());\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -4.4975441275449,
      "mean_entropy": -0.01484337995889406
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() >0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.3163807694105203,
      "mean_entropy": -0.0029917744759330005
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")) {\n            name = name + \"/\";\n        }\n        if (prefix.length() > 0) {\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.9170232108731204,
      "mean_entropy": -0.0043273661644991435
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() >0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.3163807694105203,
      "mean_entropy": -0.0029917744759330005
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() >0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.3163807694105203,
      "mean_entropy": -0.0029917744759330005
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        \n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() > 0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -4.74445595719112,
      "mean_entropy": -0.01073406325156362
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")) {\n            name = name + \"/\";\n        }\n        if (prefix.length() > 0) {\n            name = prefix + \"/\" + name;\n        }\n    }\n\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -2.4402838438731203,
      "mean_entropy": -0.005483783918816001
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() >0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.3163807694105203,
      "mean_entropy": -0.0029917744759330005
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() >0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.3163807694105203,
      "mean_entropy": -0.0029917744759330005
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")) {\n            name = name + \"/\";\n        }\n        if (prefix.length() > 0) {\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.9170232108731204,
      "mean_entropy": -0.0043273661644991435
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() > 0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.91980680582822,
      "mean_entropy": -0.004353303414576463
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() >0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.3163807694105203,
      "mean_entropy": -0.0029917744759330005
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() >0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.3163807694105203,
      "mean_entropy": -0.0029917744759330005
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() > 0){\n            name = prefix + \"/\" + name;\n        }\n    }\n\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -3.3882769580282197,
      "mean_entropy": -0.007648480717896659
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() >0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.3163807694105203,
      "mean_entropy": -0.0029917744759330005
    },
    {
      "patch": "\n/**\n * Parse an entry's header information from a header buffer.\n *\n * @param header The tar entry header buffer to get information from.\n */\npublic void parseTarHeader(byte[] header) {\n    int offset = 0;\n\n    name = TarUtils.parseName(header, offset, NAMELEN);\n    offset += NAMELEN;\n    mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n    offset += MODELEN;\n    userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n    offset += UIDLEN;\n    groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n    offset += GIDLEN;\n    size = TarUtils.parseOctal(header, offset, SIZELEN);\n    offset += SIZELEN;\n    modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n    offset += MODTIMELEN;\n    offset += CHKSUMLEN;\n    linkFlag = header[offset++];\n    linkName = TarUtils.parseName(header, offset, NAMELEN);\n    offset += NAMELEN;\n    magic = TarUtils.parseName(header, offset, MAGICLEN);\n    offset += MAGICLEN;\n    version = TarUtils.parseName(header, offset, VERSIONLEN);\n    offset += VERSIONLEN;\n    userName = TarUtils.parseName(header, offset, UNAMELEN);\n    offset += UNAMELEN;\n    groupName = TarUtils.parseName(header, offset, GNAMELEN);\n    offset += GNAMELEN;\n    devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n    offset += DEVLEN;\n    devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n    offset += DEVLEN;\n    String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n    // SunOS tar -E does not add / to directory names, so fix up to be consistent\n    if (isDirectory() && !name.endsWith(\"/\")) {\n        name = name + \"/\";\n    }\n    if (prefix.length() > 0) {\n        name = prefix + \"/\" + name;\n    }\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -3.8757890863051867,
      "mean_entropy": -0.008889424509874282
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() > 0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.91980680582822,
      "mean_entropy": -0.004353303414576463
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() > 0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.98802133909711,
      "mean_entropy": -0.004507984895911814
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() >0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.5253551001501107,
      "mean_entropy": -0.003466716136704797
    },
    {
      "patch": "\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     */\n    public void parseTarHeader(byte[] header) {\n        int offset = 0;\n\n        name = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctal(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctal(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = TarUtils.parseName(header, offset, NAMELEN);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = TarUtils.parseName(header, offset, UNAMELEN);\n        offset += UNAMELEN;\n        groupName = TarUtils.parseName(header, offset, GNAMELEN);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\n        offset += DEVLEN;\n        String prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n        // SunOS tar -E does not add / to directory names, so fix up to be consistent\n        if (isDirectory() && !name.endsWith(\"/\")){\n            name = name + \"/\";\n        }\n        if (prefix.length() >0){\n            name = prefix + \"/\" + name;\n        }\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 6,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames",
        [
          "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames"
        ]
      ],
      "sum_entropy": -1.5253551001501107,
      "mean_entropy": -0.003466716136704797
    }
  ],
  "Compress_9": [
    {
      "patch": "\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -2.4091243888827094,
      "mean_entropy": -0.005147701685646815
    },
    {
      "patch": "\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n\n        count(currSize); // Moved up for accurate byte count\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -17.33177675267421,
      "mean_entropy": -0.0361832500055829
    },
    {
      "patch": "\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -2.4091243888827094,
      "mean_entropy": -0.005147701685646815
    },
    {
      "patch": "\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -2.4091243888827094,
      "mean_entropy": -0.005147701685646815
    },
    {
      "patch": "\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.034726177261689,
      "mean_entropy": -0.009603563852093952
    },
    {
      "patch": "\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -1.513631727882709,
      "mean_entropy": -0.003248136755113109
    },
    {
      "patch": "\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.034726177261689,
      "mean_entropy": -0.009603563852093952
    },
    {
      "patch": "\n/**\n * Put an entry on the output stream. This writes the entry's\n * header record and positions the output stream for writing\n * the contents of the entry. Once this method is called, the\n * stream is ready for calls to write() to write the entry's\n * contents. Once the contents are written, closeArchiveEntry()\n * <B>MUST</B> be called to ensure that all buffered data\n * is completely written to the output stream.\n *\n * @param archiveEntry The TarEntry to be written to the archive.\n * @throws IOException on error\n * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n */\n@Override\npublic void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n    if(finished) {\n        throw new IOException(\"Stream has already been finished\");\n    }\n    TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n    if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n        if (longFileMode == LONGFILE_GNU) {\n            // create a TarEntry for the LongLink, the contents\n            // of which are the entry's name\n            TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                TarConstants.LF_GNUTYPE_LONGNAME);\n\n            final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n            longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n            putArchiveEntry(longLinkEntry);\n            write(nameBytes);\n            write(0); // NUL terminator\n            closeArchiveEntry();\n        } else if (longFileMode != LONGFILE_TRUNCATE) {\n            throw new RuntimeException(\"file name '\" + entry.getName()\n                                       + \"' is too long ( > \"\n                                       + TarConstants.NAMELEN + \" bytes)\");\n        }\n    }\n\n    entry.writeEntryHeader(recordBuf);\n    buffer.writeRecord(recordBuf);\n\n    currBytes = 0;\n\n    if (entry.isDirectory()) {\n        currSize = 0;\n    } else {\n        currSize = entry.getSize();\n    }\n    currName = entry.getName();\n    haveUnclosedEntry = true;\n}\n\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -5.055556304453966,
      "mean_entropy": -0.011209659211649592
    },
    {
      "patch": "\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1);\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0);\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -7.863737186896056,
      "mean_entropy": -0.028185437945864002
    },
    {
      "patch": "\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.034726177261689,
      "mean_entropy": -0.009603563852093952
    },
    {
      "patch": "\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -1.513631727882709,
      "mean_entropy": -0.003248136755113109
    },
    {
      "patch": "\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n        \n        count(currSize);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -5.417925909382708,
      "mean_entropy": -0.01147865658767523
    },
    {
      "patch": "\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -1.513631727882709,
      "mean_entropy": -0.003248136755113109
    },
    {
      "patch": "\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.034726177261689,
      "mean_entropy": -0.009603563852093952
    },
    {
      "patch": "\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -6.049141225461689,
      "mean_entropy": -0.01902245668384179
    },
    {
      "patch": "\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName() + \"' is too long ( > \" + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -6.598144039891347,
      "mean_entropy": -0.022830948234918155
    },
    {
      "patch": "\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -2.018697985808741,
      "mean_entropy": -0.004313457234634062
    },
    {
      "patch": "\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -2.018697985808741,
      "mean_entropy": -0.004313457234634062
    },
    {
      "patch": "\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        if (entry.getName().length() >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                final byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\n                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(nameBytes);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entry.getName()\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        entry.writeEntryHeader(recordBuf);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entry.getName();\n        haveUnclosedEntry = true;\n    }\n\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -4.277844526180851,
      "mean_entropy": -0.009140693432010365
    },
    {
      "patch": "\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuilder longName = new StringBuilder();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                    && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()) { // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()) { // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -5.007452724163264,
      "mean_entropy": -0.009342262545080717
    },
    {
      "patch": "\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextTarEntry(); // Changed from getNextEntry() to getNextTarEntry()\n            if (currEntry == null) {\n                return null;\n            }\n            if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()) {\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()) {\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -7.148556968826133,
      "mean_entropy": -0.019802096866554385
    },
    {
      "patch": "\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuilder longName = new StringBuilder();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextTarEntry();\n            if (currEntry == null) {\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()) { // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()) { // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -9.708822275843962,
      "mean_entropy": -0.026169332279902865
    },
    {
      "patch": "\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuilder longName = new StringBuilder();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()) { // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()) { // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -4.039541804620189,
      "mean_entropy": -0.007536458590709308
    },
    {
      "patch": "\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuilder longName = new StringBuilder();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -4.130670876344813,
      "mean_entropy": -0.010404712534873585
    },
    {
      "patch": "\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuilder longName = new StringBuilder();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()) { // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()) { // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.644564666520189,
      "mean_entropy": -0.0068250274653936125
    },
    {
      "patch": "\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                return null;\n            }\n            if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()) {\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()) {\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -2.9342416870290284,
      "mean_entropy": -0.008407569303808104
    },
    {
      "patch": "\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuilder longName = new StringBuilder();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -2.3496202594961404,
      "mean_entropy": -0.004416579435143121
    },
    {
      "patch": "\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                return null;\n            }\n            if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()) {\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()) {\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -2.9342416870290284,
      "mean_entropy": -0.008407569303808104
    },
    {
      "patch": "\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.863331057926523,
      "mean_entropy": -0.009731312488479906
    },
    {
      "patch": "\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -1.7736549807711992,
      "mean_entropy": -0.0033339379337804496
    },
    {
      "patch": "\n/**\n * Get the next entry in this tar archive. This will skip\n * over any remaining data in the current entry, if there\n * is one, and place the input stream at the header of the\n * next entry, and read the header and instantiate a new\n * TarEntry from the header bytes and return that entry.\n * If there are no more entries in the archive, null will\n * be returned to indicate that the end of the archive has\n * been reached.\n *\n * @return The next TarEntry in the archive, or null.\n * @throws IOException on error\n */\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()){ // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()){ // Process sparse files\n        readGNUSparse();\n    }\n\n    return currEntry;\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -4.385532578729462,
      "mean_entropy": -0.008482654891159501
    },
    {
      "patch": "\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -1.7736549807711992,
      "mean_entropy": -0.0033339379337804496
    },
    {
      "patch": "\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                return null;\n            }\n            if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()) {\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()) {\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -2.9342416870290284,
      "mean_entropy": -0.008407569303808104
    },
    {
      "patch": "\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuilder longName = new StringBuilder();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -4.901705350698969,
      "mean_entropy": -0.009231083522973577
    },
    {
      "patch": "\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuilder longName = new StringBuilder();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -2.3496202594961404,
      "mean_entropy": -0.004416579435143121
    },
    {
      "patch": "\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuilder longName = new StringBuilder();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -4.0855145346657125,
      "mean_entropy": -0.01029096860117308
    },
    {
      "patch": "\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -1.8727385299636792,
      "mean_entropy": -0.003520185206698645
    },
    {
      "patch": "\n/**\n * Get the next entry in this tar archive. This will skip\n * over any remaining data in the current entry, if there\n * is one, and place the input stream at the header of the\n * next entry, and read the header and instantiate a new\n * TarEntry from the header bytes and return that entry.\n * If there are no more entries in the archive, null will\n * be returned to indicate that the end of the archive has\n * been reached.\n *\n * @return The next TarEntry in the archive, or null.\n * @throws IOException on error\n */\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuilder longName = new StringBuilder();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) { // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) { // Process sparse files\n        readGNUSparse();\n    }\n\n    return currEntry;\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -5.926581377561114,
      "mean_entropy": -0.011419231941350893
    },
    {
      "patch": "\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        return currEntry;\n    }\n\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -2.505505789163679,
      "mean_entropy": -0.004691958406673556
    },
    {
      "patch": "\n    /**\n     * @return false if End-Of-File, else true\n     */\n    private boolean readBlock() throws IOException {\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset, bytesNeeded);\n\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    return false;\n                }\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                // Incomplete Read occurred - throw exception?\n            }\n        }\n\n        currBlkIdx++;\n\n        return true;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -4.913819662957049,
      "mean_entropy": -0.025070508484474743
    },
    {
      "patch": "\n    /**\n     * @return false if End-Of-File, else true\n     */\n    private boolean readBlock() throws IOException {\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset, bytesNeeded);\n\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    return false;\n                }\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                // Incomplete Read occurred - throw exception?\n            }\n        }\n\n        currBlkIdx++;\n\n        return true;\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.4637276847566,
      "mean_entropy": -0.01767208002426837
    },
    {
      "patch": "\n    /**\n     * @return false if End-Of-File, else true\n     */\n    private boolean readBlock() throws IOException {\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset, bytesNeeded);\n\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    return false;\n                }\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                // Incomplete Read occurred - throw exception?\n            }\n        }\n\n        currBlkIdx++;\n\n        return true;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.4637276847566,
      "mean_entropy": -0.01767208002426837
    },
    {
      "patch": "\n    /**\n     * @return false if End-Of-File, else true\n     */\n    private boolean readBlock() throws IOException {\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset, bytesNeeded);\n\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    return false;\n                }\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                // TODO: Incomplete Read occurred - throw exception?\n            }\n        }\n\n        currBlkIdx++;\n\n        return true;\n    }\n\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -4.0843076791406006,
      "mean_entropy": -0.020421538395703
    },
    {
      "patch": "\n    private boolean readBlock() throws IOException {\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset, bytesNeeded);\n\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    return false;\n                }\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                // Incomplete Read occurred - throw exception?\n            }\n        }\n\n        currBlkIdx++;\n\n        return true;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -5.008184843044879,
      "mean_entropy": -0.028294829621722483
    },
    {
      "patch": "\n    /**\n     * @return false if End-Of-File, else true\n     */\n    private boolean readBlock() throws IOException {\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset, bytesNeeded);\n\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    return false;\n                }\n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                // Incomplete Read occurred - throw exception?\n            }\n        }\n\n        currBlkIdx++;\n\n        return true;\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.4637276847566,
      "mean_entropy": -0.01767208002426837
    },
    {
      "patch": "\n    private boolean readBlock() throws IOException {\n        if (inStream == null) {\n            throw new IOException(\"reading from an output buffer\");\n        }\n\n        currRecIdx = 0;\n\n        int offset = 0;\n        int bytesNeeded = blockSize;\n\n        while (bytesNeeded > 0) {\n            long numBytes = inStream.read(blockBuffer, offset, bytesNeeded);\n\n            if (numBytes == -1) {\n                if (offset == 0) {\n                    return false;\n                }\n                \n                Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n                break;\n            }\n\n            offset += numBytes;\n            bytesNeeded -= numBytes;\n\n            if (numBytes != blockSize) {\n                // Incomplete Read occurred - throw exception?\n            }\n        }\n\n        currBlkIdx++;\n\n        return true;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -6.246848376591703,
      "mean_entropy": -0.03509465380107698
    },
    {
      "patch": "\nprivate boolean readBlock() throws IOException {\n    if (inStream == null) {\n        throw new IOException(\"reading from an output buffer\");\n    }\n\n    currRecIdx = 0;\n\n    int offset = 0;\n    int bytesNeeded = blockSize;\n\n    while (bytesNeeded > 0) {\n        long numBytes = inStream.read(blockBuffer, offset, bytesNeeded);\n\n        if (numBytes == -1) {\n            if (offset == 0) {\n                return false;\n            }\n\n            Arrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\n            break;\n        }\n\n        offset += numBytes;\n        bytesNeeded -= numBytes;\n\n        if (numBytes != blockSize) {\n            // TODO: Incomplete Read occurred - throw exception?\n        }\n    }\n\n    currBlkIdx++;\n\n    return true;\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -5.618345975658372,
      "mean_entropy": -0.031742067659086846
    },
    {
      "patch": "\nprivate void paxHeaders() throws IOException{\n    Reader br = new InputStreamReader(this, \"UTF-8\") {\n        @Override\n        public void close() {\n            // make sure GC doesn't close \"this\" before we are done\n        }\n    };\n    Map<String, String> headers = new HashMap<String, String>();\n    // Format is \"length keyword=value\\n\";\n    try {\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = br.read()) != -1){\n                read++;\n                if (ch == ' '){ // End of length string\n                    // Get keyword\n                    StringBuffer sb = new StringBuffer();\n                    while((ch = br.read()) != -1){\n                        read++;\n                        if (ch == '='){ // end of keyword\n                            String keyword = sb.toString();\n                            // Get rest of entry\n                            char[] cbuf = new char[len-read];\n                            int got = br.read(cbuf);\n                            if (got != len - read){\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + (len - read)\n                                                      + \" chars, read \"\n                                                      + got);\n                            }\n                            // Drop trailing NL\n                            String value = new String(cbuf, 0,\n                                                      len - read - 1);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        sb.append((char) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF\n                break;\n            }\n        }\n    } finally {\n        // NO-OP but makes FindBugs happy\n        br.close();\n    }\n\n    getNextEntry(); // Get the actual file entry\n    /*\n     * The following headers are defined for Pax.\n     * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n     * comment\n     * gid, gname\n     * linkpath\n     * size\n     * uid,uname\n     */\n    for (Entry<String, String> ent : headers.entrySet()){\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)){\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)){\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)){\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)){\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)){\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)){\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)){\n            currEntry.setSize(Long.parseLong(val));\n        }\n    }\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.499817129578643,
      "mean_entropy": -0.0058233230109461616
    },
    {
      "patch": "\n    private void paxHeaders() throws IOException{\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n                @Override\n                public void close() {\n                    // make sure GC doesn't close \"this\" before we are done\n                }\n            };\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        try {\n            while(true){ // get length\n                int ch;\n                int len = 0;\n                int read = 0;\n                while((ch = br.read()) != -1){\n                    read++;\n                    if (ch == ' '){ // End of length string\n                        // Get keyword\n                        StringBuffer sb = new StringBuffer();\n                        while((ch = br.read()) != -1){\n                            read++;\n                            if (ch == '='){ // end of keyword\n                                String keyword = sb.toString();\n                                // Get rest of entry\n                                char[] cbuf = new char[len-read];\n                                int got = br.read(cbuf);\n                                if (got != len - read){\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + (len - read)\n                                                          + \" chars, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL\n                                String value = new String(cbuf, 0,\n                                                          len - read - 1);\n                                headers.put(keyword, value);\n                                break;\n                            }\n                            sb.append((char) ch);\n                        }\n                        break; // Processed single header\n                    }\n                    len *= 10;\n                    len += ch - '0';\n                }\n                if (ch == -1){ // EOF\n                    break;\n                }\n            }\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         */\n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.124369408548329,
      "mean_entropy": -0.005181375470229402
    },
    {
      "patch": "\nprivate void paxHeaders() throws IOException {\n    Reader br = new InputStreamReader(this, \"UTF-8\") {\n        @Override\n        public void close() {\n            // make sure GC doesn't close \"this\" before we are done\n        }\n    };\n    Map<String, String> headers = new HashMap<String, String>();\n    // Format is \"length keyword=value\\n\";\n    try {\n        while (true) { // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while ((ch = br.read()) != -1) {\n                read++;\n                if (ch == ' ') { // End of length string\n                    // Get keyword\n                    StringBuffer sb = new StringBuffer();\n                    while ((ch = br.read()) != -1) {\n                        read++;\n                        if (ch == '=') { // end of keyword\n                            String keyword = sb.toString();\n                            // Get rest of entry\n                            char[] cbuf = new char[len - read];\n                            int got = br.read(cbuf);\n                            if (got != len - read) {\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + (len - read) + \" chars, read \" + got);\n                            }\n                            // Drop trailing NL\n                            String value = new String(cbuf, 0, len - read - 1);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        sb.append((char) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1) { // EOF\n                break;\n            }\n        }\n    } finally {\n        // NO-OP but makes FindBugs happy\n        br.close();\n    }\n\n    getNextEntry(); // Get the actual file entry\n    /*\n     * The following headers are defined for Pax.\n     * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n     * comment\n     * gid, gname\n     * linkpath\n     * size\n     * uid, uname\n     */\n    for (Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        }\n    }\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -5.9017482568269575,
      "mean_entropy": -0.009643379504619212
    },
    {
      "patch": "\n    private void paxHeaders() throws IOException {\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n            @Override\n            public void close() {\n                // make sure GC doesn't close \"this\" before we are done\n            }\n        };\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        try {\n            while (true) { // get length\n                int ch;\n                int len = 0;\n                int read = 0;\n                while ((ch = br.read()) != -1) {\n                    read++;\n                    if (ch == ' ') { // End of length string\n                        // Get keyword\n                        StringBuffer sb = new StringBuffer();\n                        while ((ch = br.read()) != -1) {\n                            read++;\n                            if (ch == '=') { // end of keyword\n                                String keyword = sb.toString();\n                                // Get rest of entry\n                                char[] cbuf = new char[len - read];\n                                int got = br.read(cbuf);\n                                if (got != len - read) {\n                                    throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + (len - read)\n                                            + \" chars, read \" + got);\n                                }\n                                // Drop trailing NL\n                                String value = new String(cbuf, 0, len - read - 1);\n                                headers.put(keyword, value);\n                                break;\n                            }\n                            sb.append((char) ch);\n                        }\n                        break; // Processed single header\n                    }\n                    len *= 10;\n                    len += ch - '0';\n                }\n                if (ch == -1) { // EOF\n                    break;\n                }\n            }\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        /*\n         * The following headers are defined for Pax. atime, ctime, mtime, charset: cannot use these without changing\n         * TarArchiveEntry fields comment gid, gname linkpath size uid,uname\n         */\n        for (Entry<String, String> ent : headers.entrySet()) {\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)) {\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)) {\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)) {\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)) {\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)) {\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)) {\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)) {\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -8.7819581038836,
      "mean_entropy": -0.014612243101303827
    },
    {
      "patch": "\n    private void paxHeaders() throws IOException {\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n            @Override\n            public void close() {\n                // make sure GC doesn't close \"this\" before we are done\n            }\n        };\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        try {\n            while (true) {\n                int ch;\n                int len = 0;\n                int read = 0;\n                while ((ch = br.read()) != -1) {\n                    read++;\n                    if (ch == ' ') { // End of length string\n                        // Get keyword\n                        StringBuffer sb = new StringBuffer();\n                        while ((ch = br.read()) != -1) {\n                            read++;\n                            if (ch == '=') { // end of keyword\n                                String keyword = sb.toString();\n                                // Get rest of entry\n                                char[] cbuf = new char[len - read];\n                                int got = br.read(cbuf);\n                                if (got != len - read) {\n                                    throw new IOException(\"Failed to read \"\n                                        + \"Paxheader. Expected \"\n                                        + (len - read)\n                                        + \" chars, read \"\n                                        + got);\n                                }\n                                // Drop trailing NL\n                                String value = new String(cbuf, 0,\n                                    len - read - 1);\n                                headers.put(keyword, value);\n                                break;\n                            }\n                            sb.append((char) ch);\n                        }\n                        break; // Processed single header\n                    }\n                    len *= 10;\n                    len += ch - '0';\n                }\n                if (ch == -1) { // EOF\n                    break;\n                }\n            }\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        /*\n        * The following headers are defined for Pax.\n        * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n        * comment\n        * gid, gname\n        * linkpath\n        * size\n        * uid,uname\n        */\n        for (Map.Entry<String, String> ent : headers.entrySet()) {\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)) {\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)) {\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)) {\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)) {\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)) {\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)) {\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)) {\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -14.352693451571097,
      "mean_entropy": -0.02329982703177126
    },
    {
      "patch": "\nprivate void paxHeaders() throws IOException {\n    Reader br = new InputStreamReader(this, \"UTF-8\") {\n        @Override\n        public void close() {\n            // make sure GC doesn't close \"this\" before we are done\n        }\n    };\n    Map<String, String> headers = new HashMap<String, String>();\n    // Format is \"length keyword=value\\n\";\n    try {\n        while (true) { // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while ((ch = br.read()) != -1) {\n                read++;\n                if (ch == ' ') { // End of length string\n                    // Get keyword\n                    StringBuffer sb = new StringBuffer();\n                    while ((ch = br.read()) != -1) {\n                        read++;\n                        if (ch == '=') { // end of keyword\n                            String keyword = sb.toString();\n                            // Get rest of entry\n                            char[] cbuf = new char[len - read];\n                            int got = br.read(cbuf);\n                            if (got != len - read) {\n                                throw new IOException(\"Failed to read \"\n                                        + \"Paxheader. Expected \"\n                                        + (len - read)\n                                        + \" chars, read \"\n                                        + got);\n                            }\n                            // Drop trailing NL\n                            String value = new String(cbuf, 0,\n                                    len - read - 1);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        sb.append((char) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1) { // EOF\n                break;\n            }\n        }\n    } finally {\n        // NO-OP but makes FindBugs happy\n        br.close();\n    }\n\n    getNextEntry(); // Get the actual file entry\n    /*\n     * The following headers are defined for Pax.\n     * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n     * comment\n     * gid, gname\n     * linkpath\n     * size\n     * uid,uname\n     */\n    for (Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        }\n    }\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -5.373757740995888,
      "mean_entropy": -0.00870949390761084
    },
    {
      "patch": "\n    private void paxHeaders() throws IOException{\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n            @Override\n            public void close() {\n                // make sure GC doesn't close \"this\" before we are done\n            }\n        };\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        try {\n            while (true) { // get length\n                int ch;\n                int len = 0;\n                int read = 0;\n                while ((ch = br.read()) != -1) {\n                    read++;\n                    if (ch == ' ') { // End of length string\n                        // Get keyword\n                        StringBuilder sb = new StringBuilder();\n                        while ((ch = br.read()) != -1) {\n                            read++;\n                            if (ch == '=') { // end of keyword\n                                String keyword = sb.toString();\n                                // Get rest of entry\n                                char[] cbuf = new char[len - read];\n                                int got = br.read(cbuf);\n                                if (got != len - read) {\n                                    throw new IOException(\"Failed to read Paxheader. Expected \"\n                                            + (len - read)\n                                            + \" chars, read \"\n                                            + got);\n                                }\n                                // Drop trailing NL\n                                String value = new String(cbuf, 0,\n                                        len - read - 1);\n                                headers.put(keyword, value);\n                                break;\n                            }\n                            sb.append((char) ch);\n                        }\n                        break; // Processed single header\n                    }\n                    len *= 10;\n                    len += ch - '0';\n                }\n                if (ch == -1) { // EOF\n                    break;\n                }\n            }\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid, uname\n         */\n        for (Map.Entry<String, String> ent : headers.entrySet()) {\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)) {\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)) {\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)) {\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)) {\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)) {\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)) {\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)) {\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -10.874410897036176,
      "mean_entropy": -0.017681968938270204
    },
    {
      "patch": "\n    private void paxHeaders() throws IOException{\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n            @Override\n            public void close() {\n                // make sure GC doesn't close \"this\" before we are done\n            }\n        };\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        try {\n            while(true){ // get length\n                int ch;\n                int len = 0;\n                int read = 0;\n                while((ch = br.read()) != -1){\n                    read++;\n                    if (ch == ' '){ // End of length string\n                        // Get keyword\n                        StringBuffer sb = new StringBuffer();\n                        while((ch = br.read()) != -1){\n                            read++;\n                            if (ch == '='){ // end of keyword\n                                String keyword = sb.toString();\n                                // Get rest of entry\n                                char[] cbuf = new char[len-read];\n                                int got = br.read(cbuf);\n                                if (got != len - read){\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + (len - read)\n                                                          + \" chars, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL\n                                String value = new String(cbuf, 0,\n                                                          len - read - 1);\n                                headers.put(keyword, value);\n                                break;\n                            }\n                            sb.append((char) ch);\n                        }\n                        break; // Processed single header\n                    }\n                    len *= 10;\n                    len += ch - '0';\n                }\n                if (ch == -1){ // EOF\n                    break;\n                }\n            }\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         */\n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.584924482215104,
      "mean_entropy": -0.005945148395049923
    },
    {
      "patch": "\n    private void paxHeaders() throws IOException {\n        InputStreamReader br = new InputStreamReader(this, \"UTF-8\");\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        try {\n            while (true) { // get length\n                int ch;\n                int len = 0;\n                int read = 0;\n                while ((ch = br.read()) != -1) {\n                    read++;\n                    if (ch == ' ') { // End of length string\n                        // Get keyword\n                        StringBuffer sb = new StringBuffer();\n                        while ((ch = br.read()) != -1) {\n                            read++;\n                            if (ch == '=') { // end of keyword\n                                String keyword = sb.toString();\n                                // Get rest of entry\n                                char[] cbuf = new char[len - read];\n                                int got = br.read(cbuf);\n                                if (got != len - read) {\n                                    throw new IOException(\"Failed to read \" +\n                                            \"Paxheader. Expected \" +\n                                            (len - read) +\n                                            \" chars, read \" +\n                                            got);\n                                }\n                                // Drop trailing NL\n                                String value = new String(cbuf, 0,\n                                        len - read - 1);\n                                headers.put(keyword, value);\n                                break;\n                            }\n                            sb.append((char) ch);\n                        }\n                        break; // Processed single header\n                    }\n                    len *= 10;\n                    len += ch - '0';\n                }\n                if (ch == -1) { // EOF\n                    break;\n                }\n            }\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         */\n        for (Map.Entry<String, String> ent : headers.entrySet()) {\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)) {\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)) {\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)) {\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)) {\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)) {\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)) {\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)) {\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -12.451125321106618,
      "mean_entropy": -0.021139431784561322
    },
    {
      "patch": "\nprivate void paxHeaders() throws IOException {\n    Reader br = new InputStreamReader(this, \"UTF-8\") {\n        @Override\n        public void close() {\n            // make sure GC doesn't close \"this\" before we are done\n        }\n    };\n    Map<String, String> headers = new HashMap<String, String>();\n    // Format is \"length keyword=value\\n\";\n    try {\n        while (true) { // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while ((ch = br.read()) != -1) {\n                read++;\n                if (ch == ' ') { // End of length string\n                    // Get keyword\n                    StringBuffer sb = new StringBuffer();\n                    while ((ch = br.read()) != -1) {\n                        read++;\n                        if (ch == '=') { // end of keyword\n                            String keyword = sb.toString();\n                            // Get rest of entry\n                            char[] cbuf = new char[len - read];\n                            int got = br.read(cbuf);\n                            if (got != len - read) {\n                                throw new IOException(\"Failed to read Paxheader. Expected \"\n                                        + (len - read)\n                                        + \" chars, read \"\n                                        + got);\n                            }\n                            // Drop trailing NL\n                            String value = new String(cbuf, 0, len - read - 1);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        sb.append((char) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1) { // EOF\n                break;\n            }\n        }\n    } finally {\n        // NO-OP but makes FindBugs happy\n        br.close();\n    }\n\n    getNextEntry(); // Get the actual file entry\n    /*\n     * The following headers are defined for Pax.\n     * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n     * comment\n     * gid, gname\n     * linkpath\n     * size\n     * uid, uname\n     */\n    for (Map.Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        }\n    }\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -8.187611286989057,
      "mean_entropy": -0.013378449815341597
    },
    {
      "patch": "\n    private void paxHeaders() throws IOException{\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n            @Override\n            public void close() {\n                // make sure GC doesn't close \"this\" before we are done\n            }\n        };\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        try {\n            while(true){ // get length\n                int ch;\n                int len = 0;\n                int read = 0;\n                while((ch = br.read()) != -1){\n                    read++;\n                    if (ch == ' '){ // End of length string\n                        // Get keyword\n                        StringBuffer sb = new StringBuffer();\n                        while((ch = br.read()) != -1){\n                            read++;\n                            if (ch == '='){ // end of keyword\n                                String keyword = sb.toString();\n                                // Get rest of entry\n                                char[] cbuf = new char[len-read];\n                                int got = br.read(cbuf);\n                                if (got != len - read){\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + (len - read)\n                                                          + \" chars, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL\n                                String value = new String(cbuf, 0,\n                                                          len - read - 1);\n                                headers.put(keyword, value);\n                                break;\n                            }\n                            sb.append((char) ch);\n                        }\n                        break; // Processed single header\n                    }\n                    len *= 10;\n                    len += ch - '0';\n                }\n                if (ch == -1){ // EOF\n                    break;\n                }\n            }\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         */\n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -3.584924482215104,
      "mean_entropy": -0.005945148395049923
    },
    {
      "patch": "\n    private void paxHeaders() throws IOException{\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n            @Override\n            public void close() {\n                // make sure GC doesn't close \"this\" before we are done\n            }\n        };\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        try {\n            while (true) { // get length\n                int ch;\n                int len = 0;\n                int read = 0;\n                while ((ch = br.read()) != -1) {\n                    read++;\n                    if (ch == ' ') { // End of length string\n                        // Get keyword\n                        StringBuffer sb = new StringBuffer();\n                        while ((ch = br.read()) != -1) {\n                            read++;\n                            if (ch == '=') { // end of keyword\n                                String keyword = sb.toString();\n                                // Get rest of entry\n                                char[] cbuf = new char[len - read];\n                                int got = br.read(cbuf);\n                                if (got != len - read) {\n                                    throw new IOException(\"Failed to read \"\n                                            + \"Paxheader. Expected \"\n                                            + (len - read)\n                                            + \" chars, read \"\n                                            + got);\n                                }\n                                // Drop trailing NL\n                                String value = new String(cbuf, 0,\n                                        len - read - 1);\n                                headers.put(keyword, value);\n                                break;\n                            }\n                            sb.append((char) ch);\n                        }\n                        break; // Processed single header\n                    }\n                    len *= 10;\n                    len += ch - '0';\n                }\n                if (ch == -1) { // EOF\n                    break;\n                }\n            }\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid, uname\n         */\n        for (Map.Entry<String, String> ent : headers.entrySet()) {\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)) {\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)) {\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)) {\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)) {\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)) {\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)) {\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)) {\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -6.904023020573868,
      "mean_entropy": -0.011135521000925594
    },
    {
      "patch": "\n    private void paxHeaders() throws IOException{\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n            @Override\n            public void close() {\n                // make sure GC doesn't close \"this\" before we are done\n            }\n        };\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        try {\n            while(true){ // get length\n                int ch;\n                int len = 0;\n                int read = 0;\n                while((ch = br.read()) != -1){\n                    read++;\n                    if (ch == ' '){ // End of length string\n                        // Get keyword\n                        StringBuffer sb = new StringBuffer();\n                        while((ch = br.read()) != -1){\n                            read++;\n                            if (ch == '='){ // end of keyword\n                                String keyword = sb.toString();\n                                // Get rest of entry\n                                char[] cbuf = new char[len-read];\n                                int got = br.read(cbuf);\n                                if (got != len - read){\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + (len - read)\n                                                          + \" chars, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL\n                                String value = new String(cbuf, 0,\n                                                          len - read - 1);\n                                headers.put(keyword, value);\n                                break;\n                            }\n                            sb.append((char) ch);\n                        }\n                        break; // Processed single header\n                    }\n                    len *= 10;\n                    len += ch - '0';\n                }\n                if (ch == -1){ // EOF\n                    break;\n                }\n            }\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         */\n        for (Map.Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -5.352573661870617,
      "mean_entropy": -0.008861876923626848
    },
    {
      "patch": "\nprivate void paxHeaders() throws IOException {\n    InputStreamReader br = new InputStreamReader(this, \"UTF-8\") {\n        @Override\n        public void close() {\n            // make sure GC doesn't close \"this\" before we are done\n        }\n    };\n    Map<String, String> headers = new HashMap<String, String>();\n    // Format is \"length keyword=value\\n\";\n    try {\n        while(true) { // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = br.read()) != -1) {\n                read++;\n                if (ch == ' ') { // End of length string\n                    // Get keyword\n                    StringBuilder sb = new StringBuilder();\n                    while((ch = br.read()) != -1) {\n                        read++;\n                        if (ch == '=') { // end of keyword\n                            String keyword = sb.toString();\n                            // Get rest of entry\n                            char[] cbuf = new char[len - read];\n                            int got = br.read(cbuf);\n                            if (got != len - read) {\n                                throw new IOException(\"Failed to read Paxheader. Expected \" + (len - read) + \" chars, read \" + got);\n                            }\n                            // Drop trailing NL\n                            String value = new String(cbuf, 0, len - read - 1);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        sb.append((char) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1) { // EOF\n                break;\n            }\n        }\n    } finally {\n        // NO-OP but makes FindBugs happy\n        br.close();\n    }\n\n    getNextEntry(); // Get the actual file entry\n    /*\n     * The following headers are defined for Pax.\n     * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n     * comment\n     * gid, gname\n     * linkpath\n     * size\n     * uid, uname\n     */\n    for (Map.Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Integer.parseInt(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Integer.parseInt(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        }\n    }\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -14.497986105483784,
      "mean_entropy": -0.023845371884019383
    },
    {
      "patch": "\n    private void paxHeaders() throws IOException{\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n            @Override\n            public void close() {\n                // make sure GC doesn't close \"this\" before we are done\n            }\n        };\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        try {\n            while(true){ // get length\n                int ch;\n                int len = 0;\n                int read = 0;\n                while((ch = br.read()) != -1){\n                    read++;\n                    if (ch == ' '){ // End of length string\n                        // Get keyword\n                        StringBuffer sb = new StringBuffer();\n                        while((ch = br.read()) != -1){\n                            read++;\n                            if (ch == '='){ // end of keyword\n                                String keyword = sb.toString();\n                                // Get rest of entry\n                                char[] cbuf = new char[len-read];\n                                int got = br.read(cbuf);\n                                if (got != len - read){\n                                    throw new IOException(\"Failed to read \"\n                                            + \"Paxheader. Expected \"\n                                            + (len - read)\n                                            + \" chars, read \"\n                                            + got);\n                                }\n                                // Drop trailing NL\n                                String value = new String(cbuf, 0,\n                                        len - read - 1);\n                                headers.put(keyword, value);\n                                break;\n                            }\n                            sb.append((char) ch);\n                        }\n                        break; // Processed single header\n                    }\n                    len *= 10;\n                    len += ch - '0';\n                }\n                if (ch == -1){ // EOF\n                    break;\n                }\n            }\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         */\n        for (Map.Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -4.604765556511978,
      "mean_entropy": -0.007623784033960229
    },
    {
      "patch": "\n    private void paxHeaders() throws IOException {\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n            @Override\n            public void close() {\n                // make sure GC doesn't close \"this\" before we are done\n            }\n        };\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        try {\n            while (true) { // get length\n                int ch;\n                int len = 0;\n                int read = 0;\n                while ((ch = br.read()) != -1) {\n                    read++;\n                    if (ch == ' ') { // End of length string\n                        // Get keyword\n                        StringBuffer sb = new StringBuffer();\n                        while ((ch = br.read()) != -1) {\n                            read++;\n                            if (ch == '=') { // end of keyword\n                                String keyword = sb.toString();\n                                // Get rest of entry\n                                char[] cbuf = new char[len - read];\n                                int got = br.read(cbuf);\n                                if (got != len - read) {\n                                    throw new IOException(\"Failed to read \"\n                                            + \"Paxheader. Expected \"\n                                            + (len - read)\n                                            + \" chars, read \"\n                                            + got);\n                                }\n                                // Drop trailing NL\n                                String value = new String(cbuf, 0,\n                                        len - read - 1);\n                                headers.put(keyword, value);\n                                break;\n                            }\n                            sb.append((char) ch);\n                        }\n                        break; // Processed single header\n                    }\n                    len *= 10;\n                    len += ch - '0';\n                }\n                if (ch == -1) { // EOF\n                    break;\n                }\n            }\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         */\n        for (Entry<String, String> ent : headers.entrySet()) {\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)) {\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)) {\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)) {\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)) {\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)) {\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)) {\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)) {\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 24,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount",
        [
          "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount"
        ]
      ],
      "sum_entropy": -4.455542672179777,
      "mean_entropy": -0.007197968775734696
    }
  ],
  "Csv_14": [
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.6778615660430695,
      "mean_entropy": -0.0011567603516093336
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.6778615660430695,
      "mean_entropy": -0.0011567603516093336
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.6778615660430695,
      "mean_entropy": -0.0011567603516093336
    },
    {
      "patch": "\n/**\n * Creates a customized CSV format.\n *\n * @param delimiter\n *            the char used for value separation, must not be a line break character\n * @param quoteChar\n *            the Character used as value encapsulation marker, may be {@code null} to disable\n * @param quoteMode\n *            the quote mode\n * @param commentStart\n *            the Character used for comment identification, may be {@code null} to disable\n * @param escape\n *            the Character used to escape special characters in values, may be {@code null} to disable\n * @param ignoreSurroundingSpaces\n *            {@code true} when whitespaces enclosing values should be ignored\n * @param ignoreEmptyLines\n *            {@code true} when the parser should skip empty lines\n * @param recordSeparator\n *            the line separator to use for output\n * @param nullString\n *            the line separator to use for output\n * @param headerComments\n *            the comments to be printed by the Printer before the actual CSV data\n * @param header\n *            the header\n * @param skipHeaderRecord\n *            TODO\n * @param allowMissingColumnNames\n *            TODO\n * @param ignoreHeaderCase\n *            TODO\n * @param trim\n *            TODO\n * @param trailingDelimiter\n *            TODO\n * @throws IllegalArgumentException\n *             if the delimiter is a line break character\n */\nprivate CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n        final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n        final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n        final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n        final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n        final boolean trailingDelimiter) {\n    this.delimiter = delimiter;\n    this.quoteCharacter = quoteChar;\n    this.quoteMode = quoteMode;\n    this.commentMarker = commentStart;\n    this.escapeCharacter = escape;\n    this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n    this.allowMissingColumnNames = allowMissingColumnNames;\n    this.ignoreEmptyLines = ignoreEmptyLines;\n    this.recordSeparator = recordSeparator;\n    this.nullString = nullString;\n    this.headerComments = toStringArray(headerComments);\n    this.header = header == null ? null : header.clone();\n    this.skipHeaderRecord = skipHeaderRecord;\n    this.ignoreHeaderCase = ignoreHeaderCase;\n    this.trailingDelimiter = trailingDelimiter;\n    this.trim = trim;\n    validate();\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -2.381754941173416,
      "mean_entropy": -0.004362188536947648
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.6778615660430695,
      "mean_entropy": -0.0011567603516093336
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.6778615660430695,
      "mean_entropy": -0.0011567603516093336
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.6778615660430695,
      "mean_entropy": -0.0011567603516093336
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.6778615660430695,
      "mean_entropy": -0.0011567603516093336
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.6778615660430695,
      "mean_entropy": -0.0011567603516093336
    },
    {
      "patch": "\n/**\n * Creates a customized CSV format.\n *\n * @param delimiter\n *            the char used for value separation, must not be a line break character\n * @param quoteChar\n *            the Character used as value encapsulation marker, may be {@code null} to disable\n * @param quoteMode\n *            the quote mode\n * @param commentStart\n *            the Character used for comment identification, may be {@code null} to disable\n * @param escape\n *            the Character used to escape special characters in values, may be {@code null} to disable\n * @param ignoreSurroundingSpaces\n *            {@code true} when whitespaces enclosing values should be ignored\n * @param ignoreEmptyLines\n *            {@code true} when the parser should skip empty lines\n * @param recordSeparator\n *            the line separator to use for output\n * @param nullString\n *            the line separator to use for output\n * @param headerComments\n *            the comments to be printed by the Printer before the actual CSV data\n * @param header\n *            the header\n * @param skipHeaderRecord\n *            TODO\n * @param allowMissingColumnNames\n *            TODO\n * @param ignoreHeaderCase\n *            TODO\n * @param trim\n *            TODO\n * @param trailingDelimiter\n *            TODO\n * @throws IllegalArgumentException\n *             if the delimiter is a line break character\n */\nprivate CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n        final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n        final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n        final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n        final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n        final boolean trailingDelimiter) {\n    this.delimiter = delimiter;\n    this.quoteCharacter = quoteChar;\n    this.quoteMode = quoteMode;\n    this.commentMarker = commentStart;\n    this.escapeCharacter = escape;\n    this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n    this.allowMissingColumnNames = allowMissingColumnNames;\n    this.ignoreEmptyLines = ignoreEmptyLines;\n    this.recordSeparator = recordSeparator;\n    this.nullString = nullString;\n    this.headerComments = toStringArray(headerComments);\n    this.header = header == null ? null : header.clone();\n    this.skipHeaderRecord = skipHeaderRecord;\n    this.ignoreHeaderCase = ignoreHeaderCase;\n    this.trailingDelimiter = trailingDelimiter;\n    this.trim = trim;\n    validate();\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -2.381754941173416,
      "mean_entropy": -0.004362188536947648
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n                      final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n                      final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n                      final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n                      final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n                      final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -2.213242461648281,
      "mean_entropy": -0.0037768642690243705
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n                      final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n                      final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n                      final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n                      final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n                      final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -2.213242461648281,
      "mean_entropy": -0.0037768642690243705
    },
    {
      "patch": "\n/**\n * Creates a customized CSV format.\n *\n * @param delimiter\n *            the char used for value separation, must not be a line break character\n * @param quoteChar\n *            the Character used as value encapsulation marker, may be {@code null} to disable\n * @param quoteMode\n *            the quote mode\n * @param commentStart\n *            the Character used for comment identification, may be {@code null} to disable\n * @param escape\n *            the Character used to escape special characters in values, may be {@code null} to disable\n * @param ignoreSurroundingSpaces\n *            {@code true} when whitespaces enclosing values should be ignored\n * @param ignoreEmptyLines\n *            {@code true} when the parser should skip empty lines\n * @param recordSeparator\n *            the line separator to use for output\n * @param nullString\n *            the line separator to use for output\n * @param headerComments\n *            the comments to be printed by the Printer before the actual CSV data\n * @param header\n *            the header\n * @param skipHeaderRecord\n *            TODO\n * @param allowMissingColumnNames\n *            TODO\n * @param ignoreHeaderCase\n *            TODO\n * @param trim\n *            TODO\n * @param trailingDelimiter\n *            TODO\n * @throws IllegalArgumentException\n *             if the delimiter is a line break character\n */\nprivate CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n        final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n        final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n        final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n        final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n        final boolean trailingDelimiter) {\n    this.delimiter = delimiter;\n    this.quoteCharacter = quoteChar;\n    this.quoteMode = quoteMode;\n    this.commentMarker = commentStart;\n    this.escapeCharacter = escape;\n    this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n    this.allowMissingColumnNames = allowMissingColumnNames;\n    this.ignoreEmptyLines = ignoreEmptyLines;\n    this.recordSeparator = recordSeparator;\n    this.nullString = nullString;\n    this.headerComments = toStringArray(headerComments);\n    this.header = header == null ? null : header.clone();\n    this.skipHeaderRecord = skipHeaderRecord;\n    this.ignoreHeaderCase = ignoreHeaderCase;\n    this.trailingDelimiter = trailingDelimiter;\n    this.trim = trim;\n    validate();\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -2.381754941173416,
      "mean_entropy": -0.004362188536947648
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.6778615660430695,
      "mean_entropy": -0.0011567603516093336
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.6778615660430695,
      "mean_entropy": -0.0011567603516093336
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.6778615660430695,
      "mean_entropy": -0.0011567603516093336
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -0.8312956886214906,
      "mean_entropy": -0.001418593325292646
    },
    {
      "patch": "\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -1.7617108920297593,
      "mean_entropy": -0.007046843568119037
    },
    {
      "patch": "\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n                      final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n                      final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n                      final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n                      final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n                      final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -2.5954351636723616,
      "mean_entropy": -0.0044290702451746785
    },
    {
      "patch": "\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVPrinterTest::testEscapeNull1\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 6,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 6,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
        [
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeNull5",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash1",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash4",
          "org.apache.commons.csv.CSVPrinterTest::testEscapeBackslash5"
        ]
      ],
      "sum_entropy": -1.7617108920297593,
      "mean_entropy": -0.007046843568119037
    }
  ],
  "Csv_4": [
    {
      "patch": "\n/**\n * Initializes the name to index mapping if the format defines a header.\n */\nprivate Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n\n        String[] header = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord record = this.nextRecord();\n            if (record != null) {\n                header = record.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            header = formatHeader;\n        }\n\n        // build the name to index mappings\n        if (header != null) {\n            for (int i = 0; i < header.length; i++) {\n                if (header[i] != null) {\n                    hdrMap.put(header[i], i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -5.797134890674781,
      "mean_entropy": -0.0258800664762267
    },
    {
      "patch": "\n/**\n * Initializes the name to index mapping if the format defines a header.\n */\nprivate Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n\n        String[] header = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord record = this.nextRecord();\n            if (record != null) {\n                header = record.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            header = formatHeader;\n        }\n\n        // build the name to index mappings\n        if (header != null) {\n            for (int i = 0; i < header.length; i++) {\n                hdrMap.put(header[i], Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -3.16372913571211,
      "mean_entropy": -0.014783781008000514
    },
    {
      "patch": "\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord record = this.nextRecord();\n                if (record != null) {\n                    header = record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap != null ? hdrMap : new LinkedHashMap<String, Integer>();\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -2.4718010881723096,
      "mean_entropy": -0.010746961252923085
    },
    {
      "patch": "\n/**\n * Initializes the name to index mapping if the format defines a header.\n */\nprivate Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n\n        String[] header = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord record = this.nextRecord();\n            if (record != null) {\n                header = record.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            header = formatHeader;\n        }\n\n        // build the name to index mappings\n        if (header != null) {\n            for (int i = 0; i < header.length; i++) {\n                hdrMap.put(header[i], Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap != null ? hdrMap : new LinkedHashMap<String, Integer>();\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -2.3739382769906094,
      "mean_entropy": -0.010550836786624931
    },
    {
      "patch": "\n/**\n * Initializes the name to index mapping if the format defines a header.\n */\nprivate Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n\n        String[] header = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord record = this.nextRecord();\n            if (record != null) {\n                header = record.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            header = formatHeader;\n        }\n\n        // build the name to index mappings\n        if (header != null) {\n            for (int i = 0; i < header.length; i++) {\n                hdrMap.put(header[i], i);\n            }\n        }\n    }\n    return hdrMap;\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -2.35369270545811,
      "mean_entropy": -0.011102324082349575
    },
    {
      "patch": "\n/**\n * Initializes the name to index mapping if the format defines a header.\n */\nprivate Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = new LinkedHashMap<String, Integer>(); // Initialize hdrMap with LinkedHashMap\n\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        String[] header = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord record = this.nextRecord();\n            if (record != null) {\n                header = record.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            header = formatHeader;\n        }\n\n        // build the name to index mappings\n        if (header != null) {\n            for (int i = 0; i < header.length; i++) {\n                hdrMap.put(header[i], Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -10.043641641700333,
      "mean_entropy": -0.04671461228697829
    },
    {
      "patch": "\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord record = this.nextRecord();\n                if (record != null) {\n                    header = record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], i);\n                }\n            }\n        }\n        return hdrMap;\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -3.415112521786109,
      "mean_entropy": -0.015737845722516634
    },
    {
      "patch": "\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord record = this.nextRecord();\n                if (record != null) {\n                    header = record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap != null ? hdrMap : new LinkedHashMap<String, Integer>();\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -2.4718010881723096,
      "mean_entropy": -0.010746961252923085
    },
    {
      "patch": "\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord record = this.nextRecord();\n                if (record != null) {\n                    header = record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -2.2904886710886094,
      "mean_entropy": -0.010458852379400044
    },
    {
      "patch": "\n/**\n * Initializes the name to index mapping if the format defines a header.\n */\nprivate Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n\n        String[] header = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord record = this.nextRecord();\n            if (record != null) {\n                header = record.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            header = formatHeader;\n        }\n\n        // build the name to index mappings\n        if (header != null) {\n            for (int i = 0; i < header.length; i++) {\n                hdrMap.put(header[i], i);\n            }\n        }\n    }\n    return hdrMap;\n}\n\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -2.55068277019811,
      "mean_entropy": -0.011919078365411728
    },
    {
      "patch": "\n/**\n * Initializes the name to index mapping if the format defines a header.\n */\nprivate Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n\n        String[] header = null;\n        if (formatHeader.length == 0) {\n            // read the header from the first line of the file\n            final CSVRecord record = this.nextRecord();\n            if (record != null) {\n                header = record.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            header = formatHeader;\n        }\n\n        // build the name to index mappings\n        if (header != null) {\n            for (int i = 0; i < header.length; i++) {\n                hdrMap.put(header[i], Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap != null ? new LinkedHashMap<String, Integer>(hdrMap) : null;\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -4.9186965417302115,
      "mean_entropy": -0.02157323044618514
    },
    {
      "patch": "\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord record = this.nextRecord();\n                if (record != null) {\n                    header = record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap != null ? hdrMap : new LinkedHashMap<String, Integer>();\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -2.402194328524999,
      "mean_entropy": -0.010444323167499995
    },
    {
      "patch": "\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord record = this.nextRecord();\n                if (record != null) {\n                    header = record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.csv.CSVParserTest::testNoHeaderMap\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.csv.CSVParserTest::testNoHeaderMap",
        [
          "org.apache.commons.csv.CSVParserTest::testNoHeaderMap"
        ]
      ],
      "sum_entropy": -2.447208787619399,
      "mean_entropy": -0.011174469349860269
    }
  ],
  "Gson_1": [
    {
      "patch": "\n  /**\n   * Returns the {@code Class<?>} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field\n   */\n  public Class<?> getDeclaredClass() {\n    return declaredType;\n  }\n\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -2.11877518541276,
      "mean_entropy": -0.01384820382622719
    },
    {
      "patch": "\n  /**\n   * Returns the {@code Class<?>} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field\n   */\n  public Class<?> getDeclaredClass() {\n    return declaredType;\n  }\n\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -2.11877518541276,
      "mean_entropy": -0.01384820382622719
    },
    {
      "patch": "\n  /**\n   * Returns the {@code Class<?>} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field\n   */\n  public Class<?> getDeclaredClass() {\n    return declaredType;\n  }\n\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -2.11877518541276,
      "mean_entropy": -0.01384820382622719
    },
    {
      "patch": "\n  /**\n   * Returns the {@code Class<?>} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field\n   */\n  public Class<?> getDeclaredClass() {\n    return field.getType();\n  }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -3.1442959541647597,
      "mean_entropy": -0.02082315201433616
    },
    {
      "patch": "\n/**\n * Returns the {@code Class<?>} object that was declared for this field.\n *\n * <p>For example, assume the following class definition:\n * <pre class=\"code\">\n * public class Foo {\n *   private String bar;\n *   private List&lt;String&gt; red;\n * }\n * </pre>\n *\n * <p>This method would return {@code String.class} for the {@code bar} field and\n * {@code List.class} for the {@code red} field.\n *\n * @return the specific class object that was declared for the field\n */\npublic Class<?> getDeclaredClass() {\n  return declaredType;\n}\n\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -3.3828458653000295,
      "mean_entropy": -0.02505811752074096
    },
    {
      "patch": "\n  /**\n   * Returns the {@code Class<?>} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field\n   */\n  public Class<?> getDeclaredClass() {\n    return declaredType;\n  }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -1.4765139108547598,
      "mean_entropy": -0.009778237820230197
    },
    {
      "patch": "\n  /**\n   * Returns the {@code Class<?>} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field\n   */\n  public Class<?> getDeclaredClass() {\n    return declaredType;\n  }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -1.4765139108547598,
      "mean_entropy": -0.009778237820230197
    },
    {
      "patch": "\n  /**\n   * Returns the {@code Class<?>} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field\n   */\n  public Class<?> getDeclaredClass() {\n    return declaredType;\n  }\n\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -2.11877518541276,
      "mean_entropy": -0.01384820382622719
    },
    {
      "patch": "\n  /**\n   * Returns the {@code Class<?>} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field\n   */\n  public Class<?> getDeclaredClass() {\n    return declaredType;\n  }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -1.4765139108547598,
      "mean_entropy": -0.009778237820230197
    },
    {
      "patch": "\n  /**\n   * Returns the {@code Class<?>} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field\n   */\n  public Class<?> getDeclaredClass() {\n    return declaredType;\n  }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -1.4765139108547598,
      "mean_entropy": -0.009778237820230197
    },
    {
      "patch": "\n/**\n * Returns the {@code Class<?>} object that was declared for this field.\n *\n * <p>For example, assume the following class definition:\n * <pre class=\"code\">\n * public class Foo {\n *   private String bar;\n *   private List&lt;String&gt; red;\n * }\n * </pre>\n *\n * <p>This method would return {@code String.class} for the {@code bar} field and\n * {@code List.class} for the {@code red} field.\n *\n * @return the specific class object that was declared for the field\n */\npublic Class<?> getDeclaredClass() {\n    return declaredType;\n}\n\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -3.276042362901029,
      "mean_entropy": -0.02426698046593355
    },
    {
      "patch": "\n  /**\n   * Returns the {@code Class<?>} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field\n   */\n  public Class<?> getDeclaredClass() {\n    return declaredType;\n  }\n\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -2.58661749324035,
      "mean_entropy": -0.016905996687845423
    },
    {
      "patch": "\n/**\n * Returns the {@code Class<?>} object that was declared for this field.\n *\n * <p>For example, assume the following class definition:\n * <pre class=\"code\">\n * public class Foo {\n *   private String bar;\n *   private List&lt;String&gt; red;\n * }\n * </pre>\n *\n * <p>This method would return {@code String.class} for the {@code bar} field and\n * {@code List.class} for the {@code red} field.\n *\n * @return the specific class object that was declared for the field\n */\npublic Class<?> getDeclaredClass() {\n    return field.getType();\n}\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -4.835494249346011,
      "mean_entropy": -0.03635709961914294
    },
    {
      "patch": "\n  /**\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   *\n   * Type listParmeterizedType = new TypeToken<List<String>>() {}.getType();\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code listParameterizedType} for the {@code red} field.\n   *\n   * @return the specific type declared for this field\n   */\n  public Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n  }\n\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -3.0574328098010994,
      "mean_entropy": -0.017879724033924557
    },
    {
      "patch": "\n/**\n* <p>For example, assume the following class definition:\n* <pre class=\"code\">\n* public class Foo {\n*   private String bar;\n*   private List&lt;String&gt; red;\n* }\n*\n* Type listParmeterizedType = new TypeToken<List<String>>() {}.getType();\n* </pre>\n*\n* <p>This method would return {@code String.class} for the {@code bar} field and\n* {@code listParameterizedType} for the {@code red} field.\n*\n* @return the specific type declared for this field\n*/\npublic Type getDeclaredType() {\n  if (genericType == null) {\n    genericType = field.getGenericType();\n  }\n  return genericType;\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -5.471994545657198,
      "mean_entropy": -0.03623837447455098
    },
    {
      "patch": "\npublic Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -3.0631913379865,
      "mean_entropy": -0.09282397993898485
    },
    {
      "patch": "\n  /**\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   *\n   * Type listParameterizedType = new TypeToken<List<String>>() {}.getType();\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code listParameterizedType} for the {@code red} field.\n   *\n   * @return the specific type declared for this field\n   */\n  public Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n  }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -1.1114768368848005,
      "mean_entropy": -0.006615933552885717
    },
    {
      "patch": "\n/**\n * <p>For example, assume the following class definition:\n * <pre class=\"code\">\n * public class Foo {\n *   private String bar;\n *   private List&lt;String&gt; red;\n * }\n *\n * Type listParameterizedType = new TypeToken<List<String>>() {}.getType();\n * </pre>\n *\n * <p>This method would return {@code String.class} for the {@code bar} field and\n * {@code listParameterizedType} for the {@code red} field.\n *\n * @return the specific type declared for this field\n */\npublic Type getDeclaredType() {\n  if (genericType == null) {\n    genericType = field.getGenericType();\n  }\n  return genericType;\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -2.1444993989458703,
      "mean_entropy": -0.014296662659639135
    },
    {
      "patch": "\n  /**\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   *\n   * Type listParameterizedType = new TypeToken<List<String>>() {}.getType();\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code listParameterizedType} for the {@code red} field.\n   *\n   * @return the specific type declared for this field\n   */\n  public Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n  }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -1.1114768368848005,
      "mean_entropy": -0.006615933552885717
    },
    {
      "patch": "\n/**\n * <p>For example, assume the following class definition:\n * <pre class=\"code\">\n * public class Foo {\n *   private String bar;\n *   private List&lt;String&gt; red;\n * }\n *\n * Type listParameterizedType = new TypeToken<List<String>>() {}.getType();\n * </pre>\n *\n * <p>This method would return {@code String.class} for the {@code bar} field and\n * {@code listParameterizedType} for the {@code red} field.\n *\n * @return the specific type declared for this field\n */\npublic Type getDeclaredType() {\n  if (genericType == null) {\n    genericType = field.getGenericType();\n  }\n  return genericType;\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -2.1444993989458703,
      "mean_entropy": -0.014296662659639135
    },
    {
      "patch": "\npublic Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -3.0631913379865,
      "mean_entropy": -0.09282397993898485
    },
    {
      "patch": "\n  /**\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   *\n   * Type listParameterizedType = new TypeToken<List<String>>() {}.getType();\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code listParameterizedType} for the {@code red} field.\n   *\n   * @return the specific type declared for this field\n   */\n  public Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n  }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -1.1114768368848005,
      "mean_entropy": -0.006615933552885717
    },
    {
      "patch": "\n  public Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n  }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -3.3621197620159493,
      "mean_entropy": -0.09606056462902712
    },
    {
      "patch": "\n  /**\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   *\n   * Type listParameterizedType = new TypeToken<List<String>>() {}.getType();\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code listParameterizedType} for the {@code red} field.\n   *\n   * @return the specific type declared for this field\n   */\n  public Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n  }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -1.1114768368848005,
      "mean_entropy": -0.006615933552885717
    },
    {
      "patch": "\n  /**\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   *\n   * Type listParameterizedType = new TypeToken<List<String>>() {}.getType();\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code listParameterizedType} for the {@code red} field.\n   *\n   * @return the specific type declared for this field\n   */\n  public Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n  }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -1.1114768368848005,
      "mean_entropy": -0.006615933552885717
    },
    {
      "patch": "\n  /**\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   *\n   * Type listParmeterizedType = new TypeToken<List<String>>() {}.getType();\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code listParameterizedType} for the {@code red} field.\n   *\n   * @return the specific type declared for this field\n   */\n  public Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n  }\n\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -3.0574328098010994,
      "mean_entropy": -0.017879724033924557
    },
    {
      "patch": "\n  /**\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   *\n   * Type listParameterizedType = new TypeToken<List<String>>() {}.getType();\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code listParameterizedType} for the {@code red} field.\n   *\n   * @return the specific type declared for this field\n   */\n  public Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n  }\n\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -2.9812912754218006,
      "mean_entropy": -0.01753700750248118
    },
    {
      "patch": "\npublic Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n  }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -4.2685901784565,
      "mean_entropy": -0.12554676995460293
    },
    {
      "patch": "\n/**\n * <p>For example, assume the following class definition:\n * <pre class=\"code\">\n * public class Foo {\n *   private String bar;\n *   private List&lt;String&gt; red;\n * }\n *\n * Type listParameterizedType = new TypeToken<List<String>>() {}.getType();\n * </pre>\n *\n * <p>This method would return {@code String.class} for the {@code bar} field and\n * {@code listParameterizedType} for the {@code red} field.\n *\n * @return the specific type declared for this field\n */\npublic Type getDeclaredType() {\n  if (genericType == null) {\n    genericType = field.getGenericType();\n  }\n  return genericType;\n}\n\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -3.7724016738224386,
      "mean_entropy": -0.024818432064621306
    },
    {
      "patch": "\n/**\n * <p>For example, assume the following class definition:\n * <pre class=\"code\">\n * public class Foo {\n *   private String bar;\n *   private List&lt;String&gt; red;\n * }\n *\n * Type listParameterizedType = new TypeToken<List<String>>() {}.getType();\n * </pre>\n *\n * <p>This method would return {@code String.class} for the {@code bar} field and\n * {@code listParameterizedType} for the {@code red} field.\n *\n * @return the specific type declared for this field\n */\npublic Type getDeclaredType() {\n  if (genericType == null) {\n    genericType = field.getGenericType();\n  }\n  return genericType;\n}\n\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -3.7724016738224386,
      "mean_entropy": -0.024818432064621306
    },
    {
      "patch": "\n/**\n * <p>For example, assume the following class definition:\n * <pre class=\"code\">\n * public class Foo {\n *   private String bar;\n *   private List&lt;String&gt; red;\n * }\n *\n * Type listParmeterizedType = new TypeToken<List<String>>() {}.getType();\n * </pre>\n *\n * <p>This method would return {@code String.class} for the {@code bar} field and\n * {@code listParameterizedType} for the {@code red} field.\n *\n * @return the specific type declared for this field\n */\npublic Type getDeclaredType() {\n  if (genericType == null) {\n    genericType = field.getGenericType();\n  }\n  return genericType;\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -2.0406396655197696,
      "mean_entropy": -0.013514169970329601
    },
    {
      "patch": "\n  /**\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   *\n   * Type listParmeterizedType = new TypeToken<List<String>>() {}.getType();\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code listParameterizedType} for the {@code red} field.\n   *\n   * @return the specific type declared for this field\n   */\n  public Type getDeclaredType() {\n    if (genericType == null) {\n      genericType = field.getGenericType();\n    }\n    return genericType;\n  }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.functional.TypeVariableTest::testSingle\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 35,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.functional.TypeVariableTest::testSingle",
        [
          "com.google.gson.functional.TypeVariableTest::testSingle"
        ]
      ],
      "sum_entropy": -1.97376266258844,
      "mean_entropy": -0.011679069009399053
    }
  ],
  "Gson_13": [
    {
      "patch": "\n  /**\n   * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n   * special double values (NaN, Infinity, -Infinity). However,\n   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n   * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n   * values. Moreover, most JavaScript engines will accept these special values in JSON without\n   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n   * though JSON specification disallows them.\n   *\n   * <p>Gson always accepts these special values during deserialization. However, it outputs\n   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n   * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n   * default behavior when you know that the JSON receiver will be able to handle these special\n   * values.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n  public GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n  }\n\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -2.3978353337237697,
      "mean_entropy": -0.006605606979955289
    },
    {
      "patch": "\n/**\n* Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n* special double values (NaN, Infinity, -Infinity). However,\n* <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n* specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n* values. Moreover, most JavaScript engines will accept these special values in JSON without\n* problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n* though JSON specification disallows them.\n*\n* <p>Gson always accepts these special values during deserialization. However, it outputs\n* strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n* {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n* {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n* will throw an {@link IllegalArgumentException}. This method provides a way to override the\n* default behavior when you know that the JSON receiver will be able to handle these special\n* values.\n*\n* @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n* @since 1.3\n*/\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n  this.serializeSpecialFloatingPointValues = true;\n  return this;\n}\n\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -4.802411258868966,
      "mean_entropy": -0.014083317474689048
    },
    {
      "patch": "\n/**\n * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n * special double values (NaN, Infinity, -Infinity). However,\n * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n * values. Moreover, most JavaScript engines will accept these special values in JSON without\n * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n * though JSON specification disallows them.\n *\n * <p>Gson always accepts these special values during deserialization. However, it outputs\n * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n * default behavior when you know that the JSON receiver will be able to handle these special\n * values.\n *\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n * @since 1.3\n */\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n  this.serializeSpecialFloatingPointValues = true;\n  return this;\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.46308143923422,
      "mean_entropy": -0.004315874452018348
    },
    {
      "patch": "\n/**\n * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n * special double values (NaN, Infinity, -Infinity). However,\n * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n * values. Moreover, most JavaScript engines will accept these special values in JSON without\n * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n * though JSON specification disallows them.\n *\n * <p>Gson always accepts these special values during deserialization. However, it outputs\n * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n * default behavior when you know that the JSON receiver will be able to handle these special\n * values.\n *\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n * @since 1.3\n */\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n  this.serializeSpecialFloatingPointValues = true;\n  return this;\n}\n\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -3.05331297030222,
      "mean_entropy": -0.008953996980358416
    },
    {
      "patch": "\n  /**\n   * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n   * special double values (NaN, Infinity, -Infinity). However,\n   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n   * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n   * values. Moreover, most JavaScript engines will accept these special values in JSON without\n   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n   * though JSON specification disallows them.\n   *\n   * <p>Gson always accepts these special values during deserialization. However, it outputs\n   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n   * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n   * default behavior when you know that the JSON receiver will be able to handle these special\n   * values.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n  public GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.78341720293377,
      "mean_entropy": -0.0021701307560492247
    },
    {
      "patch": "\n/**\n * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n * special double values (NaN, Infinity, -Infinity). However,\n * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n * values. Moreover, most JavaScript engines will accept these special values in JSON without\n * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n * though JSON specification disallows them.\n *\n * <p>Gson always accepts these special values during deserialization. However, it outputs\n * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n * default behavior when you know that the JSON receiver will be able to handle these special\n * values.\n *\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n * @since 1.3\n */\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n  this.serializeSpecialFloatingPointValues = true;\n  return this;\n}\n\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -3.05331297030222,
      "mean_entropy": -0.008953996980358416
    },
    {
      "patch": "\n/**\n * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n * special double values (NaN, Infinity, -Infinity). However,\n * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n * values. Moreover, most JavaScript engines will accept these special values in JSON without\n * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n * though JSON specification disallows them.\n *\n * <p>Gson always accepts these special values during deserialization. However, it outputs\n * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n * default behavior when you know that the JSON receiver will be able to handle these special\n * values.\n *\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n * @since 1.3\n */\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n  this.serializeSpecialFloatingPointValues = true;\n  return this;\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.46308143923422,
      "mean_entropy": -0.004315874452018348
    },
    {
      "patch": "\n/**\n * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n * special double values (NaN, Infinity, -Infinity). However,\n * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n * values. Moreover, most JavaScript engines will accept these special values in JSON without\n * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n * though JSON specification disallows them.\n *\n * <p>Gson always accepts these special values during deserialization. However, it outputs\n * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n * default behavior when you know that the JSON receiver will be able to handle these special\n * values.\n *\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n * @since 1.3\n */\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n  this.serializeSpecialFloatingPointValues = true;\n  return this;\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.46308143923422,
      "mean_entropy": -0.004315874452018348
    },
    {
      "patch": "\n  /**\n   * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n   * special double values (NaN, Infinity, -Infinity). However,\n   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n   * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n   * values. Moreover, most JavaScript engines will accept these special values in JSON without\n   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n   * though JSON specification disallows them.\n   *\n   * <p>Gson always accepts these special values during deserialization. However, it outputs\n   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n   * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n   * default behavior when you know that the JSON receiver will be able to handle these special\n   * values.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n  public GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n  }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.78341720293377,
      "mean_entropy": -0.0021701307560492247
    },
    {
      "patch": "\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -2.6282988143591,
      "mean_entropy": -0.10108841593688847
    },
    {
      "patch": "\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -2.6282988143591,
      "mean_entropy": -0.10108841593688847
    },
    {
      "patch": "\n/**\n * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n * special double values (NaN, Infinity, -Infinity). However,\n * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n * values. Moreover, most JavaScript engines will accept these special values in JSON without\n * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n * though JSON specification disallows them.\n *\n * <p>Gson always accepts these special values during deserialization. However, it outputs\n * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n * default behavior when you know that the JSON receiver will be able to handle these special\n * values.\n *\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n * @since 1.3\n */\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n  this.serializeSpecialFloatingPointValues = true;\n  return this;\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.46308143923422,
      "mean_entropy": -0.004315874452018348
    },
    {
      "patch": "\n/**\n * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n * special double values (NaN, Infinity, -Infinity). However,\n * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n * values. Moreover, most JavaScript engines will accept these special values in JSON without\n * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n * though JSON specification disallows them.\n *\n * <p>Gson always accepts these special values during deserialization. However, it outputs\n * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n * default behavior when you know that the JSON receiver will be able to handle these special\n * values.\n *\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n * @since 1.3\n */\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n  this.serializeSpecialFloatingPointValues = true;\n  return this;\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.46308143923422,
      "mean_entropy": -0.004315874452018348
    },
    {
      "patch": "\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -2.6282988143591,
      "mean_entropy": -0.10108841593688847
    },
    {
      "patch": "\n  /**\n   * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n   * special double values (NaN, Infinity, -Infinity). However,\n   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n   * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n   * values. Moreover, most JavaScript engines will accept these special values in JSON without\n   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n   * though JSON specification disallows them.\n   *\n   * <p>Gson always accepts these special values during deserialization. However, it outputs\n   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n   * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n   * default behavior when you know that the JSON receiver will be able to handle these special\n   * values.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n  public GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n  }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.78341720293377,
      "mean_entropy": -0.0021701307560492247
    },
    {
      "patch": "\n  /**\n   * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n   * special double values (NaN, Infinity, -Infinity). However,\n   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n   * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n   * values. Moreover, most JavaScript engines will accept these special values in JSON without\n   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n   * though JSON specification disallows them.\n   *\n   * <p>Gson always accepts these special values during deserialization. However, it outputs\n   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n   * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n   * default behavior when you know that the JSON receiver will be able to handle these special\n   * values.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n  public GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n  }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.78341720293377,
      "mean_entropy": -0.0021701307560492247
    },
    {
      "patch": "\n/**\n* Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n* special double values (NaN, Infinity, -Infinity). However,\n* <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n* specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n* values. Moreover, most JavaScript engines will accept these special values in JSON without\n* problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n* though JSON specification disallows them.\n*\n* <p>Gson always accepts these special values during deserialization. However, it outputs\n* strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n* {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n* {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n* will throw an {@link IllegalArgumentException}. This method provides a way to override the\n* default behavior when you know that the JSON receiver will be able to handle these special\n* values.\n*\n* @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n* @since 1.3\n*/\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n}\n\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -6.45896003687615,
      "mean_entropy": -0.018941231779695457
    },
    {
      "patch": "\n  /**\n   * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n   * special double values (NaN, Infinity, -Infinity). However,\n   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n   * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n   * values. Moreover, most JavaScript engines will accept these special values in JSON without\n   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n   * though JSON specification disallows them.\n   *\n   * <p>Gson always accepts these special values during deserialization. However, it outputs\n   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n   * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n   * default behavior when you know that the JSON receiver will be able to handle these special\n   * values.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n  public GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n  }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.7727261148231481,
      "mean_entropy": -0.002140515553526726
    },
    {
      "patch": "\n/**\n * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n * special double values (NaN, Infinity, -Infinity). However,\n * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n * values. Moreover, most JavaScript engines will accept these special values in JSON without\n * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n * though JSON specification disallows them.\n *\n * <p>Gson always accepts these special values during deserialization. However, it outputs\n * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n * default behavior when you know that the JSON receiver will be able to handle these special\n * values.\n *\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n * @since 1.3\n */\npublic GsonBuilder serializeSpecialFloatingPointValues() {\n  this.serializeSpecialFloatingPointValues = true;\n  return this;\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.4565832257589508,
      "mean_entropy": -0.00429670568070487
    },
    {
      "patch": "\n  /**\n   * Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n   * special double values (NaN, Infinity, -Infinity). However,\n   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n   * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n   * values. Moreover, most JavaScript engines will accept these special values in JSON without\n   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n   * though JSON specification disallows them.\n   *\n   * <p>Gson always accepts these special values during deserialization. However, it outputs\n   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n   * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n   * default behavior when you know that the JSON receiver will be able to handle these special\n   * values.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n  public GsonBuilder serializeSpecialFloatingPointValues() {\n    this.serializeSpecialFloatingPointValues = true;\n    return this;\n  }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.7727261148231481,
      "mean_entropy": -0.002140515553526726
    },
    {
      "patch": "\n/**\n* Configure this parser to be liberal in what it accepts. By default,\n* this parser is strict and only accepts JSON as specified by <a\n* href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n* parser to lenient causes it to ignore the following syntax errors:\n*\n* <ul>\n*   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n*       prefix</a>, <code>\")]}'\\n\"</code>.\n*   <li>Streams that include multiple top-level values. With strict parsing,\n*       each stream must contain exactly one top-level value.\n*   <li>Top-level values of any type. With strict parsing, the top-level\n*       value must be an object or an array.\n*   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n*       Double#isInfinite() infinities}.\n*   <li>End of line comments starting with {@code //} or {@code #} and\n*       ending with a newline character.\n*   <li>C-style comments starting with {@code /*} and ending with\n*       {@code *}{@code /}. Such comments may not be nested.\n*   <li>Names that are unquoted or {@code 'single quoted'}.\n*   <li>Strings that are unquoted or {@code 'single quoted'}.\n*   <li>Array elements separated by {@code ;} instead of {@code ,}.\n*   <li>Unnecessary array separators. These are interpreted as if null\n*       was the omitted value.\n*   <li>Names and values separated by {@code =} or {@code =>} instead of\n*       {@code :}.\n*   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n* </ul>\n*/\npublic final void setLenient(boolean lenient) {\n  this.lenient = lenient;\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -3.9998160161273297,
      "mean_entropy": -0.009433528339922947
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.946854271065269,
      "mean_entropy": -0.0042600749913900855
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.6524297601892689,
      "mean_entropy": -0.001433911560855536
    },
    {
      "patch": "\n/**\n * Configure this parser to be liberal in what it accepts. By default,\n * this parser is strict and only accepts JSON as specified by <a\n * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n * parser to lenient causes it to ignore the following syntax errors:\n *\n * <ul>\n *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n *       prefix</a>, <code>\")]}'\\n\"</code>.\n *   <li>Streams that include multiple top-level values. With strict parsing,\n *       each stream must contain exactly one top-level value.\n *   <li>Top-level values of any type. With strict parsing, the top-level\n *       value must be an object or an array.\n *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n *       Double#isInfinite() infinities}.\n *   <li>End of line comments starting with {@code //} or {@code #} and\n *       ending with a newline character.\n *   <li>C-style comments starting with {@code /*} and ending with\n *       {@code *}{@code /}. Such comments may not be nested.\n *   <li>Names that are unquoted or {@code 'single quoted'}.\n *   <li>Strings that are unquoted or {@code 'single quoted'}.\n *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n *   <li>Unnecessary array separators. These are interpreted as if null\n *       was the omitted value.\n *   <li>Names and values separated by {@code =} or {@code =>} instead of\n *       {@code :}.\n *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n * </ul>\n */\npublic final void setLenient(boolean lenient) {\n  this.lenient = lenient;\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.5802926137867794,
      "mean_entropy": -0.0037271052211952345
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.6524297601892689,
      "mean_entropy": -0.001433911560855536
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.946854271065269,
      "mean_entropy": -0.0042600749913900855
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.6524297601892689,
      "mean_entropy": -0.001433911560855536
    },
    {
      "patch": "\n/**\n * Configure this parser to be liberal in what it accepts. By default,\n * this parser is strict and only accepts JSON as specified by <a\n * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n * parser to lenient causes it to ignore the following syntax errors:\n *\n * <ul>\n *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n *       prefix</a>, <code>\")]}'\\n\"</code>.\n *   <li>Streams that include multiple top-level values. With strict parsing,\n *       each stream must contain exactly one top-level value.\n *   <li>Top-level values of any type. With strict parsing, the top-level\n *       value must be an object or an array.\n *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n *       Double#isInfinite() infinities}.\n *   <li>End of line comments starting with {@code //} or {@code #} and\n *       ending with a newline character.\n *   <li>C-style comments starting with {@code /*} and ending with\n *       {@code *}{@code /}. Such comments may not be nested.\n *   <li>Names that are unquoted or {@code 'single quoted'}.\n *   <li>Strings that are unquoted or {@code 'single quoted'}.\n *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n *   <li>Unnecessary array separators. These are interpreted as if null\n *       was the omitted value.\n *   <li>Names and values separated by {@code =} or {@code =>} instead of\n *       {@code :}.\n *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n * </ul>\n */\npublic final void setLenient(boolean lenient) {\n  this.lenient = lenient;\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.5802926137867794,
      "mean_entropy": -0.0037271052211952345
    },
    {
      "patch": "\n/**\n * Configure this parser to be liberal in what it accepts. By default,\n * this parser is strict and only accepts JSON as specified by <a\n * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n * parser to lenient causes it to ignore the following syntax errors:\n *\n * <ul>\n *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n *       prefix</a>, <code>\")]}'\\n\"</code>.\n *   <li>Streams that include multiple top-level values. With strict parsing,\n *       each stream must contain exactly one top-level value.\n *   <li>Top-level values of any type. With strict parsing, the top-level\n *       value must be an object or an array.\n *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n *       Double#isInfinite() infinities}.\n *   <li>End of line comments starting with {@code //} or {@code #} and\n *       ending with a newline character.\n *   <li>C-style comments starting with {@code /*} and ending with\n *       {@code *}{@code /}. Such comments may not be nested.\n *   <li>Names that are unquoted or {@code 'single quoted'}.\n *   <li>Strings that are unquoted or {@code 'single quoted'}.\n *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n *   <li>Unnecessary array separators. These are interpreted as if null\n *       was the omitted value.\n *   <li>Names and values separated by {@code =} or {@code =>} instead of\n *       {@code :}.\n *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n * </ul>\n */\npublic final void setLenient(boolean lenient) {\n  this.lenient = lenient;\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.5802926137867794,
      "mean_entropy": -0.0037271052211952345
    },
    {
      "patch": "\n/**\n * Configure this parser to be liberal in what it accepts. By default,\n * this parser is strict and only accepts JSON as specified by <a\n * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n * parser to lenient causes it to ignore the following syntax errors:\n *\n * <ul>\n *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n *       prefix</a>, <code>\")]}'\\n\"</code>.\n *   <li>Streams that include multiple top-level values. With strict parsing,\n *       each stream must contain exactly one top-level value.\n *   <li>Top-level values of any type. With strict parsing, the top-level\n *       value must be an object or an array.\n *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n *       Double#isInfinite() infinities}.\n *   <li>End of line comments starting with {@code //} or {@code #} and\n *       ending with a newline character.\n *   <li>C-style comments starting with {@code /*} and ending with\n *       {@code *}{@code /}. Such comments may not be nested.\n *   <li>Names that are unquoted or {@code 'single quoted'}.\n *   <li>Strings that are unquoted or {@code 'single quoted'}.\n *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n *   <li>Unnecessary array separators. These are interpreted as if null\n *       was the omitted value.\n *   <li>Names and values separated by {@code =} or {@code =>} instead of\n *       {@code :}.\n *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n * </ul>\n */\npublic final void setLenient(boolean lenient) {\n  this.lenient = lenient;\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.5802926137867794,
      "mean_entropy": -0.0037271052211952345
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.6524297601892689,
      "mean_entropy": -0.001433911560855536
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.946854271065269,
      "mean_entropy": -0.0042600749913900855
    },
    {
      "patch": "\n/**\n * Configure this parser to be liberal in what it accepts. By default,\n * this parser is strict and only accepts JSON as specified by <a\n * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n * parser to lenient causes it to ignore the following syntax errors:\n *\n * <ul>\n *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n *       prefix</a>, <code>\")]}'\\n\"</code>.\n *   <li>Streams that include multiple top-level values. With strict parsing,\n *       each stream must contain exactly one top-level value.\n *   <li>Top-level values of any type. With strict parsing, the top-level\n *       value must be an object or an array.\n *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n *       Double#isInfinite() infinities}.\n *   <li>End of line comments starting with {@code //} or {@code #} and\n *       ending with a newline character.\n *   <li>C-style comments starting with {@code /*} and ending with\n *       {@code *}{@code /}. Such comments may not be nested.\n *   <li>Names that are unquoted or {@code 'single quoted'}.\n *   <li>Strings that are unquoted or {@code 'single quoted'}.\n *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n *   <li>Unnecessary array separators. These are interpreted as if null\n *       was the omitted value.\n *   <li>Names and values separated by {@code =} or {@code =>} instead of\n *       {@code :}.\n *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n * </ul>\n */\npublic final void setLenient(boolean lenient) {\n  this.lenient = lenient;\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.5802926137867794,
      "mean_entropy": -0.0037271052211952345
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.6524297601892689,
      "mean_entropy": -0.001433911560855536
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.6524297601892689,
      "mean_entropy": -0.001433911560855536
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.6524297601892689,
      "mean_entropy": -0.001433911560855536
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -2.072307177306528,
      "mean_entropy": -0.0045345890094234745
    },
    {
      "patch": "\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -0.6829527528265279,
      "mean_entropy": -0.0015009950611572043
    },
    {
      "patch": "\n/**\n * Configure this parser to be liberal in what it accepts. By default,\n * this parser is strict and only accepts JSON as specified by <a\n * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n * parser to lenient causes it to ignore the following syntax errors:\n *\n * <ul>\n *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n *       prefix</a>, <code>\")]}'\\n\"</code>.\n *   <li>Streams that include multiple top-level values. With strict parsing,\n *       each stream must contain exactly one top-level value.\n *   <li>Top-level values of any type. With strict parsing, the top-level\n *       value must be an object or an array.\n *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n *       Double#isInfinite() infinities}.\n *   <li>End of line comments starting with {@code //} or {@code #} and\n *       ending with a newline character.\n *   <li>C-style comments starting with {@code /*} and ending with\n *       {@code *}{@code /}. Such comments may not be nested.\n *   <li>Names that are unquoted or {@code 'single quoted'}.\n *   <li>Strings that are unquoted or {@code 'single quoted'}.\n *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n *   <li>Unnecessary array separators. These are interpreted as if null\n *       was the omitted value.\n *   <li>Names and values separated by {@code =} or {@code =>} instead of\n *       {@code :}.\n *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n * </ul>\n */\npublic final void setLenient(boolean lenient) {\n  this.lenient = lenient;\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -1.5905955154028588,
      "mean_entropy": -0.003751404517459573
    },
    {
      "patch": "\n/**\n * Configure this parser to be liberal in what it accepts. By default,\n * this parser is strict and only accepts JSON as specified by <a\n * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n * parser to lenient causes it to ignore the following syntax errors:\n *\n * <ul>\n *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n *       prefix</a>, <code>\")]}'\\n\"</code>.\n *   <li>Streams that include multiple top-level values. With strict parsing,\n *       each stream must contain exactly one top-level value.\n *   <li>Top-level values of any type. With strict parsing, the top-level\n *       value must be an object or an array.\n *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n *       Double#isInfinite() infinities}.\n *   <li>End of line comments starting with {@code //} or {@code #} and\n *       ending with a newline character.\n *   <li>C-style comments starting with {@code /*} and ending with\n *       {@code *}{@code /}. Such comments may not be nested.\n *   <li>Names that are unquoted or {@code 'single quoted'}.\n *   <li>Strings that are unquoted or {@code 'single quoted'}.\n *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n *   <li>Unnecessary array separators. These are interpreted as if null\n *       was the omitted value.\n *   <li>Names and values separated by {@code =} or {@code =>} instead of\n *       {@code :}.\n *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n * </ul>\n */\npublic final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n}\n\n// Bug fix suggested by Michele\n// Change the condition inside the setLenient method\n// value!=0 || false==negative\n// This change aims to differentiate between 0 and -0 at the lexical level\n// and treat -0 as -0.0 to enable roundtripping any valid number value found in the source\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonReaderTest::testNegativeZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 75,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonReaderTest::testNegativeZero",
        [
          "com.google.gson.stream.JsonReaderTest::testNegativeZero"
        ]
      ],
      "sum_entropy": -41.189818862745874,
      "mean_entropy": -0.08371914402997128
    }
  ],
  "Gson_15": [
    {
      "patch": "\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    if (!lenient && (value instanceof Double)) {\n      double doubleValue = value.doubleValue();\n      if (Double.isNaN(doubleValue) || Double.isInfinite(doubleValue)) {\n        throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n      }\n    }\n\n    beforeValue();\n    out.append(value.toString());\n    return this;\n  }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -4.429102009599081,
      "mean_entropy": -0.026521568919754976
    },
    {
      "patch": "\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -2.187198343793693,
      "mean_entropy": -0.013755964426375429
    },
    {
      "patch": "\n/**\n * Encodes {@code value}.\n *\n * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n *     {@link Double#isInfinite() infinities}.\n * @return this writer.\n */\npublic JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (lenient && (value instanceof Double) && (Double.isNaN((Double) value) || Double.isInfinite((Double) value))) {\n      beforeValue();\n      out.append(string);\n    } else if (!lenient && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    } else {\n      beforeValue();\n      out.append(string);\n    }\n    return this;\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -11.348946440075899,
      "mean_entropy": -0.05819972533372256
    },
    {
      "patch": "\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (Double.isNaN(value.doubleValue()) || Double.isInfinite(value.doubleValue()))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -4.232631384476782,
      "mean_entropy": -0.02678880623086571
    },
    {
      "patch": "\n/**\n * Encodes {@code value}.\n *\n * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n *     {@link Double#isInfinite() infinities}.\n * @return this writer.\n */\npublic JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n        return nullValue();\n    }\n\n    writeDeferredName();\n    if (!lenient && (value instanceof Double || value instanceof Float)) {\n        double doubleValue = value.doubleValue();\n        if (Double.isNaN(doubleValue) || Double.isInfinite(doubleValue)) {\n            throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n        }\n    }\n\n    beforeValue();\n    out.append(value.toString());\n    return this;\n}\n\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -8.616561464137583,
      "mean_entropy": -0.052540008927668184
    },
    {
      "patch": "\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -4.466073173210693,
      "mean_entropy": -0.02844632594401715
    },
    {
      "patch": "\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -2.187198343793693,
      "mean_entropy": -0.013755964426375429
    },
    {
      "patch": "\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient && (value instanceof Double) && (Double.isNaN(value.doubleValue()) || Double.isInfinite(value.doubleValue()))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -5.155147709578623,
      "mean_entropy": -0.031821899441843354
    },
    {
      "patch": "\n/**\n * Encodes {@code value}.\n *\n * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n *     {@link Double#isInfinite() infinities}.\n * @return this writer.\n */\npublic JsonWriter value(Number value) throws IOException {\n  if (value == null) {\n    return nullValue();\n  }\n\n  writeDeferredName();\n  String string = value.toString();\n  if (!lenient\n      && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(string);\n  return this;\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -4.308927927655445,
      "mean_entropy": -0.02872618618436963
    },
    {
      "patch": "\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (lenient && (value instanceof Double)) {\n      double doubleValue = ((Double) value).doubleValue();\n      if (Double.isNaN(doubleValue) || Double.isInfinite(doubleValue)) {\n        beforeValue();\n        out.append(string);\n        return this;\n      }\n    } else if (!lenient && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -9.155870185596168,
      "mean_entropy": -0.042388287896278555
    },
    {
      "patch": "\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    if (!lenient && (value instanceof Double) && (Double.isNaN(value.doubleValue()) || Double.isInfinite(value.doubleValue()))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(value.toString());\n    return this;\n  }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -6.061717262155139,
      "mean_entropy": -0.03885716193689192
    },
    {
      "patch": "\n/**\n * Encodes {@code value}.\n *\n * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n *     {@link Double#isInfinite() infinities}.\n * @return this writer.\n */\npublic JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n        return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -6.0089633411854075,
      "mean_entropy": -0.04005975560790272
    },
    {
      "patch": "\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -2.30271357616695,
      "mean_entropy": -0.014482475321804716
    },
    {
      "patch": "\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (Double.isNaN(value.doubleValue()) || Double.isInfinite(value.doubleValue()))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -3.55136043958727,
      "mean_entropy": -0.022476964807514366
    },
    {
      "patch": "\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 76,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient",
        [
          "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient"
        ]
      ],
      "sum_entropy": -3.50935094389695,
      "mean_entropy": -0.021797210831658073
    }
  ],
  "Gson_5": [
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n/**\n * Constructs a Gson object with default configuration. The default configuration has the\n * following settings:\n * <ul>\n *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n *   means that all the unneeded white-space is removed. You can change this behavior with\n *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n *   to change the default representation, you can do so by registering a type adapter through\n *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n *   ignores the millisecond portion of the date during serialization. You can change\n *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n *   {@link GsonBuilder#setDateFormat(String)}. </li>\n *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n *   consideration for serialization and deserialization. You can change this behavior through\n *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n * </ul>\n */\npublic Gson() {\n  this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n      Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n      DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n      DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n      LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -2.8577013407910394,
      "mean_entropy": -0.004141596146073971
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n/**\n * Constructs a Gson object with default configuration. The default configuration has the\n * following settings:\n * <ul>\n *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n *   means that all the unneeded white-space is removed. You can change this behavior with\n *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n *   to change the default representation, you can do so by registering a type adapter through\n *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n *   ignores the millisecond portion of the date during serialization. You can change\n *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n *   {@link GsonBuilder#setDateFormat(String)}. </li>\n *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n *   consideration for serialization and deserialization. You can change this behavior through\n *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n * </ul>\n */\npublic Gson() {\n  this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n      Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n      DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n      DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n      LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -2.8577013407910394,
      "mean_entropy": -0.004141596146073971
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(new Excluder(), FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -3.0337132365534982,
      "mean_entropy": -0.004184432050418618
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.3326660273485482,
      "mean_entropy": -0.0018356281368437303
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.2501860953055377,
      "mean_entropy": -0.0017220194150214018
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.2501860953055377,
      "mean_entropy": -0.0017220194150214018
    },
    {
      "patch": "\n  /**\n   * Constructs a Gson object with default configuration. The default configuration has the\n   * following settings:\n   * <ul>\n   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n   *   means that all the unneeded white-space is removed. You can change this behavior with\n   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n   *   to change the default representation, you can do so by registering a type adapter through\n   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n   *   ignores the millisecond portion of the date during serialization. You can change\n   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n   *   consideration for serialization and deserialization. You can change this behavior through\n   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n   * </ul>\n   */\n  public Gson() {\n    this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n  }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601",
        [
          "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601"
        ]
      ],
      "sum_entropy": -1.2501860953055377,
      "mean_entropy": -0.0017220194150214018
    }
  ],
  "JacksonCore_20": [
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!FORMAT_NAME_JSON.equals(format)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -2.0350983974784365,
      "mean_entropy": -0.008809949772633925
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.80475048644783,
      "mean_entropy": -0.003468752096757888
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.80475048644783,
      "mean_entropy": -0.003468752096757888
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.80475048644783,
      "mean_entropy": -0.003468752096757888
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!FORMAT_NAME_JSON.equals(format)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -2.0350983974784365,
      "mean_entropy": -0.008809949772633925
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.80475048644783,
      "mean_entropy": -0.003468752096757888
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.80475048644783,
      "mean_entropy": -0.003468752096757888
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!FORMAT_NAME_JSON.equals(format)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -2.0350983974784365,
      "mean_entropy": -0.008809949772633925
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.80475048644783,
      "mean_entropy": -0.003468752096757888
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.80475048644783,
      "mean_entropy": -0.003468752096757888
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!FORMAT_NAME_JSON.equals(format)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -2.0350983974784365,
      "mean_entropy": -0.008809949772633925
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // Use .equals() to compare strings\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -10.473293208728494,
      "mean_entropy": -0.06713649492774676
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.80475048644783,
      "mean_entropy": -0.003468752096757888
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.80475048644783,
      "mean_entropy": -0.003468752096757888
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.80475048644783,
      "mean_entropy": -0.003468752096757888
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.7961263843254397,
      "mean_entropy": -0.0034315792427820676
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!format.equals(FORMAT_NAME_JSON)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -0.7961263843254397,
      "mean_entropy": -0.0034315792427820676
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException\n    {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        //   non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!FORMAT_NAME_JSON.equals(format)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -1.935638291642789,
      "mean_entropy": -0.008379386543908178
    },
    {
      "patch": "\n    /**\n     * @since 2.8\n     */\n    protected JsonParser _createParser(DataInput input, IOContext ctxt) throws IOException {\n        // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n        // non-JSON input. So, bit unclean but...\n        String format = getFormatName();\n        if (!FORMAT_NAME_JSON.equals(format)) { // NOTE: only ensure override; full equality NOT needed\n            throw new UnsupportedOperationException(String.format(\n                    \"InputData source not (yet?) support for this format (%s)\", format));\n        }\n        // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n        // at least handle possible UTF-8 BOM\n        int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(input);\n        ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n        return new UTF8DataInputJsonParser(ctxt, _parserFeatures, input,\n                _objectCodec, can, firstByte);\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 79,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
        [
          "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject",
          "com.fasterxml.jackson.core.main.TestGeneratorMisc::testAsEmbedded"
        ]
      ],
      "sum_entropy": -5.001730059691888,
      "mean_entropy": -0.02193741254250828
    }
  ],
  "JacksonDatabind_108": [
    {
      "patch": "\n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     * Returns {@link JsonNode} that represents the root of the resulting tree, if there\n     * was content to read, or \"missing node\" (instance of {@JsonNode} for which\n     * {@link JsonNode#isMissingNode()} returns true, and behaves otherwise similar to\n     * \"null node\") if no more content is accessible through passed-in input source.\n     *<p>\n     * NOTE! Behavior with end-of-input (no more content) differs between this\n     * {@code readTree} method, and {@link #readTree(JsonParser)} -- latter returns\n     * {@code null} for \"no content\" case.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(InputStream in) throws IOException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndCloseAsTree(in);\n        }\n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(in), false));\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 432,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader",
        [
          "com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader"
        ]
      ],
      "sum_entropy": -2.451818518859241,
      "mean_entropy": -0.008694391910848373
    },
    {
      "patch": "\n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     * Returns {@link JsonNode} that represents the root of the resulting tree, if there\n     * was content to read, or \"missing node\" (instance of {@JsonNode} for which\n     * {@link JsonNode#isMissingNode()} returns true, and behaves otherwise similar to\n     * \"null node\") if no more content is accessible through passed-in input source.\n     *<p>\n     * NOTE! Behavior with end-of-input (no more content) differs between this\n     * {@code readTree} method, and {@link #readTree(JsonParser)} -- latter returns\n     * {@code null} for \"no content\" case.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(InputStream in) throws IOException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndCloseAsTree(in);\n        }\n        JsonParser parser = _considerFilter(_parserFactory.createParser(in), false);\n        JsonNode node = _bindAndCloseAsTree(parser);\n        if (node.isMissingNode()) {\n            return node;\n        } else {\n            return null;\n        }\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 432,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader",
        [
          "com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader"
        ]
      ],
      "sum_entropy": -8.93018926186431,
      "mean_entropy": -0.02834980718052162
    },
    {
      "patch": "\n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     * Returns {@link JsonNode} that represents the root of the resulting tree, if there\n     * was content to read, or \"missing node\" (instance of {@JsonNode} for which\n     * {@link JsonNode#isMissingNode()} returns true, and behaves otherwise similar to\n     * \"null node\") if no more content is accessible through passed-in input source.\n     *<p>\n     * NOTE! Behavior with end-of-input (no more content) differs between this\n     * {@code readTree} method, and {@link #readTree(JsonParser)} -- latter returns\n     * {@code null} for \"no content\" case.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(InputStream in) throws IOException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndCloseAsTree(in);\n        }\n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(in), false));\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 432,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader",
        [
          "com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader"
        ]
      ],
      "sum_entropy": -2.451818518859241,
      "mean_entropy": -0.008694391910848373
    },
    {
      "patch": "\n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     * Returns {@link JsonNode} that represents the root of the resulting tree, if there\n     * was content to read, or \"missing node\" (instance of {@JsonNode} for which\n     * {@link JsonNode#isMissingNode()} returns true, and behaves otherwise similar to\n     * \"null node\") if no more content is accessible through passed-in input source.\n     *<p>\n     * NOTE! Behavior with end-of-input (no more content) differs between this\n     * {@code readTree} method, and {@link #readTree(JsonParser)} -- latter returns\n     * {@code null} for \"no content\" case.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(InputStream in) throws IOException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndCloseAsTree(in);\n        }\n        JsonParser parser = _considerFilter(_parserFactory.createParser(in), false);\n        return _bindAndCloseAsTree(parser);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 432,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader",
        [
          "com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader"
        ]
      ],
      "sum_entropy": -6.34073088074015,
      "mean_entropy": -0.021940245262076642
    }
  ],
  "JacksonDatabind_51": [
    {
      "patch": "\n    /**\n     * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n     * with the initial information based on standard settings for the type\n     * for which serializer is being built.\n     */\n    public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n            SettableBeanProperty idProp, ObjectIdResolver resolver)\n    {\n        return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 69,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom",
        [
          "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom"
        ]
      ],
      "sum_entropy": -0.99520244590438,
      "mean_entropy": -0.009214837462077593
    },
    {
      "patch": "\n    /**\n     * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n     * with the initial information based on standard settings for the type\n     * for which serializer is being built.\n     */\n    public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n            SettableBeanProperty idProp, ObjectIdResolver resolver)\n    {\n        return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 69,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom",
        [
          "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom"
        ]
      ],
      "sum_entropy": -0.99520244590438,
      "mean_entropy": -0.009214837462077593
    },
    {
      "patch": "\n/**\n * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n * with the initial information based on standard settings for the type\n * for which serializer is being built.\n */\npublic static ObjectIdReader construct(JavaType idType, PropertyName propName,\n        ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n        SettableBeanProperty idProp, ObjectIdResolver resolver)\n{\n    return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 69,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom",
        [
          "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom"
        ]
      ],
      "sum_entropy": -2.69523863081592,
      "mean_entropy": -0.0269523863081592
    },
    {
      "patch": "\n    /**\n     * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n     * with the initial information based on standard settings for the type\n     * for which serializer is being built.\n     */\n    public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n            SettableBeanProperty idProp, ObjectIdResolver resolver)\n    {\n        return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 69,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom",
        [
          "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom"
        ]
      ],
      "sum_entropy": -0.99520244590438,
      "mean_entropy": -0.009214837462077593
    },
    {
      "patch": "\n    /**\n     * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n     * with the initial information based on standard settings for the type\n     * for which serializer is being built.\n     */\n    public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n            SettableBeanProperty idProp, ObjectIdResolver resolver)\n    {\n        return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 69,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom",
        [
          "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom"
        ]
      ],
      "sum_entropy": -0.99520244590438,
      "mean_entropy": -0.009214837462077593
    },
    {
      "patch": "\n/**\n * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n * with the initial information based on standard settings for the type\n * for which serializer is being built.\n */\npublic static ObjectIdReader construct(JavaType idType, PropertyName propName,\n        ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n        SettableBeanProperty idProp, ObjectIdResolver resolver)\n{\n    return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 69,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom",
        [
          "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom"
        ]
      ],
      "sum_entropy": -2.69523863081592,
      "mean_entropy": -0.0269523863081592
    },
    {
      "patch": "\n    /**\n     * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n     * with the initial information based on standard settings for the type\n     * for which serializer is being built.\n     */\n    public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n            SettableBeanProperty idProp, ObjectIdResolver resolver)\n    {\n        return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 69,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom",
        [
          "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom"
        ]
      ],
      "sum_entropy": -0.99520244590438,
      "mean_entropy": -0.009214837462077593
    },
    {
      "patch": "\n    /**\n     * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n     * with the initial information based on standard settings for the type\n     * for which serializer is being built.\n     */\n    public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n            SettableBeanProperty idProp, ObjectIdResolver resolver)\n    {\n        return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 69,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom",
        [
          "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom"
        ]
      ],
      "sum_entropy": -0.99520244590438,
      "mean_entropy": -0.009214837462077593
    },
    {
      "patch": "\n    /**\n     * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n     * with the initial information based on standard settings for the type\n     * for which serializer is being built.\n     */\n    public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n            SettableBeanProperty idProp, ObjectIdResolver resolver)\n    {\n        return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 69,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom",
        [
          "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom"
        ]
      ],
      "sum_entropy": -0.99520244590438,
      "mean_entropy": -0.009214837462077593
    },
    {
      "patch": "\n    /**\n     * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n     * with the initial information based on standard settings for the type\n     * for which serializer is being built.\n     */\n    public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n            SettableBeanProperty idProp, ObjectIdResolver resolver)\n    {\n        return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 69,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom",
        [
          "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom"
        ]
      ],
      "sum_entropy": -0.99520244590438,
      "mean_entropy": -0.009214837462077593
    },
    {
      "patch": "\n    /**\n     * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n     * with the initial information based on standard settings for the type\n     * for which serializer is being built.\n     */\n    public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n            SettableBeanProperty idProp, ObjectIdResolver resolver)\n    {\n        return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 69,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom",
        [
          "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom"
        ]
      ],
      "sum_entropy": -0.99520244590438,
      "mean_entropy": -0.009214837462077593
    }
  ],
  "JacksonDatabind_58": [
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        \n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        \n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        \n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -8.64134983626166,
      "mean_entropy": -0.019118030611198364
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    if (Enum.class.isAssignableFrom(returnType)) {\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\" + factory + \") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n            }\n        }\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -9.199636471692237,
      "mean_entropy": -0.022061478349381863
    },
    {
      "patch": "\nprivate KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n        JavaType type)\n    throws JsonMappingException\n{\n    final DeserializationConfig config = ctxt.getConfig();\n    Class<?> enumClass = type.getRawClass();\n\n    BeanDescription beanDesc = config.introspect(type);\n    KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n    if (des != null) {\n        return des;\n    } else {\n        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (custom != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n        }\n        JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (valueDesForKey != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n        }\n    }\n    EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n        if (ai.hasCreatorAnnotation(factory)) {\n            int argCount = factory.getParameterCount();\n            if (argCount == 1) {\n                Class<?> returnType = factory.getRawReturnType();\n                if (returnType.isAssignableFrom(enumClass)) {\n                    if (factory.getRawParameterType(0) != String.class) {\n                        throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                    }\n                    if (config.canOverrideAccessModifiers()) {\n                        ClassUtil.checkAndFixAccess(factory.getMember(),\n                                ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                    }\n                    return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                }\n            }\n        }\n    }\n    return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -7.099083922254002,
      "mean_entropy": -0.017189065187055697
    },
    {
      "patch": "\nprivate KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n        JavaType type)\n    throws JsonMappingException\n{\n    final DeserializationConfig config = ctxt.getConfig();\n    Class<?> enumClass = type.getRawClass();\n\n    BeanDescription beanDesc = config.introspect(type);\n    // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n    KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n    if (des != null) {\n        return des;\n    } else {\n        // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (custom != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n        }\n        JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (valueDesForKey != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n        }\n    }\n    EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n    // May have @JsonCreator for static factory method:\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n        if (ai.hasCreatorAnnotation(factory)) {\n            int argCount = factory.getParameterCount();\n            if (argCount == 1) {\n                Class<?> returnType = factory.getRawReturnType();\n                // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                if (returnType.isAssignableFrom(enumClass)) {\n                    // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                    if (factory.getRawParameterType(0) != String.class) {\n                        throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                    }\n                    if (!config.canOverrideAccessModifiers()) { // Change from canOverrideAccess() to canOverrideAccessModifiers()\n                        ClassUtil.checkAndFixAccess(factory.getMember(),\n                                ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                    }\n                    return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                }\n            }\n            throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                    +enumClass.getName()+\")\");\n        }\n    }\n    // [JACKSON-749] Also, need to consider @JsonValue, if one found\n    return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n}\n\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -12.957381961940944,
      "mean_entropy": -0.0224176158511089
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (!config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(), false);\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -5.066606286813352,
      "mean_entropy": -0.00914549871265948
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -4.34654165493092,
      "mean_entropy": -0.008094118538046407
    },
    {
      "patch": "\nprivate KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type)\n        throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    Class<?> enumClass = type.getRawClass();\n\n    BeanDescription beanDesc = config.introspect(type);\n    // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n    KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n    if (des != null) {\n        return des;\n    } else {\n        // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (custom != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n        }\n        JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (valueDesForKey != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n        }\n    }\n    EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n    // May have @JsonCreator for static factory method:\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n        if (ai.hasCreatorAnnotation(factory)) {\n            int argCount = factory.getParameterCount();\n            if (argCount == 1) {\n                Class<?> returnType = factory.getRawReturnType();\n                // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                if (returnType.isAssignableFrom(enumClass)) {\n                    // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                    if (factory.getRawParameterType(0) != String.class) {\n                        throw new IllegalArgumentException(\"Parameter #0 type for factory method (\" + factory + \") not suitable, must be java.lang.String\");\n                    }\n                    if (config.canOverrideAccessModifiers()) {\n                        ClassUtil.checkAndFixAccess(factory.getMember(), ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                    }\n                    return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                }\n            }\n        }\n    }\n    // [JACKSON-749] Also, need to consider @JsonValue, if one found\n    return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n}\n\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -8.286058901384392,
      "mean_entropy": -0.015575298686812766
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (enumClass.isAssignableFrom(returnType)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\" + factory + \") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(), ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\" + factory + \") decorated with @JsonCreator (for Enum type \" + enumClass.getName() + \")\");\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -6.621550966498164,
      "mean_entropy": -0.011740338593081852
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                            +enumClass.getName()+\")\");\n                }\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -4.483956175382646,
      "mean_entropy": -0.007866589781373064
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (enumClass.isAssignableFrom(returnType)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -3.5093388584179683,
      "mean_entropy": -0.006200245332893937
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        if (!factory.getMember().isAccessible()) {\n                            factory.getMember().setAccessible(true);\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -6.6474564049534415,
      "mean_entropy": -0.011305197967607894
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n                                                         JavaType type) throws JsonMappingException {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\" + factory + \") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"Unsuitable method (\" + factory + \") decorated with @JsonCreator (for Enum type \"\n                            + enumClass.getName() + \")\");\n                }\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -9.63239075685116,
      "mean_entropy": -0.0168693358263593
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            // This block is changed to prevent the private access issue\n                            // Removed the method to check and fix access\n                            return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                        }\n                    }\n                    throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                            +enumClass.getName()+\")\");\n                }\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -37.41249487186876,
      "mean_entropy": -0.06621680508295355
    },
    {
      "patch": "\nprivate KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n        JavaType type)\n    throws JsonMappingException\n{\n    final DeserializationConfig config = ctxt.getConfig();\n    Class<?> enumClass = type.getRawClass();\n\n    BeanDescription beanDesc = config.introspect(type);\n    // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n    KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n    if (des != null) {\n        return des;\n    } else {\n        // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n        if (custom != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n        }\n        JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (valueDesForKey != null) {\n            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n        }\n    }\n    EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n    // May have @JsonCreator for static factory method:\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n        if (ai.hasCreatorAnnotation(factory)) {\n            int argCount = factory.getParameterCount();\n            if (argCount == 1) {\n                Class<?> returnType = factory.getRawReturnType();\n                // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                if (returnType.isAssignableFrom(enumClass)) {\n                    // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                    if (factory.getRawParameterType(0) != String.class) {\n                        throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                    }\n                    if (!config.canOverrideAccessModifiers()) {\n                        ClassUtil.checkAndFixAccess(factory.getMember(), false);\n                    }\n                    return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                }\n            }\n            throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                    +enumClass.getName()+\")\");\n        }\n    }\n    // [JACKSON-749] Also, need to consider @JsonValue, if one found\n    return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -6.612355394786146,
      "mean_entropy": -0.01200064499961188
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -3.6141461918358697,
      "mean_entropy": -0.006385417300063374
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0).isAssignableFrom(String.class)) {\n                            if (config.canOverrideAccessModifiers()) {\n                                ClassUtil.checkAndFixAccess(factory.getMember(),\n                                        ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                            }\n                            return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                        } else {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                    }\n                    throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                            +enumClass.getName()+\")\");\n                }\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -8.232619820275195,
      "mean_entropy": -0.014417898109063389
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -5.6637813825631005,
      "mean_entropy": -0.010547078924698512
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n            }\n        }\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -7.955853667643125,
      "mean_entropy": -0.020991698331512203
    },
    {
      "patch": "\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (enumClass.isAssignableFrom(returnType)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\" + factory + \") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\" + factory + \") decorated with @JsonCreator (for Enum type \"\n                        + enumClass.getName() + \")\");\n            }\n        }\n        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -6.291983745103094,
      "mean_entropy": -0.011077436170956152
    },
    {
      "patch": "\n@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    final DeserializationConfig config = ctxt.getConfig();\n    // first: construct like a regular bean deserializer...\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n    addBeanProps(ctxt, beanDesc, builder);\n    // (and assume there won't be any back references)\n\n    // But then let's decorate things a bit\n    /* To resolve [JACKSON-95], need to add \"initCause\" as setter\n     * for exceptions (sub-classes of Throwable).\n     */\n    AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n    if (am != null) { // should never be null\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                new PropertyName(\"cause\"));\n        SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                am.getParameterType(0));\n        if (prop != null) {\n            /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n             *   to set... but let's replace it just in case,\n             *   otherwise can end up with odd errors.\n             */\n            builder.addOrReplaceProperty(prop, true);\n        }\n    }\n\n    // And also need to ignore \"localizedMessage\"\n    builder.addIgnorable(\"localizedMessage\");\n    // Java 7 also added \"getSuppressed\", skip if we have such data:\n    builder.addIgnorable(\"suppressed\");\n    /* As well as \"message\": it will be passed via constructor,\n     * as there's no 'setMessage()' method\n     */\n    builder.addIgnorable(\"message\");\n\n    // update builder now that all information is in?\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.build();\n\n    /* At this point it ought to be a BeanDeserializer; if not, must assume\n     * it's some other thing that can handle deserialization ok...\n     */\n    if (deserializer instanceof BeanDeserializer) {\n        deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n    }\n\n    // may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}\n\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -9.8195404609029,
      "mean_entropy": -0.016393222806181804
    },
    {
      "patch": "\n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // first: construct like a regular bean deserializer...\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n        addBeanProps(ctxt, beanDesc, builder);\n        // (and assume there won't be any back references)\n\n        // But then let's decorate things a bit\n        /* To resolve [JACKSON-95], need to add \"initCause\" as setter\n         * for exceptions (sub-classes of Throwable).\n         */\n        AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n        if (am != null) { // should never be null\n            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                    new PropertyName(\"cause\"));\n            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                    am.getParameterType(0));\n            if (prop != null) {\n                /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n                 *   to set... but let's replace it just in case,\n                 *   otherwise can end up with odd errors.\n                 */\n                if (!am.getMember().isAccessible()) {\n                    am.getMember().setAccessible(true);\n                }\n                builder.addOrReplaceProperty(prop, true);\n            }\n        }\n\n        // And also need to ignore \"localizedMessage\"\n        builder.addIgnorable(\"localizedMessage\");\n        // Java 7 also added \"getSuppressed\", skip if we have such data:\n        builder.addIgnorable(\"suppressed\");\n        /* As well as \"message\": it will be passed via constructor,\n         * as there's no 'setMessage()' method\n        */\n        builder.addIgnorable(\"message\");\n\n        // update builder now that all information is in?\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.build();\n        \n        /* At this point it ought to be a BeanDeserializer; if not, must assume\n         * it's some other thing that can handle deserialization ok...\n         */\n        if (deserializer instanceof BeanDeserializer) {\n            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n        }\n\n        // may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -6.2361424449442575,
      "mean_entropy": -0.00993016312889213
    },
    {
      "patch": "\n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // first: construct like a regular bean deserializer...\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n        addBeanProps(ctxt, beanDesc, builder);\n        // (and assume there won't be any back references)\n\n        // But then let's decorate things a bit\n        /* To resolve [JACKSON-95], need to add \"initCause\" as setter\n         * for exceptions (sub-classes of Throwable).\n         */\n        AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n        if (am != null) { // should never be null\n            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                    new PropertyName(\"cause\"));\n            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                    am.getParameterType(0));\n            if (prop != null) {\n                /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n                 *   to set... but let's replace it just in case,\n                 *   otherwise can end up with odd errors.\n                 */\n                builder.addOrReplaceProperty(prop, true);\n            }\n        }\n\n        // And also need to ignore \"localizedMessage\"\n        builder.addIgnorable(\"localizedMessage\");\n        // Java 7 also added \"getSuppressed\", skip if we have such data:\n        builder.addIgnorable(\"suppressed\");\n        /* As well as \"message\": it will be passed via constructor,\n         * as there's no 'setMessage()' method\n        */\n        builder.addIgnorable(\"message\");\n\n        // update builder now that all information is in?\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.build();\n        \n        /* At this point it ought to be a BeanDeserializer; if not, must assume\n         * it's some other thing that can handle deserialization ok...\n         */\n        if (deserializer instanceof BeanDeserializer) {\n            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n        }\n\n        // may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -4.213628542262106,
      "mean_entropy": -0.006953182412973773
    },
    {
      "patch": "\n@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt,\n        JavaType type, BeanDescription beanDesc)\n    throws JsonMappingException\n{\n    final DeserializationConfig config = ctxt.getConfig();\n    // first: construct like a regular bean deserializer...\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n    addBeanProps(ctxt, beanDesc, builder);\n    // (and assume there won't be any back references)\n\n    // But then let's decorate things a bit\n    /* To resolve [JACKSON-95], need to add \"initCause\" as setter\n     * for exceptions (sub-classes of Throwable).\n     */\n    AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n    if (am != null) { // should never be null\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                new PropertyName(\"cause\"));\n        SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                am.getParameterType(0));\n        if (prop != null) {\n            /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n             *   to set... but let's replace it just in case,\n             *   otherwise can end up with odd errors.\n             */\n            builder.addOrReplaceProperty(prop, true);\n        }\n    }\n\n    // And also need to ignore \"localizedMessage\"\n    builder.addIgnorable(\"localizedMessage\");\n    // Java 7 also added \"getSuppressed\", skip if we have such data:\n    builder.addIgnorable(\"suppressed\");\n    /* As well as \"message\": it will be passed via constructor,\n     * as there's no 'setMessage()' method\n    */\n    builder.addIgnorable(\"message\");\n\n    // update builder now that all information is in?\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.build();\n    \n    /* At this point it ought to be a BeanDeserializer; if not, must assume\n     * it's some other thing that can handle deserialization ok...\n     */\n    if (deserializer instanceof BeanDeserializer) {\n        deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n    }\n\n    // may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -4.267308963789817,
      "mean_entropy": -0.007100347693493872
    },
    {
      "patch": "\n@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt,\n        JavaType type, BeanDescription beanDesc)\n    throws JsonMappingException\n{\n    final DeserializationConfig config = ctxt.getConfig();\n    // first: construct like a regular bean deserializer...\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n    addBeanProps(ctxt, beanDesc, builder);\n    // (and assume there won't be any back references)\n\n    // But then let's decorate things a bit\n    /* To resolve [JACKSON-95], need to add \"initCause\" as setter\n     * for exceptions (sub-classes of Throwable).\n     */\n    AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n    if (am != null) { // should never be null\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                new PropertyName(\"cause\"));\n        SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                am.getParameterType(0));\n        if (prop != null) {\n            /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n             *   to set... but let's replace it just in case,\n             *   otherwise can end up with odd errors.\n             */\n            builder.addOrReplaceProperty(prop, true);\n        }\n    }\n\n    // And also need to ignore \"localizedMessage\"\n    builder.addIgnorable(\"localizedMessage\");\n    // Java 7 also added \"getSuppressed\", skip if we have such data:\n    builder.addIgnorable(\"suppressed\");\n    /* As well as \"message\": it will be passed via constructor,\n     * as there's no 'setMessage()' method\n    */\n    builder.addIgnorable(\"message\");\n\n    // update builder now that all information is in?\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.build();\n    \n    /* At this point it ought to be a BeanDeserializer; if not, must assume\n     * it's some other thing that can handle deserialization ok...\n     */\n    if (deserializer instanceof BeanDeserializer) {\n        deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n    }\n\n    // may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -4.267308963789817,
      "mean_entropy": -0.007100347693493872
    },
    {
      "patch": "\n@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt,\n        JavaType type, BeanDescription beanDesc)\n    throws JsonMappingException\n{\n    final DeserializationConfig config = ctxt.getConfig();\n    // first: construct like a regular bean deserializer...\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n    addBeanProps(ctxt, beanDesc, builder);\n    // (and assume there won't be any back references)\n\n    // But then let's decorate things a bit\n    /* To resolve [JACKSON-95], need to add \"initCause\" as setter\n     * for exceptions (sub-classes of Throwable).\n     */\n    AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n    if (am != null) { // should never be null\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                new PropertyName(\"cause\"));\n        SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                am.getParameterType(0));\n        if (prop != null) {\n            /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n             *   to set... but let's replace it just in case,\n             *   otherwise can end up with odd errors.\n             */\n            builder.addOrReplaceProperty(prop, true);\n        }\n    }\n\n    // And also need to ignore \"localizedMessage\"\n    builder.addIgnorable(\"localizedMessage\");\n    // Java 7 also added \"getSuppressed\", skip if we have such data:\n    builder.addIgnorable(\"suppressed\");\n    /* As well as \"message\": it will be passed via constructor,\n     * as there's no 'setMessage()' method\n    */\n    builder.addIgnorable(\"message\");\n\n    // update builder now that all information is in?\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.build();\n    \n    /* At this point it ought to be a BeanDeserializer; if not, must assume\n     * it's some other thing that can handle deserialization ok...\n     */\n    if (deserializer instanceof BeanDeserializer) {\n        deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n    }\n\n    // may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -3.4154517075366764,
      "mean_entropy": -0.0056829479326733386
    },
    {
      "patch": "\n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // first: construct like a regular bean deserializer...\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n\n        addBeanProps(ctxt, beanDesc, builder);\n        // (and assume there won't be any back references)\n\n        // But then let's decorate things a bit\n        /* To resolve [JACKSON-95], need to add \"initCause\" as setter\n         * for exceptions (sub-classes of Throwable).\n         */\n        AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n        if (am != null) { // should never be null\n            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n                    new PropertyName(\"cause\"));\n            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                    am.getParameterType(0));\n            if (prop != null) {\n                /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n                 *   to set... but let's replace it just in case,\n                 *   otherwise can end up with odd errors.\n                 */\n                builder.addOrReplaceProperty(prop, true);\n            }\n        }\n\n        // And also need to ignore \"localizedMessage\"\n        builder.addIgnorable(\"localizedMessage\");\n        // Java 7 also added \"getSuppressed\", skip if we have such data:\n        builder.addIgnorable(\"suppressed\");\n        /* As well as \"message\": it will be passed via constructor,\n         * as there's no 'setMessage()' method\n        */\n        builder.addIgnorable(\"message\");\n\n        // update builder now that all information is in?\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.build();\n        \n        /* At this point it ought to be a BeanDeserializer; if not, must assume\n         * it's some other thing that can handle deserialization ok...\n         */\n        if (deserializer instanceof BeanDeserializer) {\n            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n        }\n\n        // may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -4.042741166440213,
      "mean_entropy": -0.006671190043630715
    },
    {
      "patch": "\n    /**\n     * Method called to locate all members used for value injection (if any),\n     * constructor {@link com.fasterxml.jackson.databind.deser.impl.ValueInjector} instances, and add them to builder.\n     */\n    protected void addInjectables(DeserializationContext ctxt,\n                                  BeanDescription beanDesc, BeanDeserializerBuilder builder)\n            throws JsonMappingException {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            boolean fixAccess = ctxt.canOverrideAccessModifiers();\n            boolean forceAccess = fixAccess && ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                if (fixAccess) {\n                    try {\n                        m.fixAccess(forceAccess); // to ensure we can call it\n                    } catch (Exception e) {\n                        // Log or handle the exception as needed\n                    }\n                }\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        m.getType(),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -12.478775523809077,
      "mean_entropy": -0.05355697649703466
    },
    {
      "patch": "\n    protected void addInjectables(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            boolean fixAccess = ctxt.canOverrideAccessModifiers();\n            boolean forceAccess = fixAccess && ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                if (fixAccess && m.getMember().getDeclaringClass() != Throwable.class) {\n                    m.fixAccess(forceAccess); // to ensure we can call it\n                }\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        m.getType(),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -5.493956382907673,
      "mean_entropy": -0.030186573532459744
    },
    {
      "patch": "\n    protected void addInjectables(DeserializationContext ctxt,\n                                   BeanDescription beanDesc, BeanDeserializerBuilder builder)\n            throws JsonMappingException {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            boolean fixAccess = ctxt.canOverrideAccessModifiers();\n            boolean forceAccess = fixAccess && ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                if (fixAccess) {\n                    if (m instanceof AnnotatedField || m instanceof AnnotatedMethod) {\n                        m.fixAccess(forceAccess);\n                    }\n                }\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        m.getType(),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -12.269935634159767,
      "mean_entropy": -0.06932167024949021
    },
    {
      "patch": "\n    /**\n     * Method called locate all members used for value injection (if any),\n     * constructor {@link com.fasterxml.jackson.databind.deser.impl.ValueInjector} instances, and add them to builder.\n     */\n    protected void addInjectables(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            boolean fixAccess = ctxt.canOverrideAccessModifiers();\n            boolean forceAccess = fixAccess && ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                if (fixAccess) {\n                    try {\n                        m.fixAccess(forceAccess); // to ensure we can call it\n                    } catch (Exception e) {\n                        // Handle the exception here\n                        e.printStackTrace();\n                    }\n                }\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        m.getType(),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -9.515063625711894,
      "mean_entropy": -0.040489632449837845
    },
    {
      "patch": "\n    /**\n     * Method that can be called to modify access rights, by calling\n     * {@link java.lang.reflect.AccessibleObject#setAccessible} on\n     * the underlying annotated element.\n     *<p>\n     * Note that caller should verify that\n     * {@link com.fasterxml.jackson.databind.MapperFeature#CAN_OVERRIDE_ACCESS_MODIFIERS}\n     * is enabled before calling this method; as well as pass\n     * <code>force</code> flag appropriately.\n     * \n     * @since 2.7\n     */\n    public final void fixAccess(boolean force) {\n        com.fasterxml.jackson.databind.util.ClassUtil.checkAndFixAccess(getMember(), force);\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -3.33780528676223,
      "mean_entropy": -0.0236723779202995
    },
    {
      "patch": "\n    /**\n     * Method that can be called to modify access rights, by calling\n     * {@link java.lang.reflect.AccessibleObject#setAccessible} on\n     * the underlying annotated element.\n     *<p>\n     * Note that caller should verify that\n     * {@link com.fasterxml.jackson.databind.MapperFeature#CAN_OVERRIDE_ACCESS_MODIFIERS}\n     * is enabled before calling this method; as well as pass\n     * <code>force</code> flag appropriately.\n     * \n     * @since 2.7\n     */\n    public final void fixAccess(boolean force) {\n        com.fasterxml.jackson.databind.util.ClassUtil.checkAndFixAccess(getMember(), force);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -3.33780528676223,
      "mean_entropy": -0.0236723779202995
    },
    {
      "patch": "\n    /**\n     * Method that can be called to modify access rights, by calling\n     * {@link java.lang.reflect.AccessibleObject#setAccessible} on\n     * the underlying annotated element.\n     *<p>\n     * Note that caller should verify that\n     * {@link com.fasterxml.jackson.databind.MapperFeature#CAN_OVERRIDE_ACCESS_MODIFIERS}\n     * is enabled before calling this method; as well as pass\n     * <code>force</code> flag appropriately.\n     * \n     * @since 2.7\n     */\n    public final void fixAccess(boolean force) {\n        ClassUtil.checkAndFixAccess(this.getMember(), force);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 305,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral",
        [
          "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral"
        ]
      ],
      "sum_entropy": -3.6520024118061802,
      "mean_entropy": -0.026656951910994018
    }
  ],
  "JacksonDatabind_85": [
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df instanceof StdDateFormat) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, _formatString);\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -3.9760638487628928,
      "mean_entropy": -0.012622424916707595
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n    throws JsonMappingException {\n    \n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df instanceof StdDateFormat) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    return withDateFormat(std, _formatString);\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                    return withDateFormat(df, _formatString);\n                }\n            }\n        }\n    }\n    \n    return this;\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -14.204928554895432,
      "mean_entropy": -0.043978106981100405
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n        throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df.getClass() == StdDateFormat.class) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, _formatString);\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -5.173804836908988,
      "mean_entropy": -0.016218823940153566
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n    throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                if (df instanceof StdDateFormat) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, format.getPattern());\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -8.131183805607805,
      "mean_entropy": -0.027103946018692683
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df.getClass() == StdDateFormat.class) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, _formatString);\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -5.010816815911742,
      "mean_entropy": -0.01575728558462812
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n    throws JsonMappingException\n{\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property,\n                this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df instanceof StdDateFormat) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, format.getPattern());\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -6.9067859926285795,
      "mean_entropy": -0.021719452807008113
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n        throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df instanceof StdDateFormat) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    return withDateFormat(std, _formatString);\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                    return withDateFormat(df, _formatString);\n                }\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -6.161907700260093,
      "mean_entropy": -0.01919597414411244
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n       throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                if (df instanceof StdDateFormat) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, _formatString);\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -8.689971528531192,
      "mean_entropy": -0.02896657176177064
    },
    {
      "patch": "\n        @Override\n        public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n           throws JsonMappingException\n        {\n            if (property != null) {\n                JsonFormat.Value format = findFormatOverrides(ctxt, property,\n                        this.handledType());\n                if (format != null) {\n                    TimeZone tz = format.getTimeZone();\n                    // First: fully custom pattern?\n                    if (format.hasPattern()) {\n                        final String pattern = format.getPattern();\n                        final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                        SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                        if (tz == null) {\n                            tz = ctxt.getTimeZone();\n                        }\n                        df.setTimeZone(tz);\n                        return withDateFormat(df, pattern);\n                    }\n                    // But if not, can still override timezone\n                    if (tz != null) {\n                        DateFormat df = ctxt.getConfig().getDateFormat();\n                        // one shortcut: with our custom format, can simplify handling a bit\n                        if (df.getClass() == StdDateFormat.class) {\n                            final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                            StdDateFormat std = (StdDateFormat) df;\n                            std = std.withTimeZone(tz);\n                            std = std.withLocale(loc);\n                            df = std;\n                        } else {\n                            // otherwise need to clone, re-set timezone:\n                            df = (DateFormat) df.clone();\n                            df.setTimeZone(tz);\n                        }\n                        return withDateFormat(df, format.getPattern());\n                    }\n                }\n            }\n            return this;\n        }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -4.399438093808797,
      "mean_entropy": -0.013495208876714102
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df.getClass() == StdDateFormat.class) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    return withDateFormat(std, _formatString);\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                    return withDateFormat(df, _formatString);\n                }\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -4.337094597471276,
      "mean_entropy": -0.01342753745347144
    },
    {
      "patch": "\n        @Override\n        public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n           throws JsonMappingException\n        {\n            if (property != null) {\n                JsonFormat.Value format = findFormatOverrides(ctxt, property,\n                        this.handledType());\n                if (format != null) {\n                    TimeZone tz = format.getTimeZone();\n                    // First: fully custom pattern?\n                    if (format.hasPattern()) {\n                        final String pattern = format.getPattern();\n                        final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                        SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                        if (tz == null) {\n                            tz = ctxt.getTimeZone();\n                        }\n                        df.setTimeZone(tz);\n                        return withDateFormat(df, pattern);\n                    }\n                    // But if not, can still override timezone\n                    if (tz != null) {\n                        DateFormat df = ctxt.getConfig().getDateFormat();\n                        // one shortcut: with our custom format, can simplify handling a bit\n                        if (df instanceof StdDateFormat) {\n                            final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                            StdDateFormat std = (StdDateFormat) df;\n                            std = std.withTimeZone(tz);\n                            std = std.withLocale(loc);\n                            df = std;\n                        } else {\n                            // otherwise need to clone, re-set timezone:\n                            df = (DateFormat) df.clone();\n                            df.setTimeZone(tz);\n                        }\n                        return withDateFormat(df, _formatString);\n                    }\n                }\n            }\n            return this;\n        }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -4.931408388830752,
      "mean_entropy": -0.015267518231674155
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n        throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df instanceof StdDateFormat) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, format.getPattern());\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -5.52069125488924,
      "mean_entropy": -0.017470541945852024
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n        throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df.getClass() == StdDateFormat.class) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, format.getPattern());\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -4.052758153015986,
      "mean_entropy": -0.012704571012589299
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df.getClass() == StdDateFormat.class) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, _formatString);\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -5.010816815911742,
      "mean_entropy": -0.01575728558462812
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df.getClass() == StdDateFormat.class) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    return withDateFormat(std, _formatString);\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                    return withDateFormat(df, _formatString);\n                }\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -4.337094597471276,
      "mean_entropy": -0.01342753745347144
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n        throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property,\n                this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df.getClass() == StdDateFormat.class) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    return withDateFormat(std, _formatString);\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                    return withDateFormat(df, _formatString);\n                }\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -5.285998080762109,
      "mean_entropy": -0.016264609479268027
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n   throws JsonMappingException\n{\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property,\n                this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df.getClass() == StdDateFormat.class) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, format.getPattern());\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -5.840505285412804,
      "mean_entropy": -0.018194720515304685
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n        throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property,\n                this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df instanceof StdDateFormat) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, _formatString);\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -4.81477687613578,
      "mean_entropy": -0.015188570587179116
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n        throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df.getClass() == StdDateFormat.class) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, _formatString);\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -5.110916897633699,
      "mean_entropy": -0.016021683064682442
    },
    {
      "patch": "\n@Override\npublic JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {\n    if (property != null) {\n        JsonFormat.Value format = findFormatOverrides(ctxt, property, this.handledType());\n        if (format != null) {\n            TimeZone tz = format.getTimeZone();\n            // First: fully custom pattern?\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = ctxt.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withDateFormat(df, pattern);\n            }\n            // But if not, can still override timezone\n            if (tz != null) {\n                DateFormat df = ctxt.getConfig().getDateFormat();\n                // one shortcut: with our custom format, can simplify handling a bit\n                if (df instanceof StdDateFormat) {\n                    final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                    StdDateFormat std = (StdDateFormat) df;\n                    std = std.withTimeZone(tz);\n                    std = std.withLocale(loc);\n                    df = std;\n                } else {\n                    // otherwise need to clone, re-set timezone:\n                    df = (DateFormat) df.clone();\n                    df.setTimeZone(tz);\n                }\n                return withDateFormat(df, _formatString);\n            }\n        }\n    }\n    return this;\n}\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 325,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern",
        [
          "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern"
        ]
      ],
      "sum_entropy": -3.9928049148481692,
      "mean_entropy": -0.012675571158248156
    }
  ],
  "Jsoup_16": [
    {
      "patch": "\n@Override\nvoid outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n    accum.append(\"<!DOCTYPE html\");\n    if (!StringUtil.isBlank(attr(\"publicId\")))\n        accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n    if (!StringUtil.isBlank(attr(\"systemId\")))\n        accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n    accum.append('>');\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -1.6556567749964397,
      "mean_entropy": -0.019478314999958113
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -0.8467301686563802,
      "mean_entropy": -0.00951382211973461
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -0.8467301686563802,
      "mean_entropy": -0.00951382211973461
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -0.8467301686563802,
      "mean_entropy": -0.00951382211973461
    },
    {
      "patch": "\n@Override\nvoid outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n    accum.append(\"<!DOCTYPE html\");\n    if (!StringUtil.isBlank(attr(\"publicId\")))\n        accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n    if (!StringUtil.isBlank(attr(\"systemId\")))\n        accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n    accum.append('>');\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -1.6556567749964397,
      "mean_entropy": -0.019478314999958113
    },
    {
      "patch": "\n@Override\nvoid outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n    accum.append(\"<!DOCTYPE html\");\n    if (!StringUtil.isBlank(attr(\"publicId\")))\n        accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n    if (!StringUtil.isBlank(attr(\"systemId\")))\n        accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n    accum.append('>');\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -1.6556567749964397,
      "mean_entropy": -0.019478314999958113
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -0.8467301686563802,
      "mean_entropy": -0.00951382211973461
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -0.8467301686563802,
      "mean_entropy": -0.00951382211973461
    },
    {
      "patch": "\n@Override\nvoid outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n    accum.append(\"<!DOCTYPE html\");\n    if (!StringUtil.isBlank(attr(\"publicId\")))\n        accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n    if (!StringUtil.isBlank(attr(\"systemId\")))\n        accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n    accum.append('>');\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -1.6556567749964397,
      "mean_entropy": -0.019478314999958113
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -0.8467301686563802,
      "mean_entropy": -0.00951382211973461
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(' ').append(\"\\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -3.641003627033981,
      "mean_entropy": -0.040011028868505286
    },
    {
      "patch": "\n@Override\nvoid outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n    accum.append(\"<!DOCTYPE html\");\n    if (!StringUtil.isBlank(attr(\"publicId\")))\n        accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n    if (!StringUtil.isBlank(attr(\"systemId\")))\n        accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n    accum.append('>');\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -1.6556567749964397,
      "mean_entropy": -0.019478314999958113
    },
    {
      "patch": "\n@Override\nvoid outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n    accum.append(\"<!DOCTYPE html\");\n    if (!StringUtil.isBlank(attr(\"publicId\")))\n        accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n    if (!StringUtil.isBlank(attr(\"systemId\")))\n        accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n    accum.append('>');\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -1.6556567749964397,
      "mean_entropy": -0.019478314999958113
    },
    {
      "patch": "\n@Override\nvoid outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n    accum.append(\"<!DOCTYPE html\");\n    if (!StringUtil.isBlank(attr(\"publicId\")))\n        accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n    if (!StringUtil.isBlank(attr(\"systemId\")))\n        accum.append(' ').append(attr(\"systemId\")).append(\"\\\"\"); // Fixed the missing double quote here\n    accum.append('>');\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -6.848767841410239,
      "mean_entropy": -0.07444312871098085
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -0.8467301686563802,
      "mean_entropy": -0.00951382211973461
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -0.8467301686563802,
      "mean_entropy": -0.00951382211973461
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -0.8013283217214799,
      "mean_entropy": -0.009003689008106516
    },
    {
      "patch": "\n@Override\nvoid outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n    accum.append(\"<!DOCTYPE html\");\n    if (!StringUtil.isBlank(attr(\"publicId\")))\n        accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n    if (!StringUtil.isBlank(attr(\"systemId\")))\n        accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n    accum.append('>');\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -1.49257431054714,
      "mean_entropy": -0.017559697771142826
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -0.8013283217214799,
      "mean_entropy": -0.009003689008106516
    },
    {
      "patch": "\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -0.8013283217214799,
      "mean_entropy": -0.009003689008106516
    },
    {
      "patch": "\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n                // skip\n            }\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError();\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length() - 1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -2.9085659191509396,
      "mean_entropy": -0.005416323871789459
    },
    {
      "patch": "\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n                // skip\n            }\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError();\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -2.0475421916298506,
      "mean_entropy": -0.003827181666597852
    },
    {
      "patch": "\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n                // skip\n            }\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError();\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -2.0475421916298506,
      "mean_entropy": -0.003827181666597852
    },
    {
      "patch": "\nCharacter consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n        return null;\n\n    reader.mark();\n    if (reader.matchConsume(\"#\")) { // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) { // didn't match anything\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n            // skip\n        }\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else { // named\n        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n        String nameRef = reader.consumeLetterSequence();\n        boolean looksLegit = reader.matches(';');\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit) // named with semicolon\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        return Entities.getCharacterByName(nameRef);\n    }\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -3.2422955228303723,
      "mean_entropy": -0.0060603654632343405
    },
    {
      "patch": "\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter.equals(reader.current())) // Fixed comparison using equals()\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.parseInt(numRef, base); // Changed to parseInt() for base conversion\n            } catch (NumberFormatException e) {\n            } // skip\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError();\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -14.989546464683071,
      "mean_entropy": -0.02730336332364858
    },
    {
      "patch": "\nCharacter consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n        return null;\n\n    reader.mark();\n    if (reader.matchConsume(\"#\")) { // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) { // didn't match anything\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n            // skip\n        }\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else { // named\n        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n        String nameRef = reader.consumeLetterSequence();\n        boolean looksLegit = reader.matches(';');\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length()-1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit) // named with semicolon\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        return Entities.getCharacterByName(nameRef);\n    }\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -2.860813412440246,
      "mean_entropy": -0.005367379760675884
    },
    {
      "patch": "\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n            } // skip\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError();\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -3.4248755648004003,
      "mean_entropy": -0.00641362465318427
    },
    {
      "patch": "\nCharacter consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n        return null;\n\n    reader.mark();\n    if (reader.matchConsume(\"#\")) { // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.isEmpty()) { // didn't match anything\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n            // skip\n        }\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else { // named\n        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n        String nameRef = reader.consumeLetterSequence();\n        boolean looksLegit = reader.matches(';');\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length()-1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit) // named with semicolon\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        return Entities.getCharacterByName(nameRef);\n    }\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -5.143200747519156,
      "mean_entropy": -0.00972249668718177
    },
    {
      "patch": "\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n                // skip\n            }\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError();\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length() - 1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -2.9085659191509396,
      "mean_entropy": -0.005416323871789459
    },
    {
      "patch": "\nCharacter consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter.equals(reader.current()))\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n        return null;\n\n    reader.mark();\n    if (reader.matchConsume(\"#\")) { // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.isEmpty()) { // didn't match anything\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n            // skip\n        }\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else { // named\n        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n        String nameRef = reader.consumeLetterSequence();\n        boolean looksLegit = reader.matches(';');\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length()-1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit) // named with semicolon\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        return Entities.getCharacterByName(nameRef);\n    }\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -4.9345822747396,
      "mean_entropy": -0.009328132844498299
    },
    {
      "patch": "\nCharacter consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n        return null;\n\n    reader.mark();\n    if (reader.matchConsume(\"#\")) { // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.isEmpty()) { // didn't match anything\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n        } // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else { // named\n        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n        String nameRef = reader.consumeLetterSequence();\n        boolean looksLegit = reader.matches(';');\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length()-1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit) // named with semicolon\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        return Entities.getCharacterByName(nameRef);\n    }\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -6.7672832239888,
      "mean_entropy": -0.012816824287857576
    },
    {
      "patch": "\nCharacter consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n        return null;\n\n    reader.mark();\n    if (reader.matchConsume(\"#\")) { // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) { // didn't match anything\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n            // skip\n        }\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else { // named\n        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n        String nameRef = reader.consumeLetterSequence();\n        boolean looksLegit = reader.matches(';');\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length()-1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit) // named with semicolon\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        return Entities.getCharacterByName(nameRef);\n    }\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -2.860813412440246,
      "mean_entropy": -0.005367379760675884
    },
    {
      "patch": "\nCharacter consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n        return null;\n\n    reader.mark();\n    if (reader.matchConsume(\"#\")) { // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) { // didn't match anything\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n            // skip\n        }\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else { // named\n        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n        String nameRef = reader.consumeLetterSequence();\n        boolean looksLegit = reader.matches(';');\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length()-1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit) // named with semicolon\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        return Entities.getCharacterByName(nameRef);\n    }\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -4.298493916426649,
      "mean_entropy": -0.008064716541138177
    },
    {
      "patch": "\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n            } // skip\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError();\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -3.4248755648004003,
      "mean_entropy": -0.00641362465318427
    },
    {
      "patch": "\nCharacter consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n        return null;\n\n    reader.mark();\n    if (reader.matchConsume(\"#\")) { // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) { // didn't match anything\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n            // skip\n        }\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else { // named\n        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n        String nameRef = reader.consumeLetterSequence();\n        boolean looksLegit = reader.matches(';');\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length()-1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit) // named with semicolon\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        return Entities.getCharacterByName(nameRef);\n    }\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -2.860813412440246,
      "mean_entropy": -0.005367379760675884
    },
    {
      "patch": "\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n                // skip\n            }\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError();\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -2.0475421916298506,
      "mean_entropy": -0.003827181666597852
    },
    {
      "patch": "\nCharacter consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n        return null;\n\n    reader.mark();\n    if (reader.matchConsume(\"#\")) { // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) { // didn't match anything\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n            // skip\n        }\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else { // named\n        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n        String nameRef = reader.consumeLetterSequence();\n        boolean looksLegit = reader.matches(';');\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit) // named with semicolon\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        return Entities.getCharacterByName(nameRef);\n    }\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -3.205099390564731,
      "mean_entropy": -0.005990839982363983
    },
    {
      "patch": "\nCharacter consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n        return null;\n\n    reader.mark();\n    if (reader.matchConsume(\"#\")) { // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) { // didn't match anything\n            characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n            // skip\n        }\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError();\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else { // named\n        // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n        String nameRef = reader.consumeLetterSequence();\n        boolean looksLegit = reader.matches(';');\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length()-1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            if (looksLegit) // named with semicolon\n                characterReferenceError();\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            characterReferenceError(); // missing semi\n        return Entities.getCharacterByName(nameRef);\n    }\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -4.257919781149082,
      "mean_entropy": -0.007988592459941992
    },
    {
      "patch": "\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException e) {\n                // skip\n            }\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError();\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -1.9557236038802477,
      "mean_entropy": -0.003655558138093921
    },
    {
      "patch": "\n    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n            return null;\n\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.parseInt(numRef, base);\n            } catch (NumberFormatException e) {\n                // skip\n            }\n            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                characterReferenceError();\n                return replacementChar;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) charval;\n            }\n        } else { // named\n            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n            String nameRef = reader.consumeLetterSequence();\n            boolean looksLegit = reader.matches(';');\n            boolean found = false;\n            while (nameRef.length() > 0 && !found) {\n                if (Entities.isNamedEntity(nameRef))\n                    found = true;\n                else {\n                    nameRef = nameRef.substring(0, nameRef.length()-1);\n                    reader.unconsume();\n                }\n            }\n            if (!found) {\n                if (looksLegit) // named with semicolon\n                    characterReferenceError();\n                reader.rewindToMark();\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(); // missing semi\n            return Entities.getCharacterByName(nameRef);\n        }\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
        [
          "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration",
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationThrowsExceptionOnBlankName"
        ]
      ],
      "sum_entropy": -4.097995865119826,
      "mean_entropy": -0.00765980535536416
    }
  ],
  "Jsoup_39": [
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\")) {\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    }\n\n    // set up the request for execution\n    if (req.method() == Connection.Method.GET && req.data().size() > 0) {\n        serialiseRequestUrl(req); // appends query string\n    }\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (req.method() == Connection.Method.POST) {\n            writePost(req.data(), conn.getOutputStream());\n        }\n\n        int status = conn.getResponseCode();\n        boolean needsRedirect = false;\n        if (status != HttpURLConnection.HTTP_OK) {\n            if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER) {\n                needsRedirect = true;\n            } else if (!req.ignoreHttpErrors()) {\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n            }\n        }\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        if (needsRedirect && req.followRedirects()) {\n            req.method(Connection.Method.GET); // always redirect with a get. any data param from original req are dropped.\n            req.data().clear();\n\n            String location = res.header(\"Location\");\n            if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') {\n                location = location.substring(6);\n            }\n            req.url(new URL(req.url(), encodeUrl(location)));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) {\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        res.req = req;\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null && !req.ignoreContentType() && (!(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\")))) {\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n        }\n\n        InputStream bodyStream = null;\n        InputStream dataStream = null;\n        try {\n            dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            bodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n                    new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                    new BufferedInputStream(dataStream);\n\n            res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        } finally {\n            if (bodyStream != null) {\n                bodyStream.close();\n            }\n            if (dataStream != null) {\n                dataStream.close();\n            }\n        }\n    } finally {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet",
        [
          "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet"
        ]
      ],
      "sum_entropy": -7.699919241520176,
      "mean_entropy": -0.010664708090748166
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n\n            // set up the request for execution\n            if (req.method() == Connection.Method.GET && req.data().size() > 0)\n                serialiseRequestUrl(req); // appends query string\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (req.method() == Connection.Method.POST)\n                    writePost(req.data(), conn.getOutputStream());\n\n                int status = conn.getResponseCode();\n                boolean needsRedirect = false;\n                if (status != HttpURLConnection.HTTP_OK) {\n                    if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER)\n                        needsRedirect = true;\n                    else if (!req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n                }\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                if (needsRedirect && req.followRedirects()) {\n                    req.method(Connection.Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n\n                    String location = res.header(\"Location\");\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    req.url(new URL(req.url(), encodeUrl(location)));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                res.req = req;\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null && !req.ignoreContentType() && (!(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))))\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                InputStream bodyStream = null;\n                InputStream dataStream = null;\n                try {\n                    dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    bodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n                            new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                            new BufferedInputStream(dataStream);\n\n                    res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                    res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                } finally {\n                    if (bodyStream != null) bodyStream.close();\n                    if (dataStream != null) dataStream.close();\n                }\n            } finally {\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet",
        [
          "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet"
        ]
      ],
      "sum_entropy": -2.492900929047301,
      "mean_entropy": -0.0034432333274133993
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n\n            // set up the request for execution\n            if (req.method() == Connection.Method.GET && req.data().size() > 0)\n                serialiseRequestUrl(req); // appends query string\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (req.method() == Connection.Method.POST)\n                    writePost(req.data(), conn.getOutputStream());\n\n                int status = conn.getResponseCode();\n                boolean needsRedirect = false;\n                if (status != HttpURLConnection.HTTP_OK) {\n                    if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER)\n                        needsRedirect = true;\n                    else if (!req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n                }\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                if (needsRedirect && req.followRedirects()) {\n                    req.method(Connection.Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n\n                    String location = res.header(\"Location\");\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    req.url(new URL(req.url(), encodeUrl(location)));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                res.req = req;\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null && !req.ignoreContentType() && (!(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))))\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                InputStream bodyStream = null;\n                InputStream dataStream = null;\n                try {\n                    dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    bodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n                            new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                            new BufferedInputStream(dataStream);\n\n                    res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                    res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                } finally {\n                    if (bodyStream != null) bodyStream.close();\n                    if (dataStream != null) dataStream.close();\n                }\n            } finally {\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet",
        [
          "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet"
        ]
      ],
      "sum_entropy": -2.492900929047301,
      "mean_entropy": -0.0034432333274133993
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n\n            // set up the request for execution\n            if (req.method() == Connection.Method.GET && req.data().size() > 0)\n                serialiseRequestUrl(req); // appends query string\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (req.method() == Connection.Method.POST)\n                    writePost(req.data(), conn.getOutputStream());\n\n                int status = conn.getResponseCode();\n                boolean needsRedirect = false;\n                if (status != HttpURLConnection.HTTP_OK) {\n                    if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER)\n                        needsRedirect = true;\n                    else if (!req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n                }\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                if (needsRedirect && req.followRedirects()) {\n                    req.method(Connection.Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n\n                    String location = res.header(\"Location\");\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    req.url(new URL(req.url(), encodeUrl(location)));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                res.req = req;\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null && !req.ignoreContentType() && (!(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))))\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                InputStream bodyStream = null;\n                InputStream dataStream = null;\n                try {\n                    dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    bodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n                            new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                            new BufferedInputStream(dataStream);\n\n                    res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                    res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                } finally {\n                    if (bodyStream != null) bodyStream.close();\n                    if (dataStream != null) dataStream.close();\n                }\n            } finally {\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet",
        [
          "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet"
        ]
      ],
      "sum_entropy": -2.492900929047301,
      "mean_entropy": -0.0034432333274133993
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n\n            // set up the request for execution\n            if (req.method() == Connection.Method.GET && req.data().size() > 0)\n                serialiseRequestUrl(req); // appends query string\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (req.method() == Connection.Method.POST)\n                    writePost(req.data(), conn.getOutputStream());\n\n                int status = conn.getResponseCode();\n                boolean needsRedirect = false;\n                if (status != HttpURLConnection.HTTP_OK) {\n                    if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER)\n                        needsRedirect = true;\n                    else if (!req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n                }\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                if (needsRedirect && req.followRedirects()) {\n                    req.method(Connection.Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n\n                    String location = res.header(\"Location\");\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    req.url(new URL(req.url(), encodeUrl(location)));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                res.req = req;\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null && !req.ignoreContentType() && (!(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))))\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                InputStream bodyStream = null;\n                InputStream dataStream = null;\n                try {\n                    dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    bodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n                            new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                            new BufferedInputStream(dataStream);\n\n                    res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                    res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                } finally {\n                    if (bodyStream != null) bodyStream.close();\n                    if (dataStream != null) dataStream.close();\n                }\n            } finally {\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet",
        [
          "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet"
        ]
      ],
      "sum_entropy": -2.492900929047301,
      "mean_entropy": -0.0034432333274133993
    },
    {
      "patch": "\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n\n        // set up the request for execution\n        if (req.method() == Connection.Method.GET && req.data().size() > 0)\n            serialiseRequestUrl(req); // appends query string\n        HttpURLConnection conn = createConnection(req);\n        Response res;\n        try {\n            conn.connect();\n            if (req.method() == Connection.Method.POST)\n                writePost(req.data(), conn.getOutputStream());\n\n            int status = conn.getResponseCode();\n            boolean needsRedirect = false;\n            if (status != HttpURLConnection.HTTP_OK) {\n                if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER)\n                    needsRedirect = true;\n                else if (!req.ignoreHttpErrors())\n                    throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n            }\n            res = new Response(previousResponse);\n            res.setupFromConnection(conn, previousResponse);\n            if (needsRedirect && req.followRedirects()) {\n                req.method(Connection.Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n\n                String location = res.header(\"Location\");\n                if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                req.url(new URL(req.url(), encodeUrl(location)));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            res.req = req;\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null && !req.ignoreContentType() && (!(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))))\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            InputStream bodyStream = null;\n            InputStream dataStream = null;\n            try {\n                dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                bodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n                        new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                        new BufferedInputStream(dataStream);\n\n                res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            } finally {\n                if (bodyStream != null) bodyStream.close();\n                if (dataStream != null) dataStream.close();\n            }\n        } finally {\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            conn.disconnect();\n        }\n\n        res.executed = true;\n        return res;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet",
        [
          "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet"
        ]
      ],
      "sum_entropy": -4.529754674887194,
      "mean_entropy": -0.0062565672305071734
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\")) {\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    }\n\n    // set up the request for execution\n    if (req.method() == Connection.Method.GET && !req.data().isEmpty()) {\n        serialiseRequestUrl(req); // appends query string\n    }\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (req.method() == Connection.Method.POST) {\n            writePost(req.data(), conn.getOutputStream());\n        }\n\n        int status = conn.getResponseCode();\n        boolean needsRedirect = false;\n        if (status != HttpURLConnection.HTTP_OK) {\n            if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER) {\n                needsRedirect = true;\n            } else if (!req.ignoreHttpErrors()) {\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n            }\n        }\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        if (needsRedirect && req.followRedirects()) {\n            req.method(Connection.Method.GET); // always redirect with a get. any data param from original req are dropped.\n            req.data().clear();\n\n            String location = res.header(\"Location\");\n            if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') {\n                location = location.substring(6);\n            }\n            req.url(new URL(req.url(), encodeUrl(location)));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        res.req = req;\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null && !req.ignoreContentType() &&\n                !(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))) {\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n        }\n\n        InputStream bodyStream = null;\n        InputStream dataStream = null;\n        try {\n            dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            bodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n                    new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                    new BufferedInputStream(dataStream);\n\n            res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        } finally {\n            if (bodyStream != null) bodyStream.close();\n            if (dataStream != null) dataStream.close();\n        }\n    } finally {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet",
        [
          "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet"
        ]
      ],
      "sum_entropy": -11.65824303382683,
      "mean_entropy": -0.01608033521907149
    }
  ],
  "Jsoup_40": [
    {
      "patch": "\nvoid insert(Token.Doctype d) {\n    String name = d.getName();\n    if (name.isEmpty()) {\n        name = null; // Setting name to null if it is empty\n    }\n    DocumentType doctypeNode = new DocumentType(name, d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n    insertNode(doctypeNode);\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -8.133102322297695,
      "mean_entropy": -0.11141236057942049
    },
    {
      "patch": "\nvoid insert(Token.Doctype d) {\n    if (d.getName().isEmpty()) {\n        DocumentType doctypeNode = new DocumentType(\"\", d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    } else {\n        DocumentType doctypeNode = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -2.810225988091101,
      "mean_entropy": -0.03157557289990001
    },
    {
      "patch": "\n    void insert(Token.Doctype d) {\n        String name = d.getName().isEmpty() ? null : d.getName();\n        DocumentType doctypeNode = new DocumentType(name, d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -3.0764011181801996,
      "mean_entropy": -0.0521423918335627
    },
    {
      "patch": "\nvoid insert(Token.Doctype d) {\n    if (d.getName() == null || d.getName().isEmpty()) {\n        DocumentType doctypeNode = new DocumentType(\"\", d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    } else {\n        DocumentType doctypeNode = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -4.132191927730805,
      "mean_entropy": -0.043496757134008475
    },
    {
      "patch": "\nvoid insert(Token.Doctype d) {\n    String name = d.getName();\n    String publicIdentifier = d.getPublicIdentifier();\n    String systemIdentifier = d.getSystemIdentifier();\n    \n    if (name == null || name.isEmpty()) {\n        name = \"\"; // Set to empty string as per spec\n    }\n    if (publicIdentifier == null) {\n        publicIdentifier = \"\"; // Set to empty string as per spec\n    }\n    if (systemIdentifier == null) {\n        systemIdentifier = \"\"; // Set to empty string as per spec\n    }\n    \n    DocumentType doctypeNode = new DocumentType(name, publicIdentifier, systemIdentifier, baseUri);\n    insertNode(doctypeNode);\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -15.58613545723844,
      "mean_entropy": -0.10899395424642265
    },
    {
      "patch": "\n    void insert(Token.Doctype d) {\n        String name = d.getName();\n        if (name.isEmpty()) {\n            name = null;\n        }\n        DocumentType doctypeNode = new DocumentType(name, d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -3.5150786375923495,
      "mean_entropy": -0.05407813288603615
    },
    {
      "patch": "\n    void insert(Token.Doctype d) {\n        String name = d.getName();\n        if (name.isEmpty()) {\n            name = null; // Mark as missing\n        }\n        DocumentType doctypeNode = new DocumentType(name, d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -6.34731095471003,
      "mean_entropy": -0.09067587078157187
    },
    {
      "patch": "\n    void insert(Token.Doctype d) {\n        String name = d.getName();\n        if (name.isEmpty()) {\n            name = null;\n        }\n        DocumentType doctypeNode = new DocumentType(name, d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -3.5150786375923495,
      "mean_entropy": -0.05407813288603615
    },
    {
      "patch": "\nvoid insert(Token.Doctype d) {\n    String name = d.getName();\n    if (name.isEmpty()) {\n        name = null;\n    }\n    DocumentType doctypeNode = new DocumentType(name, d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n    insertNode(doctypeNode);\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -3.1143791448065703,
      "mean_entropy": -0.049434589600104294
    },
    {
      "patch": "\n    void insert(Token.Doctype d) {\n        String name = d.getName().isEmpty() ? null : d.getName();\n        DocumentType doctypeNode = new DocumentType(name, d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -3.0764011181801996,
      "mean_entropy": -0.0521423918335627
    },
    {
      "patch": "\n    void insert(Token.Doctype d) {\n        if (d.getName().isEmpty()) {\n            DocumentType doctypeNode = new DocumentType(null, d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n            insertNode(doctypeNode);\n        } else {\n            DocumentType doctypeNode = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n            insertNode(doctypeNode);\n        }\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -5.282364759565254,
      "mean_entropy": -0.05741700825614406
    },
    {
      "patch": "\nvoid insert(Token.Doctype d) {\n    String name = (d.getName().isEmpty()) ? null : d.getName();\n    DocumentType doctypeNode = new DocumentType(name, d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n    insertNode(doctypeNode);\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -6.299556640429581,
      "mean_entropy": -0.10861304552464796
    },
    {
      "patch": "\n    void insert(Token.Doctype d) {\n        String name = d.getName().isEmpty() ? null : d.getName();\n        DocumentType doctypeNode = new DocumentType(name, d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -3.0764011181801996,
      "mean_entropy": -0.0521423918335627
    },
    {
      "patch": "\n    void insert(Token.Doctype d) {\n        String name = d.getName().isEmpty() ? null : d.getName();\n        DocumentType doctypeNode = new DocumentType(name, d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n        insertNode(doctypeNode);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -2.8709764320253504,
      "mean_entropy": -0.04866061749195509
    },
    {
      "patch": "\n    void insert(Token.Doctype d) {\n        String name = d.getName() != null ? d.getName() : \"\";\n        String publicIdentifier = d.getPublicIdentifier() != null ? d.getPublicIdentifier() : \"\";\n        String systemIdentifier = d.getSystemIdentifier() != null ? d.getSystemIdentifier() : \"\";\n        \n        DocumentType doctypeNode = new DocumentType(name, publicIdentifier, systemIdentifier, baseUri);\n        insertNode(doctypeNode);\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 17,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
        [
          "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName",
          "org.jsoup.parser.HtmlParserTest::handlesInvalidDoctypes"
        ]
      ],
      "sum_entropy": -5.416698350222453,
      "mean_entropy": -0.05642394114815055
    }
  ],
  "Jsoup_78": [
    {
      "patch": "\n    public static void main(String... args) {\n        try {\n            Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n            final String url = args[0];\n            final String selector = args.length == 2 ? args[1] : null;\n\n            // fetch the specified URL and parse to a HTML DOM\n            Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n            HtmlToPlainText formatter = new HtmlToPlainText();\n\n            if (selector != null) {\n                Elements elements = doc.select(selector); // get each element that matches the CSS selector\n                for (Element element : elements) {\n                    String plainText = formatter.getPlainText(element); // format that element to plain text\n                    System.out.println(plainText);\n                }\n            } else { // format the whole doc\n                String plainText = formatter.getPlainText(doc);\n                System.out.println(plainText);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -3.6419232154322994,
      "mean_entropy": -0.01604371460542863
    },
    {
      "patch": "\n    public static void main(String... args) throws IOException {\n        Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n        final String url = args[0];\n        final String selector = args.length == 2 ? args[1] : null;\n\n        // fetch the specified URL and parse to a HTML DOM\n        Document doc = Jsoup.connect(url).userAgent(\"Mozilla/5.0\").timeout(5000).get(); // Provide a default user agent and timeout\n\n        HtmlToPlainText formatter = new HtmlToPlainText();\n\n        if (selector != null) {\n            Elements elements = doc.select(selector); // get each element that matches the CSS selector\n            for (Element element : elements) {\n                String plainText = formatter.getPlainText(element); // format that element to plain text\n                System.out.println(plainText);\n            }\n        } else { // format the whole doc\n            String plainText = formatter.getPlainText(doc);\n            System.out.println(plainText);\n        }\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -9.549977694348936,
      "mean_entropy": -0.042070386318717776
    },
    {
      "patch": "\n    public static void main(String... args) throws IOException {\n        Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n        final String url = args[0];\n        final String selector = args.length == 2 ? args[1] : null;\n\n        // fetch the specified URL and parse to a HTML DOM\n        Document doc = Jsoup.connect(url).userAgent(\"Mozilla\").timeout(5000).get(); // Assuming userAgent and timeout are defined appropriately\n\n        HtmlToPlainText formatter = new HtmlToPlainText();\n\n        if (selector != null) {\n            Elements elements = doc.select(selector); // get each element that matches the CSS selector\n            for (Element element : elements) {\n                String plainText = formatter.getPlainText(element); // format that element to plain text\n                System.out.println(plainText);\n            }\n        } else { // format the whole doc\n            String plainText = formatter.getPlainText(doc);\n            System.out.println(plainText);\n        }\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -14.915198852147988,
      "mean_entropy": -0.06688429978541699
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody && hasRequestBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -7.203568530499236,
      "mean_entropy": -0.007298448359168426
    },
    {
      "patch": "\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n        final boolean methodHasBody = req.method().hasBody();\n        final boolean hasRequestBody = req.requestBody() != null;\n        if (!methodHasBody)\n            Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n        // set up the request for execution\n        String mimeBoundary = null;\n        if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n            serialiseRequestUrl(req);\n        else if (methodHasBody)\n            mimeBoundary = setOutputContentType(req);\n\n        long startTime = System.nanoTime();\n        HttpURLConnection conn = createConnection(req);\n        Response res;\n        try {\n            conn.connect();\n            if (conn.getDoOutput())\n                writePost(req, conn.getOutputStream(), mimeBoundary);\n\n            int status = conn.getResponseCode();\n            res = new Response(previousResponse);\n            res.setupFromConnection(conn, previousResponse);\n            res.req = req;\n\n            // redirect if there's a location header (from 3xx, or 201 etc)\n            if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                if (status != HTTP_TEMP_REDIR) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n                    req.requestBody(null);\n                    req.removeHeader(CONTENT_TYPE);\n                }\n\n                String location = res.header(LOCATION);\n                if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                URL redir = StringUtil.resolve(req.url(), location);\n                req.url(encodeUrl(redir));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null\n                    && !req.ignoreContentType()\n                    && !contentType.startsWith(\"text/\")\n                    && !xmlContentTypeRxp.matcher(contentType).matches()\n            )\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            // switch to the XML parser if content type is xml and parser not explicitly set\n            if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                    req.parser(Parser.xmlParser());\n                }\n            }\n\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                res.bodyStream = null;\n                res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                    res.bodyStream = new GZIPInputStream(res.bodyStream);\n                } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                    res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                }\n                res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                ;\n            } else {\n                res.byteData = DataUtil.emptyByteBuffer();\n            }\n        } catch (IOException e) {\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            conn.disconnect();\n            throw e;\n        }\n\n        res.executed = true;\n        return res;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -8.721914269777901,
      "mean_entropy": -0.008827848451192208
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\")) {\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    }\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody) {\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n    }\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody)) {\n        serialiseRequestUrl(req);\n    } else if (methodHasBody) {\n        mimeBoundary = setOutputContentType(req);\n    }\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res = new Response(previousResponse);\n    try {\n        conn.connect();\n        if (conn.getDoOutput()) {\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n        }\n\n        int status = conn.getResponseCode();\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') {\n                location = location.substring(6);\n            }\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors()) {\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n        }\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n        ) {\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n        }\n\n        // switch to the XML parser if content type is xml and parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) {\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout());\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -18.55979946350843,
      "mean_entropy": -0.019999783904642705
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                    throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e) {\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -10.472341454246534,
      "mean_entropy": -0.01063181873527567
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n            && !req.ignoreContentType()\n            && !contentType.startsWith(\"text/\")\n            && !xmlContentTypeRxp.matcher(contentType).matches()\n            )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and not parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                .timeout(startTime, req.timeout())\n            ;\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e){\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -10.774718752655541,
      "mean_entropy": -0.010972218689058596
    },
    {
      "patch": "\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n        final boolean methodHasBody = req.method().hasBody();\n        final boolean hasRequestBody = req.requestBody() != null;\n        if (!methodHasBody)\n            Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n        // set up the request for execution\n        String mimeBoundary = null;\n        if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n            serialiseRequestUrl(req);\n        else if (methodHasBody)\n            mimeBoundary = setOutputContentType(req);\n\n        long startTime = System.nanoTime();\n        HttpURLConnection conn = createConnection(req);\n        Response res;\n        try {\n            conn.connect();\n            if (conn.getDoOutput())\n                writePost(req, conn.getOutputStream(), mimeBoundary);\n\n            int status = conn.getResponseCode();\n            res = new Response(previousResponse);\n            res.setupFromConnection(conn, previousResponse);\n            res.req = req;\n\n            // redirect if there's a location header (from 3xx, or 201 etc)\n            if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                if (status != HTTP_TEMP_REDIR) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n                    req.requestBody(null);\n                    req.removeHeader(CONTENT_TYPE);\n                }\n\n                String location = res.header(LOCATION);\n                if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                URL redir = StringUtil.resolve(req.url(), location);\n                req.url(encodeUrl(redir));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null\n                    && !req.ignoreContentType()\n                    && !contentType.startsWith(\"text/\")\n                    && !xmlContentTypeRxp.matcher(contentType).matches()\n                    )\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            // switch to the XML parser if content type is xml and parser not explicitly set\n            if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                    req.parser(Parser.xmlParser());\n                }\n            }\n\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                res.bodyStream = null;\n                res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                    res.bodyStream = new GZIPInputStream(res.bodyStream);\n                } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                    res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                }\n                res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                ;\n            } else {\n                res.byteData = DataUtil.emptyByteBuffer();\n            }\n        } catch (IOException e) {\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            conn.disconnect();\n            throw e;\n        }\n\n        res.executed = true;\n        return res;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -8.747996269178625,
      "mean_entropy": -0.008854247236010753
    },
    {
      "patch": "\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n        final boolean methodHasBody = req.method().hasBody();\n        final boolean hasRequestBody = req.requestBody() != null;\n        if (!methodHasBody && hasRequestBody)\n            throw new IllegalArgumentException(\"Cannot set a request body for HTTP method \" + req.method());\n\n        // set up the request for execution\n        String mimeBoundary = null;\n        if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n            serialiseRequestUrl(req);\n        else if (methodHasBody)\n            mimeBoundary = setOutputContentType(req);\n\n        long startTime = System.nanoTime();\n        HttpURLConnection conn = createConnection(req);\n        Response res;\n        try {\n            conn.connect();\n            if (conn.getDoOutput())\n                writePost(req, conn.getOutputStream(), mimeBoundary);\n\n            int status = conn.getResponseCode();\n            res = new Response(previousResponse);\n            res.setupFromConnection(conn, previousResponse);\n            res.req = req;\n\n            // redirect if there's a location header (from 3xx, or 201 etc)\n            if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                if (status != HTTP_TEMP_REDIR) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n                    req.requestBody(null);\n                    req.removeHeader(CONTENT_TYPE);\n                }\n\n                String location = res.header(LOCATION);\n                if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                URL redir = StringUtil.resolve(req.url(), location);\n                req.url(encodeUrl(redir));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null\n                    && !req.ignoreContentType()\n                    && !contentType.startsWith(\"text/\")\n                    && !xmlContentTypeRxp.matcher(contentType).matches()\n                    )\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            // switch to the XML parser if content type is xml and parser not explicitly set\n            if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                // only flip it if an HttpConnection.Request (i.e. don't presume other impls want it):\n                if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                    req.parser(Parser.xmlParser());\n                }\n            }\n\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                res.bodyStream = null;\n                res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                    res.bodyStream = new GZIPInputStream(res.bodyStream);\n                } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                    res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                }\n                res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout());\n            } else {\n                res.byteData = DataUtil.emptyByteBuffer();\n            }\n        } catch (IOException e) {\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            conn.disconnect();\n            throw e;\n        }\n\n        res.executed = true;\n        return res;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -15.836590487738405,
      "mean_entropy": -0.016126874223766196
    },
    {
      "patch": "\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n        final boolean methodHasBody = req.method().hasBody();\n        final boolean hasRequestBody = req.requestBody() != null;\n        if (!methodHasBody)\n            Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n        // set up the request for execution\n        String mimeBoundary = null;\n        if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n            serialiseRequestUrl(req);\n        else if (methodHasBody)\n            mimeBoundary = setOutputContentType(req);\n\n        long startTime = System.nanoTime();\n        HttpURLConnection conn = createConnection(req);\n        Response res;\n        try {\n            conn.connect();\n            if (conn.getDoOutput())\n                writePost(req, conn.getOutputStream(), mimeBoundary);\n\n            int status = conn.getResponseCode();\n            res = new Response(previousResponse);\n            res.setupFromConnection(conn, previousResponse);\n            res.req = req;\n\n            // redirect if there's a location header (from 3xx, or 201 etc)\n            if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                if (status != HTTP_TEMP_REDIR) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n                    req.requestBody(null);\n                    req.removeHeader(CONTENT_TYPE);\n                }\n\n                String location = res.header(LOCATION);\n                if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                URL redir = StringUtil.resolve(req.url(), location);\n                req.url(encodeUrl(redir));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null\n                    && !req.ignoreContentType()\n                    && !contentType.startsWith(\"text/\")\n                    && !contentType.startsWith(\"application/xml\")\n                    && !contentType.startsWith(\"application/xhtml+xml\")\n            )\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            // switch to the XML parser if content type is xml and parser not explicitly set\n            if (contentType != null && (contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))) {\n                if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                    req.parser(Parser.xmlParser());\n                }\n            }\n\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                res.bodyStream = null;\n                res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                    res.bodyStream = new GZIPInputStream(res.bodyStream);\n                } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                    res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                }\n                res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout());\n            } else {\n                res.byteData = DataUtil.emptyByteBuffer();\n            }\n        } catch (IOException e){\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            conn.disconnect();\n            throw e;\n        }\n\n        res.executed = true;\n        return res;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -13.82372526877777,
      "mean_entropy": -0.01420732298949411
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -6.0017741020327415,
      "mean_entropy": -0.006105568771142158
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n                )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) {\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout());\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -13.12182627235431,
      "mean_entropy": -0.014419589310279462
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n        )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout())\n            ;\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -7.46552640090953,
      "mean_entropy": -0.007602369043696059
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead",
        [
          "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead"
        ]
      ],
      "sum_entropy": -4.675045565924403,
      "mean_entropy": -0.004741425523249902
    }
  ],
  "Jsoup_81": [
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n        )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout())\n            ;\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -7.774590650905648,
      "mean_entropy": -0.007917098422510843
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -4.190507410074607,
      "mean_entropy": -0.004241404261209117
    },
    {
      "patch": "\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n        final boolean methodHasBody = req.method().hasBody();\n        final boolean hasRequestBody = req.requestBody() != null;\n        if (!methodHasBody)\n            Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n        // set up the request for execution\n        String mimeBoundary = null;\n        if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n            serialiseRequestUrl(req);\n        else if (methodHasBody)\n            mimeBoundary = setOutputContentType(req);\n\n        long startTime = System.nanoTime();\n        HttpURLConnection conn = createConnection(req);\n        Response res;\n        try {\n            conn.connect();\n            if (conn.getDoOutput())\n                writePost(req, conn.getOutputStream(), mimeBoundary);\n\n            int status = conn.getResponseCode();\n            res = new Response(previousResponse);\n            res.setupFromConnection(conn, previousResponse);\n            res.req = req;\n\n            // redirect if there's a location header (from 3xx, or 201 etc)\n            if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                if (status != HTTP_TEMP_REDIR) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n                    req.requestBody(null);\n                    req.removeHeader(CONTENT_TYPE);\n                }\n\n                String location = res.header(LOCATION);\n                if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                URL redir = StringUtil.resolve(req.url(), location);\n                req.url(encodeUrl(redir));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null\n                    && !req.ignoreContentType()\n                    && !contentType.startsWith(\"text/\")\n                    && !contentType.startsWith(\"application/xml\")\n                    && !contentType.startsWith(\"application/xhtml+xml\")\n                    )\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            // switch to the XML parser if content type is xml and not parser not explicitly set\n            if (contentType != null && contentType.startsWith(\"application/xml\")) {\n                // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                    req.parser(Parser.xmlParser());\n                }\n            }\n\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                res.bodyStream = null;\n                res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                    res.bodyStream = new GZIPInputStream(res.bodyStream);\n                } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                    res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                }\n                res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                ;\n            } else {\n                res.byteData = DataUtil.emptyByteBuffer();\n            }\n        } catch (IOException e) {\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            conn.disconnect();\n            throw e;\n        }\n\n        res.executed = true;\n        return res;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -12.735225601675953,
      "mean_entropy": -0.01290296413543663
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -5.7259659872613184,
      "mean_entropy": -0.005801383978988164
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\")) {\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    }\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody) {\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n    }\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody)) {\n        serialiseRequestUrl(req);\n    } else if (methodHasBody) {\n        mimeBoundary = setOutputContentType(req);\n    }\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput()) {\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n        }\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HttpURLConnection.HTTP_MOVED_TEMP) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') {\n                location = location.substring(6);\n            }\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors()) {\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n        }\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n        ) {\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n        }\n\n        // switch to the XML parser if content type is xml and parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) {\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout());\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e){\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -17.39732280501042,
      "mean_entropy": -0.01810335359522416
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !contentType.startsWith(\"application/xml\")\n                        && !contentType.startsWith(\"application/xhtml+xml\")\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && contentType.startsWith(\"application/xml\")) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -7.398369380005745,
      "mean_entropy": -0.007503417221101161
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n                )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and not parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                .timeout(startTime, req.timeout());\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e){\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -10.90980941228983,
      "mean_entropy": -0.011087204687286413
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n        )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout());\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -8.41937867444703,
      "mean_entropy": -0.008556279140698201
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\")) {\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    }\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody) {\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n    }\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody)) {\n        serialiseRequestUrl(req);\n    } else if (methodHasBody) {\n        mimeBoundary = setOutputContentType(req);\n    }\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput()) {\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n        }\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') {\n                location = location.substring(6);\n            }\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors()) {\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n        }\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n        ) {\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n        }\n\n        // switch to the XML parser if content type is xml and not parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) {\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                .timeout(startTime, req.timeout());\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -10.876737462495996,
      "mean_entropy": -0.011306379898644485
    },
    {
      "patch": "\nstatic void escape(Appendable accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (Character.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribute val; not needed in html attr val\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else\n                        appendEncoded(accum, escapeMode, codePoint);\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                appendEncoded(accum, escapeMode, codePoint);\n        }\n    }\n}\n\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -5.03783256065783,
      "mean_entropy": -0.009523312969107429
    },
    {
      "patch": "\nstatic void escape(Appendable accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribute value; not needed in html attribute value\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else\n                        appendEncoded(accum, escapeMode, codePoint);\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                appendEncoded(accum, escapeMode, codePoint);\n        }\n    }\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -3.652965848488088,
      "mean_entropy": -0.006931624000926163
    },
    {
      "patch": "\nstatic void escape(Appendable accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (Character.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribue val; not needed in html attr val\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else\n                        appendEncoded(accum, escapeMode, codePoint);\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                appendEncoded(accum, escapeMode, codePoint);\n        }\n    }\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -4.0208025231501106,
      "mean_entropy": -0.007615156293844906
    },
    {
      "patch": "\n    static void escape(Appendable accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else\n                            appendEncoded(accum, escapeMode, codePoint);\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                    accum.append(c);\n                else\n                    appendEncoded(accum, escapeMode, codePoint);\n            }\n        }\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -3.7541610606683693,
      "mean_entropy": -0.007083322755978055
    },
    {
      "patch": "\n    static void escape(Appendable accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (Character.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else\n                            appendEncoded(accum, escapeMode, codePoint);\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                    accum.append(c);\n                else\n                    appendEncoded(accum, escapeMode, codePoint);\n            }\n        }\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -4.274482260425999,
      "mean_entropy": -0.0080650608687283
    },
    {
      "patch": "\nstatic void escape(Appendable accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (Character.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribue val; not needed in html attr val\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else\n                        appendEncoded(accum, escapeMode, codePoint);\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                appendEncoded(accum, escapeMode, codePoint);\n        }\n    }\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -4.0208025231501106,
      "mean_entropy": -0.007615156293844906
    },
    {
      "patch": "\nstatic void escape(Appendable accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (Character.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) {\n                    continue;\n                }\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml) {\n                        accum.append(\"&nbsp;\");\n                    } else {\n                        accum.append(\"&#xa0;\");\n                    }\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribue val; not needed in html attr val\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml) {\n                        accum.append(\"&lt;\");\n                    } else {\n                        accum.append(c);\n                    }\n                    break;\n                case '>':\n                    if (!inAttribute) {\n                        accum.append(\"&gt;\");\n                    } else {\n                        accum.append(c);\n                    }\n                    break;\n                case '\"':\n                    if (inAttribute) {\n                        accum.append(\"&quot;\");\n                    } else {\n                        accum.append(c);\n                    }\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder)) {\n                        accum.append(c);\n                    } else {\n                        appendEncoded(accum, escapeMode, codePoint);\n                    }\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) { // uses fallback encoder for simplicity\n                accum.append(c);\n            } else {\n                appendEncoded(accum, escapeMode, codePoint);\n            }\n        }\n    }\n}\n\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -8.124707371201012,
      "mean_entropy": -0.014586548242730722
    },
    {
      "patch": "\nstatic void escape(Appendable accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribute val; not needed in html attr val\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else\n                        appendEncoded(accum, escapeMode, codePoint);\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                appendEncoded(accum, escapeMode, codePoint);\n        }\n    }\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -3.5099629297865578,
      "mean_entropy": -0.0066602712140162385
    },
    {
      "patch": "\nstatic void escape(Appendable accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribute value; not needed in html attribute value\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else\n                        appendEncoded(accum, escapeMode, codePoint);\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                appendEncoded(accum, escapeMode, codePoint);\n        }\n    }\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -3.652965848488088,
      "mean_entropy": -0.006931624000926163
    },
    {
      "patch": "\nstatic void escape(Appendable accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribute value; not needed in html attribute value\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else\n                        appendEncoded(accum, escapeMode, codePoint);\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                appendEncoded(accum, escapeMode, codePoint);\n        }\n    }\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -3.652965848488088,
      "mean_entropy": -0.006931624000926163
    },
    {
      "patch": "\nstatic void escape(Appendable accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribue val; not needed in html attr val\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else\n                        appendEncoded(accum, escapeMode, codePoint);\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                appendEncoded(accum, escapeMode, codePoint);\n        }\n    }\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -3.8649484311524063,
      "mean_entropy": -0.0073199780893038
    },
    {
      "patch": "\nstatic void escape(Appendable accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribute val; not needed in html attr val\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else\n                        appendEncoded(accum, escapeMode, codePoint);\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                appendEncoded(accum, escapeMode, codePoint);\n        }\n    }\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -3.564365472199476,
      "mean_entropy": -0.0067635018447807895
    },
    {
      "patch": "\nstatic void escape(Appendable accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n    final int length = string.length();\n\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribute value; not needed in html attribute value\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else\n                        appendEncoded(accum, escapeMode, codePoint);\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                accum.append(c);\n            else\n                appendEncoded(accum, escapeMode, codePoint);\n        }\n    }\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -3.7309435877056782,
      "mean_entropy": -0.007079589350485158
    },
    {
      "patch": "\n    static void escape(Appendable accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else\n                            appendEncoded(accum, escapeMode, codePoint);\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                    accum.append(c);\n                else\n                    appendEncoded(accum, escapeMode, codePoint);\n            }\n        }\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration",
        [
          "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration"
        ]
      ],
      "sum_entropy": -3.422342376934207,
      "mean_entropy": -0.00645724976780039
    }
  ],
  "Jsoup_82": [
    {
      "patch": "\npublic static void main(String... args) throws IOException {\n    Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n    final String url = args[0];\n    final String selector = args.length == 2 ? args[1] : null;\n\n    // fetch the specified URL and parse to a HTML DOM\n    Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n    HtmlToPlainText formatter = new HtmlToPlainText();\n\n    if (selector != null) {\n        Elements elements = doc.select(selector); // get each element that matches the CSS selector\n        for (Element element : elements) {\n            String plainText = formatter.getPlainText(element); // format that element to plain text\n            System.out.println(plainText);\n        }\n    } else { // format the whole doc\n        String plainText = formatter.getPlainText(doc);\n        System.out.println(plainText);\n    }\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.0710925070522914,
      "mean_entropy": -0.009862345271677578
    },
    {
      "patch": "\n    public static void main(String... args) throws IOException {\n        Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n        final String url = args[0];\n        final String selector = args.length == 2 ? args[1] : null;\n\n        // fetch the specified URL and parse to a HTML DOM\n        Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n        HtmlToPlainText formatter = new HtmlToPlainText();\n\n        if (selector != null) {\n            Elements elements = doc.select(selector); // get each element that matches the CSS selector\n            for (Element element : elements) {\n                String plainText = formatter.getPlainText(element); // format that element to plain text\n                System.out.println(plainText);\n            }\n        } else { // format the whole doc\n            String plainText = formatter.getPlainText(doc);\n            System.out.println(plainText);\n        }\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.1321850899930626,
      "mean_entropy": -0.010057476839589918
    },
    {
      "patch": "\npublic static void main(String... args) throws IOException {\n    Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n    final String url = args[0];\n    final String selector = args.length == 2 ? args[1] : null;\n\n    // fetch the specified URL and parse to a HTML DOM\n    Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n    HtmlToPlainText formatter = new HtmlToPlainText();\n\n    if (selector != null) {\n        Elements elements = doc.select(selector); // get each element that matches the CSS selector\n        for (Element element : elements) {\n            String plainText = formatter.getPlainText(element); // format that element to plain text\n            System.out.println(plainText);\n        }\n    } else { // format the whole doc\n        String plainText = formatter.getPlainText(doc);\n        System.out.println(plainText);\n    }\n}\n\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.3482157074292918,
      "mean_entropy": -0.015793470318062698
    },
    {
      "patch": "\n    public static void main(String... args) throws IOException {\n        Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n        final String url = args[0];\n        final String selector = args.length == 2 ? args[1] : null;\n\n        // fetch the specified URL and parse to a HTML DOM\n        Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n        HtmlToPlainText formatter = new HtmlToPlainText();\n\n        if (selector != null) {\n            Elements elements = doc.select(selector); // get each element that matches the CSS selector\n            for (Element element : elements) {\n                String plainText = formatter.getPlainText(element); // format that element to plain text\n                System.out.println(plainText);\n            }\n        } else { // format the whole doc\n            String plainText = formatter.getPlainText(doc);\n            System.out.println(plainText);\n        }\n    }\n\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.4123443496380625,
      "mean_entropy": -0.015945534344103098
    },
    {
      "patch": "\npublic static void main(String... args) throws IOException {\n    Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n    final String url = args[0];\n    final String selector = args.length == 2 ? args[1] : null;\n\n    // fetch the specified URL and parse to a HTML DOM\n    Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n    HtmlToPlainText formatter = new HtmlToPlainText();\n\n    if (selector != null) {\n        Elements elements = doc.select(selector); // get each element that matches the CSS selector\n        for (Element element : elements) {\n            String plainText = formatter.getPlainText(element); // format that element to plain text\n            System.out.println(plainText);\n        }\n    } else { // format the whole doc\n        String plainText = formatter.getPlainText(doc);\n        System.out.println(plainText);\n    }\n}\n\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.3482157074292918,
      "mean_entropy": -0.015793470318062698
    },
    {
      "patch": "\n    public static void main(String... args) throws IOException {\n        Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n        final String url = args[0];\n        final String selector = args.length == 2 ? args[1] : null;\n\n        // fetch the specified URL and parse to a HTML DOM\n        Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n        HtmlToPlainText formatter = new HtmlToPlainText();\n\n        if (selector != null) {\n            Elements elements = doc.select(selector); // get each element that matches the CSS selector\n            for (Element element : elements) {\n                String plainText = formatter.getPlainText(element); // format that element to plain text\n                System.out.println(plainText);\n            }\n        } else { // format the whole doc\n            String plainText = formatter.getPlainText(doc);\n            System.out.println(plainText);\n        }\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.1321850899930626,
      "mean_entropy": -0.010057476839589918
    },
    {
      "patch": "\npublic static void main(String... args) throws IOException {\n    Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n    final String url = args[0];\n    final String selector = args.length == 2 ? args[1] : null;\n\n    // fetch the specified URL and parse to a HTML DOM\n    Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n    HtmlToPlainText formatter = new HtmlToPlainText();\n\n    if (selector != null) {\n        Elements elements = doc.select(selector); // get each element that matches the CSS selector\n        for (Element element : elements) {\n            String plainText = formatter.getPlainText(element); // format that element to plain text\n            System.out.println(plainText);\n        }\n    } else { // format the whole doc\n        String plainText = formatter.getPlainText(doc);\n        System.out.println(plainText);\n    }\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.0710925070522914,
      "mean_entropy": -0.009862345271677578
    },
    {
      "patch": "\npublic static void main(String... args) throws IOException {\n    Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n    final String url = args[0];\n    final String selector = args.length == 2 ? args[1] : null;\n\n    // fetch the specified URL and parse to a HTML DOM\n    Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n    HtmlToPlainText formatter = new HtmlToPlainText();\n\n    if (selector != null) {\n        Elements elements = doc.select(selector); // get each element that matches the CSS selector\n        for (Element element : elements) {\n            String plainText = formatter.getPlainText(element); // format that element to plain text\n            System.out.println(plainText);\n        }\n    } else { // format the whole doc\n        String plainText = formatter.getPlainText(doc);\n        System.out.println(plainText);\n    }\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.0710925070522914,
      "mean_entropy": -0.009862345271677578
    },
    {
      "patch": "\npublic static void main(String... args) throws IOException {\n    Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n    final String url = args[0];\n    final String selector = args.length == 2 ? args[1] : null;\n\n    // fetch the specified URL and parse to a HTML DOM\n    Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n    HtmlToPlainText formatter = new HtmlToPlainText();\n\n    if (selector != null) {\n        Elements elements = doc.select(selector); // get each element that matches the CSS selector\n        for (Element element : elements) {\n            String plainText = formatter.getPlainText(element); // format that element to plain text\n            System.out.println(plainText);\n        }\n    } else { // format the whole doc\n        String plainText = formatter.getPlainText(doc);\n        System.out.println(plainText);\n    }\n}\n\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.3482157074292918,
      "mean_entropy": -0.015793470318062698
    },
    {
      "patch": "\npublic static void main(String... args) throws IOException {\n    Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n    final String url = args[0];\n    final String selector = args.length == 2 ? args[1] : null;\n\n    // fetch the specified URL and parse to a HTML DOM\n    Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n    HtmlToPlainText formatter = new HtmlToPlainText();\n\n    if (selector != null) {\n        Elements elements = doc.select(selector); // get each element that matches the CSS selector\n        for (Element element : elements) {\n            String plainText = formatter.getPlainText(element); // format that element to plain text\n            System.out.println(plainText);\n        }\n    } else { // format the whole doc\n        String plainText = formatter.getPlainText(doc);\n        System.out.println(plainText);\n    }\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.31728166725773,
      "mean_entropy": -0.01103467460598919
    },
    {
      "patch": "\npublic static void main(String... args) throws IOException {\n    Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n    final String url = args[0];\n    final String selector = args.length == 2 ? args[1] : null;\n\n    // fetch the specified URL and parse to a HTML DOM\n    Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n    HtmlToPlainText formatter = new HtmlToPlainText();\n\n    if (selector != null) {\n        Elements elements = doc.select(selector); // get each element that matches the CSS selector\n        for (Element element : elements) {\n            String plainText = formatter.getPlainText(element); // format that element to plain text\n            System.out.println(plainText);\n        }\n    } else { // format the whole doc\n        String plainText = formatter.getPlainText(doc);\n        System.out.println(plainText);\n    }\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.31728166725773,
      "mean_entropy": -0.01103467460598919
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n                )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and not parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                .timeout(startTime, req.timeout())\n            ;\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e){\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.4135908505051313,
      "mean_entropy": -0.003490379192745533
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.170894115945908,
      "mean_entropy": -0.003235606240761131
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n                )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and not parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                .timeout(startTime, req.timeout())\n            ;\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e){\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.4135908505051313,
      "mean_entropy": -0.003490379192745533
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n                )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and not parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                .timeout(startTime, req.timeout())\n            ;\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e){\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -4.809365427371438,
      "mean_entropy": -0.004907515742215754
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\")) {\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    }\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody) {\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n    }\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody)) {\n        serialiseRequestUrl(req);\n    } else if (methodHasBody) {\n        mimeBoundary = setOutputContentType(req);\n    }\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput()) {\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n        }\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location.startsWith(\"http:/\") && location.charAt(6) != '/') { // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            }\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors()) {\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n        }\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n        ) {\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n        }\n\n        // switch to the XML parser if content type is xml and parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout());\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -7.6986286318979245,
      "mean_entropy": -0.007706334966864789
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.279415970264111,
      "mean_entropy": -0.0033395274646274044
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res = null;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -6.183718390960573,
      "mean_entropy": -0.006297065571242946
    },
    {
      "patch": "\n//The fixed function:\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -6.789822749069243,
      "mean_entropy": -0.006893221065044917
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.279415970264111,
      "mean_entropy": -0.0033395274646274044
    },
    {
      "patch": "\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n        final boolean methodHasBody = req.method().hasBody();\n        final boolean hasRequestBody = req.requestBody() != null;\n        if (!methodHasBody)\n            Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n        // set up the request for execution\n        String mimeBoundary = null;\n        if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n            serialiseRequestUrl(req);\n        else if (methodHasBody)\n            mimeBoundary = setOutputContentType(req);\n\n        long startTime = System.nanoTime();\n        HttpURLConnection conn = createConnection(req);\n        Response res;\n        try {\n            conn.connect();\n            if (conn.getDoOutput())\n                writePost(req, conn.getOutputStream(), mimeBoundary);\n\n            int status = conn.getResponseCode();\n            res = new Response(previousResponse);\n            res.setupFromConnection(conn, previousResponse);\n            res.req = req;\n\n            // redirect if there's a location header (from 3xx, or 201 etc)\n            if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                if (status != HTTP_TEMP_REDIR) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n                    req.requestBody(null);\n                    req.removeHeader(CONTENT_TYPE);\n                }\n\n                String location = res.header(LOCATION);\n                if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                URL redir = StringUtil.resolve(req.url(), location);\n                req.url(encodeUrl(redir));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null\n                    && !req.ignoreContentType()\n                    && !contentType.startsWith(\"text/\")\n                    && !xmlContentTypeRxp.matcher(contentType).matches()\n                    )\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            // switch to the XML parser if content type is xml and not parser not explicitly set\n            if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                    req.parser(Parser.xmlParser());\n                }\n            }\n\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                res.bodyStream = null;\n                res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                    res.bodyStream = new GZIPInputStream(res.bodyStream);\n                } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                    res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                }\n                res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                ;\n            } else {\n                res.byteData = DataUtil.emptyByteBuffer();\n            }\n        } catch (IOException e) {\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            conn.disconnect();\n            throw e;\n        }\n\n        res.executed = true;\n        return res;\n    }\n\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -10.198916454164998,
      "mean_entropy": -0.010333248687097263
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.279415970264111,
      "mean_entropy": -0.0033395274646274044
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n                )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and not parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                .timeout(startTime, req.timeout())\n            ;\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e){\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.4135908505051313,
      "mean_entropy": -0.003490379192745533
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.170894115945908,
      "mean_entropy": -0.003235606240761131
    },
    {
      "patch": "\n    //The fixed code:\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n        final boolean methodHasBody = req.method().hasBody();\n        final boolean hasRequestBody = req.requestBody() != null;\n        if (!methodHasBody)\n            Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n        // set up the request for execution\n        String mimeBoundary = null;\n        if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n            serialiseRequestUrl(req);\n        else if (methodHasBody)\n            mimeBoundary = setOutputContentType(req);\n\n        long startTime = System.nanoTime();\n        HttpURLConnection conn = createConnection(req);\n        Response res = null;\n        try {\n            conn.connect();\n            if (conn.getDoOutput())\n                writePost(req, conn.getOutputStream(), mimeBoundary);\n\n            int status = conn.getResponseCode();\n            res = new Response(previousResponse);\n            res.setupFromConnection(conn, previousResponse);\n            res.req = req;\n\n            // redirect if there's a location header (from 3xx, or 201 etc)\n            if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                if (status != HTTP_TEMP_REDIR) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n                    req.requestBody(null);\n                    req.removeHeader(CONTENT_TYPE);\n                }\n\n                String location = res.header(LOCATION);\n                if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                URL redir = StringUtil.resolve(req.url(), location);\n                req.url(encodeUrl(redir));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null\n                    && !req.ignoreContentType()\n                    && !contentType.startsWith(\"text/\")\n                    && !xmlContentTypeRxp.matcher(contentType).matches()\n            )\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            // switch to the XML parser if content type is xml and not parser not explicitly set\n            if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                    req.parser(Parser.xmlParser());\n                }\n            }\n\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                res.bodyStream = null;\n                res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                    res.bodyStream = new GZIPInputStream(res.bodyStream);\n                } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                    res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                }\n                res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                ;\n            } else {\n                res.byteData = DataUtil.emptyByteBuffer();\n            }\n        } catch (IOException e) {\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            if (conn != null) {\n                conn.disconnect();\n            }\n            throw e;\n        }\n\n        if (res != null) {\n            res.executed = true;\n        }\n        return res;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -14.085854426706895,
      "mean_entropy": -0.013960212514080174
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null && !req.ignoreContentType() && !contentType.startsWith(\"text/\") && !xmlContentTypeRxp.matcher(contentType).matches())\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and not parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout());\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -8.641340996253339,
      "mean_entropy": -0.008899424300981812
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                    throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                            .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                            .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e) {\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -6.411941130828124,
      "mean_entropy": -0.0065361275543609825
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -3.0899937924529675,
      "mean_entropy": -0.00315305489025813
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -4.478581034217655,
      "mean_entropy": -0.0045514034900585925
    },
    {
      "patch": "\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.5516366846065006,
      "mean_entropy": -0.06714833380543422
    },
    {
      "patch": "\n/**\n * Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n * <p>\n * The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n *\n * @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n * @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n * @return The parsed HTML.\n *\n * @throws MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n * @throws SocketTimeoutException if the connection times out\n * @throws IOException if a connection or read error occurs\n *\n * @see #connect(String)\n */\npublic static Document parse(URL url, int timeoutMillis) throws IOException {\n    Connection con = HttpConnection.connect(url);\n    con.timeout(timeoutMillis);\n    return con.get();\n}\n\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -8.467846473274347,
      "mean_entropy": -0.03414454223094495
    },
    {
      "patch": "\n    /**\n     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     <p>\n     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     @return The parsed HTML.\n\n     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     @throws java.net.SocketTimeoutException if the connection times out\n     @throws IOException if a connection or read error occurs\n\n     @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -1.7689706581779188,
      "mean_entropy": -0.006991978886078731
    },
    {
      "patch": "\n    /**\n     * Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     * <p>\n     * The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n     *\n     * @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     * @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     * @return The parsed HTML.\n     *\n     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     * @throws HttpStatusException            if the response is not OK and HTTP response errors are not ignored\n     * @throws UnsupportedMimeTypeException    if the response mime type is not supported and those errors are not ignored\n     * @throws java.net.SocketTimeoutException if the connection times out\n     * @throws IOException                    if a connection or read error occurs\n     *\n     * @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -7.441016524185984,
      "mean_entropy": -0.027256470784564044
    },
    {
      "patch": "\n    /**\n     * Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     * <p>\n     * The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n     *\n     * @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     * @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     * @return The parsed HTML.\n     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     * @throws java.net.SocketTimeoutException if the connection times out\n     * @throws IOException if a connection or read error occurs\n     * @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -5.561617357756541,
      "mean_entropy": -0.020752303573718437
    },
    {
      "patch": "\n    /**\n     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     <p>\n     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     @return The parsed HTML.\n\n     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     @throws java.net.SocketTimeoutException if the connection times out\n     @throws IOException if a connection or read error occurs\n\n     @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -1.7689706581779188,
      "mean_entropy": -0.006991978886078731
    },
    {
      "patch": "\n    /**\n     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     <p>\n     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     @return The parsed HTML.\n\n     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     @throws java.net.SocketTimeoutException if the connection times out\n     @throws IOException if a connection or read error occurs\n\n     @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -1.7689706581779188,
      "mean_entropy": -0.006991978886078731
    },
    {
      "patch": "\n    /**\n     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     <p>\n     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     @return The parsed HTML.\n\n     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     @throws java.net.SocketTimeoutException if the connection times out\n     @throws IOException if a connection or read error occurs\n\n     @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -1.7689706581779188,
      "mean_entropy": -0.006991978886078731
    },
    {
      "patch": "\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.5516366846065006,
      "mean_entropy": -0.06714833380543422
    },
    {
      "patch": "\n/**\n Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n <p>\n The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n @return The parsed HTML.\n\n @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n @throws java.net.SocketTimeoutException if the connection times out\n @throws IOException if a connection or read error occurs\n\n @see #connect(String)\n */\npublic static Document parse(URL url, int timeoutMillis) throws IOException {\n    Connection con = HttpConnection.connect(url.toString());\n    con.timeout(timeoutMillis);\n    return con.get();\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -4.109613459993783,
      "mean_entropy": -0.01726728344535203
    },
    {
      "patch": "\n    /**\n     * Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     * <p>\n     * The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n     *\n     * @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     * @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     * @return The parsed HTML.\n     *\n     * @throws java.net.MalformedURLException        if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     * @throws HttpStatusException                   if the response is not OK and HTTP response errors are not ignored\n     * @throws UnsupportedMimeTypeException          if the response mime type is not supported and those errors are not ignored\n     * @throws java.net.SocketTimeoutException       if the connection times out\n     * @throws IOException                           if a connection or read error occurs\n     *\n     * @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -5.086998416723739,
      "mean_entropy": -0.018364615222829384
    },
    {
      "patch": "\n    /**\n     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     <p>\n     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     @return The parsed HTML.\n\n     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     @throws java.net.SocketTimeoutException if the connection times out\n     @throws IOException if a connection or read error occurs\n\n     @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -1.7689706581779188,
      "mean_entropy": -0.006991978886078731
    },
    {
      "patch": "\n/**\n * Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n * <p>\n * The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n *\n * @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n * @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n * @return The parsed HTML.\n *\n * @throws java.net.MalformedURLException      if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n * @throws HttpStatusException                 if the response is not OK and HTTP response errors are not ignored\n * @throws UnsupportedMimeTypeException        if the response mime type is not supported and those errors are not ignored\n * @throws java.net.SocketTimeoutException     if the connection times out\n * @throws IOException                         if a connection or read error occurs\n *\n * @see #connect(String)\n */\npublic static Document parse(URL url, int timeoutMillis) throws IOException {\n    Connection con = HttpConnection.connect(url);\n    con.timeout(timeoutMillis);\n    return con.get();\n}\n\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -7.568620498855875,
      "mean_entropy": -0.02933573836765843
    },
    {
      "patch": "\n    /**\n     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     <p>\n     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     @return The parsed HTML.\n\n     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     @throws java.net.SocketTimeoutException if the connection times out\n     @throws IOException if a connection or read error occurs\n\n     @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url.toString());\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.850855118410418,
      "mean_entropy": -0.011223839048859914
    },
    {
      "patch": "\n/**\n Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n <p>\n The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n @return The parsed HTML.\n\n @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n @throws java.net.SocketTimeoutException if the connection times out\n @throws IOException if a connection or read error occurs\n\n @see #connect(String)\n */\npublic static Document parse(URL url, int timeoutMillis) throws IOException {\n    Connection con = HttpConnection.connect(url.toString());\n    con.timeout(timeoutMillis);\n    return con.get();\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -4.975379812106646,
      "mean_entropy": -0.020904957193725406
    },
    {
      "patch": "\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.4839525287793,
      "mean_entropy": -0.06536717180998157
    },
    {
      "patch": "\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -2.4839525287793,
      "mean_entropy": -0.06536717180998157
    },
    {
      "patch": "\n    /**\n     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     <p>\n     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     @return The parsed HTML.\n\n     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     @throws java.net.SocketTimeoutException if the connection times out\n     @throws IOException if a connection or read error occurs\n\n     @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 7,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode",
        [
          "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode"
        ]
      ],
      "sum_entropy": -1.8771392546180803,
      "mean_entropy": -0.007419522745526009
    }
  ],
  "Jsoup_86": [
    {
      "patch": "\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) // empty body\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n\n    if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null; // if not found, will keep utf-8 as best attempt\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        if (!charset.canEncode()) {\n            // some charsets can read but not encode; switch to an encodable charset and update the meta el\n            doc.charset(Charset.forName(defaultCharset));\n        }\n    }\n    input.close();\n    return doc;\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.301925231901772,
      "mean_entropy": -0.003889193441580414
    },
    {
      "patch": "\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.0863568386977978,
      "mean_entropy": -0.003622484552462204
    },
    {
      "patch": "\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n    if (input == null) // empty body\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n\n    if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null; // if not found, will keep utf-8 as best attempt\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        if (!charset.canEncode()) {\n            // some charsets can read but not encode; switch to an encodable charset and update the meta el\n            doc.charset(Charset.forName(defaultCharset));\n        }\n    }\n    input.close();\n    return doc;\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.1206957762114724,
      "mean_entropy": -0.0036714067955429088
    },
    {
      "patch": "\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n\n    if (charsetName == null) {\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n            } else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration()) {\n                    decl = comment.asXmlDeclaration();\n                }\n            }\n            if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n                foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) {\n            reader.skip(1);\n        }\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        if (!charset.canEncode()) {\n            doc.charset(Charset.forName(defaultCharset));\n        }\n    }\n    input.close();\n    return doc;\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -6.862097294309618,
      "mean_entropy": -0.010622441632058232
    },
    {
      "patch": "\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.0863568386977978,
      "mean_entropy": -0.003622484552462204
    },
    {
      "patch": "\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.944483020832714,
      "mean_entropy": -0.004635115183117173
    },
    {
      "patch": "\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) // empty body\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n\n    if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null; // if not found, will keep utf-8 as best attempt\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        if (!charset.canEncode()) {\n            // some charsets can read but not encode; switch to an encodable charset and update the meta el\n            doc.charset(Charset.forName(defaultCharset));\n        }\n    }\n    input.close();\n    return doc;\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.301925231901772,
      "mean_entropy": -0.003889193441580414
    },
    {
      "patch": "\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.0863568386977978,
      "mean_entropy": -0.003622484552462204
    },
    {
      "patch": "\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.944483020832714,
      "mean_entropy": -0.004635115183117173
    },
    {
      "patch": "\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.0863568386977978,
      "mean_entropy": -0.003622484552462204
    },
    {
      "patch": "\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) { // empty body\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n\n    if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null; // if not found, will keep utf-8 as best attempt\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n            } else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration()) {\n                    decl = comment.asXmlDeclaration();\n                }\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                    foundCharset = decl.attr(\"encoding\");\n                }\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) { // creating the buffered reader ignores the input pos, so must skip here\n            reader.skip(1);\n        }\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        if (!charset.canEncode()) {\n            // some charsets can read but not encode; switch to an encodable charset and update the meta el\n            doc.charset(Charset.forName(defaultCharset));\n        }\n    }\n    input.close();\n    return doc;\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -4.4992332707815565,
      "mean_entropy": -0.005124411470138447
    },
    {
      "patch": "\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                if (first instanceof XmlDeclaration) {\n                    XmlDeclaration decl = (XmlDeclaration) first;\n                    if (decl.name().equalsIgnoreCase(\"xml\")) {\n                        foundCharset = decl.attr(\"encoding\");\n                    }\n                } else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration()) {\n                        XmlDeclaration decl = comment.asXmlDeclaration();\n                        if (decl.name().equalsIgnoreCase(\"xml\")) {\n                            foundCharset = decl.attr(\"encoding\");\n                        }\n                    }\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -6.47363596220604,
      "mean_entropy": -0.007449523546842394
    },
    {
      "patch": "\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                if (first instanceof XmlDeclaration) {\n                    XmlDeclaration decl = (XmlDeclaration) first;\n                    if (decl.name().equalsIgnoreCase(\"xml\")) {\n                        foundCharset = decl.attr(\"encoding\");\n                    }\n                } else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration()) {\n                        XmlDeclaration decl = comment.asXmlDeclaration();\n                        if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n                            foundCharset = decl.attr(\"encoding\");\n                        }\n                    }\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -7.916426147078137,
      "mean_entropy": -0.009068071187947465
    },
    {
      "patch": "\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n\n    if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null; // if not found, will keep utf-8 as best attempt\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n            } else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration()) {\n                    decl = comment.asXmlDeclaration();\n                }\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                    foundCharset = decl.attr(\"encoding\");\n                }\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) { // creating the buffered reader ignores the input pos, so must skip here\n            reader.skip(1);\n        }\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        if (!charset.canEncode()) {\n            // some charsets can read but not encode; switch to an encodable charset and update the meta el\n            doc.charset(Charset.forName(defaultCharset));\n        }\n    }\n    input.close();\n    return doc;\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -6.275338712712544,
      "mean_entropy": -0.007180021410426251
    },
    {
      "patch": "\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -5.209738000876523,
      "mean_entropy": -0.006121901293626936
    },
    {
      "patch": "\n    /**\n     * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     * (non-HTML) parser.\n     *\n     * @param in          input stream to read. Make sure to close it after parsing.\n     * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n     * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser      alternate {@link Parser#xmlParser()} parser to use.\n     * @return sane HTML\n     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -2.151441207421451,
      "mean_entropy": -0.009394939770399348
    },
    {
      "patch": "\n    /**\n     * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     * (non-HTML) parser.\n     *\n     * @param in          input stream to read. Make sure to close it after parsing.\n     * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n     * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n     * @return sane HTML\n     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -1.5986427220042505,
      "mean_entropy": -0.006950620530453263
    },
    {
      "patch": "\n    /**\n     * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     * (non-HTML) parser.\n     *\n     * @param in          input stream to read. Make sure to close it after parsing.\n     * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n     * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n     * @return sane HTML\n     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -1.5986427220042505,
      "mean_entropy": -0.006950620530453263
    },
    {
      "patch": "\n    /**\n     * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     * (non-HTML) parser.\n     *\n     * @param in          input stream to read. Make sure to close it after parsing.\n     * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n     * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n     * @return sane HTML\n     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -1.5986427220042505,
      "mean_entropy": -0.006950620530453263
    },
    {
      "patch": "\n/**\n * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n * (non-HTML) parser.\n *\n * @param in          input stream to read. Make sure to close it after parsing.\n * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n * @return sane HTML\n * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n */\npublic static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n    return DataUtil.load(in, charsetName, baseUri, parser);\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.4609437940266794,
      "mean_entropy": -0.0160228879353087
    },
    {
      "patch": "\n    /**\n     * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     * (non-HTML) parser.\n     *\n     * @param in          input stream to read. Make sure to close it after parsing.\n     * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n     * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n     * @return sane HTML\n     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -1.5986427220042505,
      "mean_entropy": -0.006950620530453263
    },
    {
      "patch": "\n/**\n * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n * (non-HTML) parser.\n *\n * @param in          input stream to read. Make sure to close it after parsing.\n * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n * @return sane HTML\n *\n * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n */\npublic static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n    return DataUtil.load(in, charsetName, baseUri, parser);\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.67331060167317,
      "mean_entropy": -0.01692769862522198
    },
    {
      "patch": "\n    /**\n     * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     * (non-HTML) parser.\n     *\n     * @param in          input stream to read. Make sure to close it after parsing.\n     * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n     * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n     * @return sane HTML\n     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -1.5986427220042505,
      "mean_entropy": -0.006950620530453263
    },
    {
      "patch": "\n    /**\n     * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     * (non-HTML) parser.\n     *\n     * @param in          input stream to read. Make sure to close it after parsing.\n     * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n     * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n     * @return sane HTML\n     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -1.5986427220042505,
      "mean_entropy": -0.006950620530453263
    },
    {
      "patch": "\n    /**\n     * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     * (non-HTML) parser.\n     *\n     * @param in          input stream to read. Make sure to close it after parsing.\n     * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n     * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n     * @return sane HTML\n     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -1.5986427220042505,
      "mean_entropy": -0.006950620530453263
    },
    {
      "patch": "\n    /**\n     * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     * (non-HTML) parser.\n     *\n     * @param in          input stream to read. Make sure to close it after parsing.\n     * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n     * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser      alternate {@link Parser#xmlParser()} parser to use.\n     * @return sane HTML\n     *\n     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -4.275561013945129,
      "mean_entropy": -0.018508922138290602
    },
    {
      "patch": "\n/**\n * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n * (non-HTML) parser.\n *\n * @param in          input stream to read. Make sure to close it after parsing.\n * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n * @return sane HTML\n *\n * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n */\npublic static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n    return DataUtil.load(in, charsetName, baseUri, parser);\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.67331060167317,
      "mean_entropy": -0.01692769862522198
    },
    {
      "patch": "\n    /**\n     * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     * (non-HTML) parser.\n     *\n     * @param in          input stream to read. Make sure to close it after parsing.\n     * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n     * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n     * @return sane HTML\n     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -1.5986427220042505,
      "mean_entropy": -0.006950620530453263
    },
    {
      "patch": "\n/**\n * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n * (non-HTML) parser.\n *\n * @param in          input stream to read. Make sure to close it after parsing.\n * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n * @return sane HTML\n *\n * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n */\npublic static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n    return DataUtil.load(in, charsetName, baseUri, parser);\n}\n\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -5.758054172058789,
      "mean_entropy": -0.02629248480392141
    },
    {
      "patch": "\n/**\n * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n * (non-HTML) parser.\n *\n * @param in          input stream to read. Make sure to close it after parsing.\n * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n * @param parser      alternate {@link Parser#xmlParser() parser} to use.\n * @return sane HTML\n * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n */\npublic static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n    return DataUtil.load(in, charsetName, baseUri, parser);\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.9143903845667887,
      "mean_entropy": -0.018122177706327725
    },
    {
      "patch": "\n    /**\n     * Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     * (non-HTML) parser.\n     *\n     * @param in          input stream to read. Make sure to close it after parsing.\n     * @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     *                    present, or fall back to {@code UTF-8} (which is often safe to do).\n     * @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser      alternate {@link Parser#xmlParser()} parser to use.\n     * @return sane HTML\n     *\n     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -4.2918166071796895,
      "mean_entropy": -0.018579292671773547
    },
    {
      "patch": "\n    /**\n     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     (non-HTML) parser.\n\n     @param in          input stream to read. Make sure to close it after parsing.\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @param parser alternate {@link Parser#xmlParser() parser} to use.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n        try {\n            return DataUtil.load(in, charsetName, baseUri, parser);\n        } catch (IndexOutOfBoundsException e) {\n            System.out.println(\"IndexOutOfBoundsException occurred while parsing the HTML content.\");\n            e.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -10.113634939216567,
      "mean_entropy": -0.03997484165698248
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\")) {\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            }\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody) {\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n            }\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody)) {\n                serialiseRequestUrl(req);\n            } else if (methodHasBody) {\n                mimeBoundary = setOutputContentType(req);\n            }\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput()) {\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n                }\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') { // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    }\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors()) {\n                    throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n                }\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        ) {\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n                }\n\n                // switch to the XML parser if content type is xml and parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                            .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                            .timeout(startTime, req.timeout());\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -10.0475935789213,
      "mean_entropy": -0.009869934753360805
    },
    {
      "patch": "\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        Validate.notNull(req.url(), \"URL must be specified to connect\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n        final boolean methodHasBody = req.method().hasBody();\n        final boolean hasRequestBody = req.requestBody() != null;\n        if (!methodHasBody)\n            Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n        // set up the request for execution\n        String mimeBoundary = null;\n        if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n            serialiseRequestUrl(req);\n        else if (methodHasBody)\n            mimeBoundary = setOutputContentType(req);\n\n        long startTime = System.nanoTime();\n        HttpURLConnection conn = createConnection(req);\n        Response res;\n        try {\n            conn.connect();\n            if (conn.getDoOutput())\n                writePost(req, conn.getOutputStream(), mimeBoundary);\n\n            int status = conn.getResponseCode();\n            res = new Response(previousResponse);\n            res.setupFromConnection(conn, previousResponse);\n            res.req = req;\n\n            // redirect if there's a location header (from 3xx, or 201 etc)\n            if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                if (status != HTTP_TEMP_REDIR) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n                    req.requestBody(null);\n                    req.removeHeader(CONTENT_TYPE);\n                }\n\n                String location = res.header(LOCATION);\n                if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                URL redir = StringUtil.resolve(req.url(), location);\n                req.url(encodeUrl(redir));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null\n                    && !req.ignoreContentType()\n                    && !contentType.startsWith(\"text/\")\n                    && !contentType.startsWith(\"application/xml\")\n                    && !contentType.startsWith(\"application/xhtml+xml\")\n            )\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            // switch to the XML parser if content type is xml and not parser not explicitly set\n            if (contentType != null && (contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))) {\n                // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                    req.parser(Parser.xmlParser());\n                }\n            }\n\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                res.bodyStream = null;\n                res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                    res.bodyStream = new GZIPInputStream(res.bodyStream);\n                } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                    res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                }\n                res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                ;\n            } else {\n                res.byteData = DataUtil.emptyByteBuffer();\n            }\n        } catch (IOException e) {\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            conn.disconnect();\n            throw e;\n        }\n\n        res.executed = true;\n        return res;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -10.162972289404594,
      "mean_entropy": -0.010102358140561226
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                    throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                            .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                            .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e) {\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -7.630211299317159,
      "mean_entropy": -0.007645502303925009
    },
    {
      "patch": "\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        Validate.notNull(req.url(), \"URL must be specified to connect\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n        final boolean methodHasBody = req.method().hasBody();\n        final boolean hasRequestBody = req.requestBody() != null;\n        if (!methodHasBody)\n            Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n        // set up the request for execution\n        String mimeBoundary = null;\n        if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n            serialiseRequestUrl(req);\n        else if (methodHasBody)\n            mimeBoundary = setOutputContentType(req);\n\n        long startTime = System.nanoTime();\n        HttpURLConnection conn = createConnection(req);\n        Response res;\n        try {\n            conn.connect();\n            if (conn.getDoOutput())\n                writePost(req, conn.getOutputStream(), mimeBoundary);\n\n            int status = conn.getResponseCode();\n            res = new Response(previousResponse);\n            res.setupFromConnection(conn, previousResponse);\n            res.req = req;\n\n            // redirect if there's a location header (from 3xx, or 201 etc)\n            if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                if (status != HTTP_TEMP_REDIR) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n                    req.requestBody(null);\n                    req.removeHeader(CONTENT_TYPE);\n                }\n\n                String location = res.header(LOCATION);\n                if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                URL redir = StringUtil.resolve(req.url(), location);\n                req.url(encodeUrl(redir));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                    throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null\n                    && !req.ignoreContentType()\n                    && !contentType.startsWith(\"text/\")\n                    && !contentType.startsWith(\"application/xml\")\n                    && !contentType.startsWith(\"application/xhtml+xml\")\n                    )\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            // switch to the XML parser if content type is xml and not parser not explicitly set\n            if (contentType != null && (contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))) {\n                // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                    req.parser(Parser.xmlParser());\n                }\n            }\n\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                res.bodyStream = null;\n                res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                    res.bodyStream = new GZIPInputStream(res.bodyStream);\n                } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                    res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                }\n                res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout())\n                ;\n            } else {\n                res.byteData = DataUtil.emptyByteBuffer();\n            }\n        } catch (IOException e){\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            conn.disconnect();\n            throw e;\n        }\n\n        res.executed = true;\n        return res;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -8.468060346295138,
      "mean_entropy": -0.008392527597913913
    },
    {
      "patch": "\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        Validate.notNull(req.url(), \"URL must be specified to connect\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n        final boolean methodHasBody = req.method().hasBody();\n        final boolean hasRequestBody = req.requestBody() != null;\n        if (!methodHasBody)\n            Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n        // set up the request for execution\n        String mimeBoundary = null;\n        if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n            serialiseRequestUrl(req);\n        else if (methodHasBody)\n            mimeBoundary = setOutputContentType(req);\n\n        long startTime = System.nanoTime();\n        HttpURLConnection conn = createConnection(req);\n        Response res = new Response(previousResponse);\n        try {\n            conn.connect();\n            if (conn.getDoOutput())\n                writePost(req, conn.getOutputStream(), mimeBoundary);\n\n            int status = conn.getResponseCode();\n            res.setupFromConnection(conn, previousResponse);\n            res.req = req;\n\n            // redirect if there's a location header (from 3xx, or 201 etc)\n            if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                if (status != HTTP_TEMP_REDIR) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n                    req.requestBody(null);\n                    req.removeHeader(CONTENT_TYPE);\n                }\n\n                String location = res.header(LOCATION);\n                if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                URL redir = StringUtil.resolve(req.url(), location);\n                req.url(encodeUrl(redir));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null\n                    && !req.ignoreContentType()\n                    && !contentType.startsWith(\"text/\")\n                    && !xmlContentTypeRxp.matcher(contentType).matches()\n                    )\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            // switch to the XML parser if content type is xml and not parser not explicitly set\n            if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                    req.parser(Parser.xmlParser());\n                }\n            }\n\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                res.bodyStream = null;\n                res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                    res.bodyStream = new GZIPInputStream(res.bodyStream);\n                } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                    res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                }\n                res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                ;\n            } else {\n                res.byteData = DataUtil.emptyByteBuffer();\n            }\n        } catch (IOException e) {\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            conn.disconnect();\n            throw e;\n        }\n\n        res.executed = true;\n        return res;\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -9.83421590996539,
      "mean_entropy": -0.009913524102787691
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    Validate.notNull(req.url(), \"URL must be specified to connect\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !contentType.startsWith(\"application/xml\")\n                && !contentType.startsWith(\"application/xhtml+xml\")\n        )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and parser not explicitly set\n        if (contentType != null && contentType.startsWith(\"application/xml\")) {\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout())\n            ;\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -10.520055990660893,
      "mean_entropy": -0.010811979435417157
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    Validate.notNull(req.url(), \"URL must be specified to connect\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\")) {\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    }\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody) {\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n    }\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody)) {\n        serialiseRequestUrl(req);\n    } else if (methodHasBody) {\n        mimeBoundary = setOutputContentType(req);\n    }\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput()) {\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n        }\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location.startsWith(\"http:/\") && location.charAt(6) != '/') { // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            }\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors()) {\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n        }\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n        ) {\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n        }\n\n        // switch to the XML parser if content type is xml and not parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout());\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -7.335321117381162,
      "mean_entropy": -0.00723404449445874
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    Validate.notNull(req.url(), \"URL must be specified to connect\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !contentType.startsWith(\"application/xml\")\n                && !contentType.startsWith(\"application/xhtml+xml\")\n                )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and parser not explicitly set\n        if (contentType != null && contentType.startsWith(\"application/xml\")) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout());\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -13.192691450466395,
      "mean_entropy": -0.013272325402883697
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !contentType.startsWith(\"application/xml\")\n                        && !contentType.startsWith(\"application/xhtml+xml\")\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && contentType.startsWith(\"application/xml\")) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -5.408619553977939,
      "mean_entropy": -0.005419458470919778
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    Validate.notNull(req.url(), \"URL must be specified to connect\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody)\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n        serialiseRequestUrl(req);\n    else if (methodHasBody)\n        mimeBoundary = setOutputContentType(req);\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput())\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                location = location.substring(6);\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n                )\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n\n        // switch to the XML parser if content type is xml and not parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                .timeout(startTime, req.timeout())\n            ;\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e){\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -6.797439593528656,
      "mean_entropy": -0.006838470416024805
    },
    {
      "patch": "\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException {\n    Validate.notNull(req, \"Request must not be null\");\n    Validate.notNull(req.url(), \"URL must be specified to connect\");\n    String protocol = req.url().getProtocol();\n    if (!protocol.equals(\"http\") && !protocol.equals(\"https\")) {\n        throw new MalformedURLException(\"Only http & https protocols supported\");\n    }\n    final boolean methodHasBody = req.method().hasBody();\n    final boolean hasRequestBody = req.requestBody() != null;\n    if (!methodHasBody) {\n        Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n    }\n\n    // set up the request for execution\n    String mimeBoundary = null;\n    if (req.data().size() > 0 && (!methodHasBody || hasRequestBody)) {\n        serialiseRequestUrl(req);\n    } else if (methodHasBody) {\n        mimeBoundary = setOutputContentType(req);\n    }\n\n    long startTime = System.nanoTime();\n    HttpURLConnection conn = createConnection(req);\n    Response res;\n    try {\n        conn.connect();\n        if (conn.getDoOutput()) {\n            writePost(req, conn.getOutputStream(), mimeBoundary);\n        }\n\n        int status = conn.getResponseCode();\n        res = new Response(previousResponse);\n        res.setupFromConnection(conn, previousResponse);\n        res.req = req;\n\n        // redirect if there's a location header (from 3xx, or 201 etc)\n        if (res.hasHeader(LOCATION) && req.followRedirects()) {\n            if (status != HTTP_TEMP_REDIR) {\n                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                req.data().clear();\n                req.requestBody(null);\n                req.removeHeader(CONTENT_TYPE);\n            }\n\n            String location = res.header(LOCATION);\n            if (location.startsWith(\"http:/\") && location.charAt(6) != '/') {\n                location = location.substring(6);\n            }\n            URL redir = StringUtil.resolve(req.url(), location);\n            req.url(encodeUrl(redir));\n\n            for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                req.cookie(cookie.getKey(), cookie.getValue());\n            }\n            return execute(req, res);\n        }\n        if ((status < 200 || status >= 400) && !req.ignoreHttpErrors()) {\n            throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n        }\n\n        // check that we can handle the returned content type; if not, abort before fetching it\n        String contentType = res.contentType();\n        if (contentType != null\n                && !req.ignoreContentType()\n                && !contentType.startsWith(\"text/\")\n                && !xmlContentTypeRxp.matcher(contentType).matches()\n        ) {\n            throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                    contentType, req.url().toString());\n        }\n\n        // switch to the XML parser if content type is xml and not parser not explicitly set\n        if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n            // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n            if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                req.parser(Parser.xmlParser());\n            }\n        }\n\n        res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n        if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n            res.bodyStream = null;\n            res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n            if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                res.bodyStream = new GZIPInputStream(res.bodyStream);\n            } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n            }\n            res.bodyStream = ConstrainableInputStream\n                    .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                    .timeout(startTime, req.timeout());\n        } else {\n            res.byteData = DataUtil.emptyByteBuffer();\n        }\n    } catch (IOException e) {\n        // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n        // connection errors will not be released quickly enough and can cause a too many open files error.\n        conn.disconnect();\n        throw e;\n    }\n\n    res.executed = true;\n    return res;\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -10.578283879327973,
      "mean_entropy": -0.010546643947485517
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                    throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                            .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                            .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e) {\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practice,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -7.677331014545805,
      "mean_entropy": -0.0076927164474406865
    },
    {
      "patch": "\n    static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n        Validate.notNull(req, \"Request must not be null\");\n        Validate.notNull(req.url(), \"URL must be specified to connect\");\n        String protocol = req.url().getProtocol();\n        if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n            throw new MalformedURLException(\"Only http & https protocols supported\");\n        final boolean methodHasBody = req.method().hasBody();\n        final boolean hasRequestBody = req.requestBody() != null;\n        if (!methodHasBody)\n            Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n        // set up the request for execution\n        String mimeBoundary = null;\n        if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n            serialiseRequestUrl(req);\n        else if (methodHasBody)\n            mimeBoundary = setOutputContentType(req);\n\n        long startTime = System.nanoTime();\n        HttpURLConnection conn = createConnection(req);\n        Response res;\n        try {\n            conn.connect();\n            if (conn.getDoOutput())\n                writePost(req, conn.getOutputStream(), mimeBoundary);\n\n            int status = conn.getResponseCode();\n            res = new Response(previousResponse);\n            res.setupFromConnection(conn, previousResponse);\n            res.req = req;\n\n            // redirect if there's a location header (from 3xx, or 201 etc)\n            if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                if (status != HTTP_TEMP_REDIR) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n                    req.requestBody(null);\n                    req.removeHeader(CONTENT_TYPE);\n                }\n\n                String location = res.header(LOCATION);\n                if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                    location = location.substring(6);\n                URL redir = StringUtil.resolve(req.url(), location);\n                req.url(encodeUrl(redir));\n\n                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                    req.cookie(cookie.getKey(), cookie.getValue());\n                }\n                return execute(req, res);\n            }\n            if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n            // check that we can handle the returned content type; if not, abort before fetching it\n            String contentType = res.contentType();\n            if (contentType != null\n                    && !req.ignoreContentType()\n                    && !contentType.startsWith(\"text/\")\n                    && !xmlContentTypeRxp.matcher(contentType).matches()\n            )\n                throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                        contentType, req.url().toString());\n\n            // switch to the XML parser if content type is xml and not parser not explicitly set\n            if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                    req.parser(Parser.xmlParser());\n                }\n            }\n\n            res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n            if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                res.bodyStream = null;\n                res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                    res.bodyStream = new GZIPInputStream(res.bodyStream);\n                } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                    res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                }\n                res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                ;\n            } else {\n                res.byteData = DataUtil.emptyByteBuffer();\n            }\n        } catch (IOException e) {\n            // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n            // connection errors will not be released quickly enough and can cause a too many open files error.\n            conn.disconnect();\n            throw e;\n        }\n\n        res.executed = true;\n        return res;\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -7.049797188262999,
      "mean_entropy": -0.007085223304786933
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -6.028562736998316,
      "mean_entropy": -0.00605885702210886
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.908602641559362,
      "mean_entropy": -0.0039164355125845315
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.908602641559362,
      "mean_entropy": -0.0039164355125845315
    },
    {
      "patch": "\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((HttpConnection.Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != Method.HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 25,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript",
        [
          "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript"
        ]
      ],
      "sum_entropy": -3.908602641559362,
      "mean_entropy": -0.0039164355125845315
    }
  ],
  "Jsoup_89": [
    {
      "patch": "\n    /**\n     * Set the attribute key; case is preserved.\n     * @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound) {\n                parent.keys[i] = key;\n            }\n        }\n        this.key = key;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.5173739211892505,
      "mean_entropy": -0.013310297554291672
    },
    {
      "patch": "\n    /**\n     * Set the attribute key; case is preserved.\n     * @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound) {\n                parent.keys[i] = key;\n            }\n        }\n        this.key = key;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.5173739211892505,
      "mean_entropy": -0.013310297554291672
    },
    {
      "patch": "\n    /**\n     * Set the attribute key; case is preserved.\n     * @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -2.5346291777006504,
      "mean_entropy": -0.022834497096402256
    },
    {
      "patch": "\n    /**\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.7266038989712407,
      "mean_entropy": -0.01584040274285542
    },
    {
      "patch": "\n/**\n * Set the attribute key; case is preserved.\n * @param key the new key; must not be null\n */\npublic void setKey(String key) {\n    Validate.notNull(key);\n    key = key.trim();\n    Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n    if (parent != null) {\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound) {\n            parent.keys[i] = key;\n        }\n    }\n    this.key = key;\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -2.3021609819504305,
      "mean_entropy": -0.02131630538842991
    },
    {
      "patch": "\n/**\n * Set the attribute key; case is preserved.\n * @param key the new key; must not be null\n */\npublic void setKey(String key) {\n    Validate.notNull(key);\n    key = key.trim();\n    Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n    if (parent != null) {\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound)\n            parent.keys[i] = key;\n    }\n    this.key = key;\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -2.28254143553933,
      "mean_entropy": -0.021738489862279334
    },
    {
      "patch": "\n    /**\n     * Set the attribute key; case is preserved.\n     * @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound) {\n                parent.keys[i] = key;\n            }\n        }\n        this.key = key;\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.5173739211892505,
      "mean_entropy": -0.013310297554291672
    },
    {
      "patch": "\n    /**\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.7266038989712407,
      "mean_entropy": -0.01584040274285542
    },
    {
      "patch": "\n/**\n * Set the attribute key; case is preserved.\n * @param key the new key; must not be null\n */\npublic void setKey(String key) {\n    Validate.notNull(key);\n    key = key.trim();\n    Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n    if (parent != null) {\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound)\n            parent.keys[i] = key;\n    }\n    this.key = key;\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -2.28254143553933,
      "mean_entropy": -0.021738489862279334
    },
    {
      "patch": "\n    /**\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.7266038989712407,
      "mean_entropy": -0.01584040274285542
    },
    {
      "patch": "\n    /**\n     * Set the attribute key; case is preserved.\n     * @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound) {\n                parent.keys[i] = key;\n            }\n        }\n        this.key = key;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.5173739211892505,
      "mean_entropy": -0.013310297554291672
    },
    {
      "patch": "\n/**\n * Set the attribute key; case is preserved.\n * @param key the new key; must not be null\n */\npublic void setKey(String key) {\n    Validate.notNull(key);\n    key = key.trim();\n    Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n    if (parent != null) {\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound)\n            parent.keys[i] = key;\n    }\n    this.key = key;\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -2.28254143553933,
      "mean_entropy": -0.021738489862279334
    },
    {
      "patch": "\n/**\n * Set the attribute key; case is preserved.\n * @param key the new key; must not be null\n */\npublic void setKey(String key) {\n    Validate.notNull(key);\n    key = key.trim();\n    Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n    if (parent != null) {\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound)\n            parent.keys[i] = key;\n    }\n    this.key = key;\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -2.28254143553933,
      "mean_entropy": -0.021738489862279334
    },
    {
      "patch": "\n    /**\n     * Set the attribute key; case is preserved.\n     * @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound) {\n                parent.keys[i] = key;\n            }\n        }\n        this.key = key;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.5173739211892505,
      "mean_entropy": -0.013310297554291672
    },
    {
      "patch": "\n    /**\n     * Set the attribute key; case is preserved.\n     * @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -2.5346291777006504,
      "mean_entropy": -0.022834497096402256
    },
    {
      "patch": "\n    /**\n     * Set the attribute key; case is preserved.\n     * @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound) {\n                parent.keys[i] = key;\n            }\n        }\n        this.key = key;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.81184680605765,
      "mean_entropy": -0.015893393035593423
    },
    {
      "patch": "\n/**\n * Set the attribute key; case is preserved.\n * @param key the new key; must not be null\n */\npublic void setKey(String key) {\n    Validate.notNull(key);\n    key = key.trim();\n    Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n    if (parent != null) {\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound)\n            parent.keys[i] = key;\n    }\n    this.key = key;\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.9829905303045,
      "mean_entropy": -0.018885624098138095
    },
    {
      "patch": "\n/**\n * Set the attribute key; case is preserved.\n * @param key the new key; must not be null\n */\npublic void setKey(String key) {\n    Validate.notNull(key);\n    key = key.trim();\n    Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n    if (parent != null) {\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound) {\n            parent.keys[i] = key;\n        }\n    }\n    this.key = key;\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -2.4782645557391993,
      "mean_entropy": -0.022946894034622217
    },
    {
      "patch": "\n    /**\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.62992486127764,
      "mean_entropy": -0.014953439094290276
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded\n     */\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.6600741369834309,
      "mean_entropy": -0.012868791759561479
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.46656430988502007,
      "mean_entropy": -0.003673734723504095
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded\n     */\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.6600741369834309,
      "mean_entropy": -0.012868791759561479
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.46656430988502007,
      "mean_entropy": -0.003673734723504095
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.46656430988502007,
      "mean_entropy": -0.003673734723504095
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.46656430988502007,
      "mean_entropy": -0.003673734723504095
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.46656430988502007,
      "mean_entropy": -0.003673734723504095
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.46656430988502007,
      "mean_entropy": -0.003673734723504095
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded\n     */\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.6600741369834309,
      "mean_entropy": -0.012868791759561479
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.46656430988502007,
      "mean_entropy": -0.003673734723504095
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.46656430988502007,
      "mean_entropy": -0.003673734723504095
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded\n     */\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -1.6600741369834309,
      "mean_entropy": -0.012868791759561479
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.46656430988502007,
      "mean_entropy": -0.003673734723504095
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.46656430988502007,
      "mean_entropy": -0.003673734723504095
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.46656430988502007,
      "mean_entropy": -0.003673734723504095
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.5135948558569298,
      "mean_entropy": -0.0040440539831254315
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.5135948558569298,
      "mean_entropy": -0.0040440539831254315
    },
    {
      "patch": "\n/**\n * Create a new attribute from unencoded (raw) key and value.\n * @param key attribute key; case is preserved.\n * @param val attribute value\n * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n * @see #createFromEncoded\n */\npublic Attribute(String key, String val, Attributes parent) {\n    Validate.notNull(key);\n    key = key.trim();\n    Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n    this.key = key;\n    this.val = val;\n    this.parent = parent;\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -3.410482903639671,
      "mean_entropy": -0.028420690863663927
    },
    {
      "patch": "\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 28,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute",
        [
          "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute"
        ]
      ],
      "sum_entropy": -0.5135948558569298,
      "mean_entropy": -0.0040440539831254315
    }
  ],
  "Jsoup_93": [
    {
      "patch": "\n/**\n * Test if the input body HTML has only tags and attributes allowed by the Whitelist. Useful for form validation.\n * The input HTML should still be run through the cleaner to set up enforced attributes, and to tidy the output.\n * Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)\n *\n * @param bodyHtml HTML to test\n * @param whitelist whitelist to test against\n * @return true if no tags or attributes were removed; false otherwise\n * @see #clean(String, org.jsoup.safety.Whitelist)\n */\npublic static boolean isValid(String bodyHtml, Whitelist whitelist) {\n    return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);\n}\n\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.FormElementTest::createsFormData\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 26,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.FormElementTest::createsFormData",
        [
          "org.jsoup.nodes.FormElementTest::createsFormData"
        ]
      ],
      "sum_entropy": -5.649558799317484,
      "mean_entropy": -0.037916502008842175
    },
    {
      "patch": "\n/**\n * Test if the input body HTML has only tags and attributes allowed by the Whitelist. Useful for form validation.\n * The input HTML should still be run through the cleaner to set up enforced attributes, and to tidy the output.\n * Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)\n * @param bodyHtml HTML to test\n * @param whitelist whitelist to test against\n * @return true if no tags or attributes were removed; false otherwise\n * @see #clean(String, org.jsoup.safety.Whitelist)\n */\npublic static boolean isValid(String bodyHtml, Whitelist whitelist) {\n    return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);\n}\n\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.FormElementTest::createsFormData\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 26,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.FormElementTest::createsFormData",
        [
          "org.jsoup.nodes.FormElementTest::createsFormData"
        ]
      ],
      "sum_entropy": -4.611429534362729,
      "mean_entropy": -0.031158307664613038
    },
    {
      "patch": "\n    public Connection submit() {\n        String action = hasAttr(\"action\") ? absUrl(\"action\") : baseUri();\n        Validate.notEmpty(action, \"Could not determine a form action URL for submit. Ensure you set a base URI when parsing.\");\n        Connection.Method method = attr(\"method\").toUpperCase().equals(\"POST\") ?\n                Connection.Method.POST : Connection.Method.GET;\n\n        return Jsoup.connect(action)\n                .data(formData())\n                .method(method);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.FormElementTest::createsFormData\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 26,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.FormElementTest::createsFormData",
        [
          "org.jsoup.nodes.FormElementTest::createsFormData"
        ]
      ],
      "sum_entropy": -2.943219845441181,
      "mean_entropy": -0.03065854005667897
    },
    {
      "patch": "\n/**\n * Prepare to submit this form. A Connection object is created with the request set up from the form values. You\n * can then set up other options (like user-agent, timeout, cookies), then execute it.\n * @return a connection prepared from the values of this form.\n * @throws IllegalArgumentException if the form's absolute action URL cannot be determined. Make sure you pass the\n * document's base URI when parsing.\n */\npublic Connection submit() {\n    String action = hasAttr(\"action\") ? absUrl(\"action\") : baseUri();\n    Validate.notEmpty(action, \"Could not determine a form action URL for submit. Ensure you set a base URI when parsing.\");\n    Connection.Method method = attr(\"method\").toUpperCase().equals(\"POST\") ?\n            Connection.Method.POST : Connection.Method.GET;\n\n    return Jsoup.connect(action)\n            .data(formData())\n            .method(method);\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.FormElementTest::createsFormData\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 26,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.FormElementTest::createsFormData",
        [
          "org.jsoup.nodes.FormElementTest::createsFormData"
        ]
      ],
      "sum_entropy": -3.414235455484233,
      "mean_entropy": -0.018759535469693587
    },
    {
      "patch": "\n    /**\n     * Prepare to submit this form. A Connection object is created with the request set up from the form values. You\n     * can then set up other options (like user-agent, timeout, cookies), then execute it.\n     * @return a connection prepared from the values of this form.\n     * @throws IllegalArgumentException if the form's absolute action URL cannot be determined. Make sure you pass the\n     * document's base URI when parsing.\n     */\n    public Connection submit() {\n        String action = hasAttr(\"action\") ? absUrl(\"action\") : baseUri();\n        Validate.notEmpty(action, \"Could not determine a form action URL for submit. Ensure you set a base URI when parsing.\");\n        Connection.Method method = attr(\"method\").toUpperCase().equals(\"POST\") ?\n                Connection.Method.POST : Connection.Method.GET;\n\n        return Jsoup.connect(action)\n                .data(formData())\n                .method(method);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.FormElementTest::createsFormData\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 26,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.FormElementTest::createsFormData",
        [
          "org.jsoup.nodes.FormElementTest::createsFormData"
        ]
      ],
      "sum_entropy": -2.3153508516984695,
      "mean_entropy": -0.012122255768054814
    },
    {
      "patch": "\n    /**\n     * Prepare to submit this form. A Connection object is created with the request set up from the form values. You\n     * can then set up other options (like user-agent, timeout, cookies), then execute it.\n     * @return a connection prepared from the values of this form.\n     * @throws IllegalArgumentException if the form's absolute action URL cannot be determined. Make sure you pass the\n     * document's base URI when parsing.\n     */\n    public Connection submit() {\n        String action = hasAttr(\"action\") ? absUrl(\"action\") : baseUri();\n        Validate.notEmpty(action, \"Could not determine a form action URL for submit. Ensure you set a base URI when parsing.\");\n        Connection.Method method = attr(\"method\").toUpperCase().equals(\"POST\") ?\n                Connection.Method.POST : Connection.Method.GET;\n\n        return Jsoup.connect(action)\n                .data(formData())\n                .method(method);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.FormElementTest::createsFormData\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 26,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.FormElementTest::createsFormData",
        [
          "org.jsoup.nodes.FormElementTest::createsFormData"
        ]
      ],
      "sum_entropy": -2.3153508516984695,
      "mean_entropy": -0.012122255768054814
    },
    {
      "patch": "\n    /**\n     * Prepare to submit this form. A Connection object is created with the request set up from the form values. You\n     * can then set up other options (like user-agent, timeout, cookies), then execute it.\n     * @return a connection prepared from the values of this form.\n     * @throws IllegalArgumentException if the form's absolute action URL cannot be determined. Make sure you pass the\n     * document's base URI when parsing.\n     */\n    public Connection submit() {\n        String action = hasAttr(\"action\") ? absUrl(\"action\") : baseUri();\n        Validate.notEmpty(action, \"Could not determine a form action URL for submit. Ensure you set a base URI when parsing.\");\n        Connection.Method method = attr(\"method\").toUpperCase().equals(\"POST\") ?\n                Connection.Method.POST : Connection.Method.GET;\n\n        return Jsoup.connect(action)\n                .data(formData())\n                .method(method);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.jsoup.nodes.FormElementTest::createsFormData\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 26,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.jsoup.nodes.FormElementTest::createsFormData",
        [
          "org.jsoup.nodes.FormElementTest::createsFormData"
        ]
      ],
      "sum_entropy": -2.3153508516984695,
      "mean_entropy": -0.012122255768054814
    }
  ],
  "Lang_10": [
    {
      "patch": "\n    /**\n     * Performs the logic for the {@code split} and\n     * {@code splitPreserveAllTokens} methods that return a maximum array\n     * length.\n     *\n     * @param str  the String to parse, may be {@code null}\n     * @param separatorChars the separate character\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if {@code true}, adjacent separators are\n     * treated as empty token separators; if {@code false}, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, {@code null} if null String input\n     */\n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            // Null separator means use whitespace\n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            // Optimise 1 character case\n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
        [
          "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
          "org.apache.commons.lang3.time.FastDateParserTest::testLANG_831"
        ]
      ],
      "sum_entropy": -2.30405207699141,
      "mean_entropy": -0.003249720842018914
    },
    {
      "patch": "\n    /**\n     * Performs the logic for the {@code split} and\n     * {@code splitPreserveAllTokens} methods that return a maximum array\n     * length.\n     *\n     * @param str  the String to parse, may be {@code null}\n     * @param separatorChars the separate character\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if {@code true}, adjacent separators are\n     * treated as empty token separators; if {@code false}, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, {@code null} if null String input\n     */\n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return new String[0];\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            // Null separator means use whitespace\n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            // Optimise 1 character case\n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || preserveAllTokens && lastMatch) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
        [
          "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
          "org.apache.commons.lang3.time.FastDateParserTest::testLANG_831"
        ]
      ],
      "sum_entropy": -3.638400370289131,
      "mean_entropy": -0.00514625229178095
    },
    {
      "patch": "\n    /**\n     * Performs the logic for the {@code split} and\n     * {@code splitPreserveAllTokens} methods that return a maximum array\n     * length.\n     *\n     * @param str  the String to parse, may be {@code null}\n     * @param separatorChars the separate character\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if {@code true}, adjacent separators are\n     * treated as empty token separators; if {@code false}, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, {@code null} if null String input\n     */\n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            // Null separator means use whitespace\n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            // Optimise 1 character case\n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
        [
          "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
          "org.apache.commons.lang3.time.FastDateParserTest::testLANG_831"
        ]
      ],
      "sum_entropy": -2.30405207699141,
      "mean_entropy": -0.003249720842018914
    },
    {
      "patch": "\n    /**\n     * Performs the logic for the {@code split} and\n     * {@code splitPreserveAllTokens} methods that return a maximum array\n     * length.\n     *\n     * @param str  the String to parse, may be {@code null}\n     * @param separatorChars the separate character\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if {@code true}, adjacent separators are\n     * treated as empty token separators; if {@code false}, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, {@code null} if null String input\n     */\n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            // Null separator means use whitespace\n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            // Optimise 1 character case\n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
        [
          "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
          "org.apache.commons.lang3.time.FastDateParserTest::testLANG_831"
        ]
      ],
      "sum_entropy": -2.30405207699141,
      "mean_entropy": -0.003249720842018914
    },
    {
      "patch": "\n    /**\n     * Performs the logic for the {@code split} and\n     * {@code splitPreserveAllTokens} methods that return a maximum array\n     * length.\n     *\n     * @param str  the String to parse, may be {@code null}\n     * @param separatorChars the separate character\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if {@code true}, adjacent separators are\n     * treated as empty token separators; if {@code false}, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, {@code null} if null String input\n     */\n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            // Null separator means use whitespace\n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            // Optimise 1 character case\n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
        [
          "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
          "org.apache.commons.lang3.time.FastDateParserTest::testLANG_831"
        ]
      ],
      "sum_entropy": -2.30405207699141,
      "mean_entropy": -0.003249720842018914
    },
    {
      "patch": "\n    /**\n     * Performs the logic for the {@code split} and\n     * {@code splitPreserveAllTokens} methods that return a maximum array\n     * length.\n     *\n     * @param str  the String to parse, may be {@code null}\n     * @param separatorChars the separate character\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if {@code true}, adjacent separators are\n     * treated as empty token separators; if {@code false}, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, {@code null} if null String input\n     */\n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            // Null separator means use whitespace\n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            // Optimise 1 character case\n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
        [
          "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
          "org.apache.commons.lang3.time.FastDateParserTest::testLANG_831"
        ]
      ],
      "sum_entropy": -2.30405207699141,
      "mean_entropy": -0.003249720842018914
    },
    {
      "patch": "\n    /**\n     * Performs the logic for the {@code split} and\n     * {@code splitPreserveAllTokens} methods that return a maximum array\n     * length.\n     *\n     * @param str  the String to parse, may be {@code null}\n     * @param separatorChars the separate character\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if {@code true}, adjacent separators are\n     * treated as empty token separators; if {@code false}, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, {@code null} if null String input\n     */\n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            // Null separator means use whitespace\n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            // Optimise 1 character case\n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
        [
          "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
          "org.apache.commons.lang3.time.FastDateParserTest::testLANG_831"
        ]
      ],
      "sum_entropy": -2.3942032692426833,
      "mean_entropy": -0.003376873440398707
    },
    {
      "patch": "\n    /**\n     * Performs the logic for the {@code split} and\n     * {@code splitPreserveAllTokens} methods that return a maximum array\n     * length.\n     *\n     * @param str  the String to parse, may be {@code null}\n     * @param separatorChars the separate character\n     * @param max  the maximum number of elements to include in the\n     *  array. A zero or negative value implies no limit.\n     * @param preserveAllTokens if {@code true}, adjacent separators are\n     * treated as empty token separators; if {@code false}, adjacent\n     * separators are treated as one separator.\n     * @return an array of parsed Strings, {@code null} if null String input\n     */\n    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n        // Performance tuned for 2.0 (JDK1.4)\n        // Direct code is quicker than StringTokenizer.\n        // Also, StringTokenizer uses isSpace() not isWhitespace()\n\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        List<String> list = new ArrayList<String>();\n        int sizePlus1 = 1;\n        int i = 0, start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        if (separatorChars == null) {\n            // Null separator means use whitespace\n            while (i < len) {\n                if (Character.isWhitespace(str.charAt(i))) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else if (separatorChars.length() == 1) {\n            // Optimise 1 character case\n            char sep = separatorChars.charAt(0);\n            while (i < len) {\n                if (str.charAt(i) == sep) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || (preserveAllTokens && lastMatch)) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 8,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
        [
          "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831",
          "org.apache.commons.lang3.time.FastDateParserTest::testLANG_831"
        ]
      ],
      "sum_entropy": -2.3942032692426833,
      "mean_entropy": -0.003376873440398707
    }
  ],
  "Lang_16": [
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n        try {\n            return Integer.decode(str);\n        } catch (NumberFormatException e) {\n            // Handle upper-case hex: 0X and -0X\n            if (str.matches(\"-?0X[0-9A-Fa-f]+\")) {\n                str = str.replace(\"0X\", \"0x\");\n                return Integer.decode(str);\n            }\n            throw e;\n        }\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -13.590808092817491,
      "mean_entropy": -0.05592925141077157
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n        return Integer.decode(str.toLowerCase());\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -7.040372976848592,
      "mean_entropy": -0.04117177179443621
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Handle upper-case hex (0X and -0X) by converting the input string to lowercase before decoding.\n        return Integer.decode(str.toLowerCase());\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -11.789114543630792,
      "mean_entropy": -0.06854136362576041
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Decode the string to handle both upper-case and lower-case hex.\n        try {\n            return Integer.decode(str);\n        } catch (NumberFormatException e) {\n            // Handle upper-case hex (0X) by replacing with lower-case (0x).\n            str = str.replace(\"0X\", \"0x\");\n            return Integer.decode(str);\n        }\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -25.481317325927836,
      "mean_entropy": -0.1196305977743091
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Ensure the string is in lowercase to handle upper-case hex\n        str = str.toLowerCase();\n        return Integer.decode(str);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -11.395158363510792,
      "mean_entropy": -0.06823448121862749
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Handle upper-case hex by converting the input string to lowercase\n        return Integer.decode(str.toLowerCase());\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -8.14681517232879,
      "mean_entropy": -0.05028898254523944
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Convert 'X' to 'x' to handle upper-case hex\n        str = str.replace(\"X\", \"x\");\n        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n        return Integer.decode(str);\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -8.935619849068685,
      "mean_entropy": -0.0453584763912116
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Convert to lower case to handle upper-case hex: 0X and -0X\n        str = str.toLowerCase();\n        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n        return Integer.decode(str);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -11.424886355623789,
      "mean_entropy": -0.05829023650828464
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // To handle upper-case hex like 0X and -0X, we need to convert the string to lowercase first\n        // before passing it to Integer.decode()\n        return Integer.decode(str.toLowerCase());\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -14.246209917220591,
      "mean_entropy": -0.07784814162415624
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Convert both upper and lower case hex and octal notations correctly\n        return Integer.decode(str);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -19.32413069181679,
      "mean_entropy": -0.11855294902955087
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Fix for handling upper-case hex: 0X and -0X\n        if (str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            str = str.replace(\"X\", \"x\");\n        }\n        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n        return Integer.decode(str);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -7.683538894510191,
      "mean_entropy": -0.03540801333875664
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Fix the bug: Convert hex digits to lowercase before passing to Integer.decode()\n        return Integer.decode(str.toLowerCase());\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -20.30993142361279,
      "mean_entropy": -0.12309049347644116
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Convert the string to lowercase to handle upper-case hex like 0X\n        return Integer.decode(str.toLowerCase());\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -11.126311497850091,
      "mean_entropy": -0.06743219089606116
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Check for upper-case hex (0X) and convert to lower case before calling decode()\n        if (str.length() > 1 && str.charAt(1) == 'X') {\n            str = \"0x\" + str.substring(2).toLowerCase(); // Convert to lower case hex\n        }\n        return Integer.decode(str);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -22.104176106082193,
      "mean_entropy": -0.10475912846484452
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n        // To handle upper-case hex like 0X and -0X, convert the input string to lowercase before decoding\n        return Integer.decode(str.toLowerCase());\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -14.724766239538175,
      "mean_entropy": -0.0751263583649907
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Handle upper-case hex (0X and -0X) as well by converting the string to lowercase before decoding\n        return Integer.decode(str.toLowerCase());\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -14.16059090705438,
      "mean_entropy": -0.08185312663037213
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // Convert hexadecimal strings to lowercase before calling decode()\n        str = str.toLowerCase();\n        return Integer.decode(str);\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -12.549691717859677,
      "mean_entropy": -0.07652251047475413
    }
  ],
  "Lang_27": [
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Invalid number format\");\n        }\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -3.7270292122207205,
      "mean_entropy": -0.018635146061103603
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Invalid number format: \" + str);\n        }\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -2.33870985831672,
      "mean_entropy": -0.011464264011356471
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Invalid format for BigDecimal: \" + str);\n        }\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -5.44234729239572,
      "mean_entropy": -0.026548035572662047
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        } \n        // Check if the string contains both 'e' and 'E' which may cause StringIndexOutOfBoundsException\n        if (str.indexOf('e') != -1 && str.indexOf('E') != -1) {\n            throw new NumberFormatException(\"Invalid number format: both 'e' and 'E' present in the string\");\n        }\n        return new BigDecimal(str);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -25.722629855814414,
      "mean_entropy": -0.10414020184540249
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Invalid number format: \" + str);\n        }\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -2.33870985831672,
      "mean_entropy": -0.011464264011356471
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"The input string is not a valid number: \" + str);\n        }\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -6.2596158449827195,
      "mean_entropy": -0.029950315047764207
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Invalid number format: \" + str);\n        }\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -2.33870985831672,
      "mean_entropy": -0.011464264011356471
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Input is not a valid number\");\n        }\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -7.1254676443431215,
      "mean_entropy": -0.03492876296246628
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Invalid number format: \" + str);\n        }\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -2.33870985831672,
      "mean_entropy": -0.011464264011356471
    },
    {
      "patch": "\n/**\n * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n * \n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * @param str  a <code>String</code> to convert, may be null\n * @return converted <code>BigDecimal</code>\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static BigDecimal createBigDecimal(String str) {\n    if (str == null) {\n        return null;\n    }\n    // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    try {\n        return new BigDecimal(str);\n    } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Invalid number format: \" + str);\n    }\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -3.4380311274864486,
      "mean_entropy": -0.017813632784903877
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new NumberFormatException(\"Invalid number format: \" + str);\n        }\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -7.543134228625121,
      "mean_entropy": -0.034760987228687194
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Invalid input format for BigDecimal\");\n        }\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -7.643210722100719,
      "mean_entropy": -0.037837676842082765
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Invalid number format: \" + str);\n        }\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -3.182552038103121,
      "mean_entropy": -0.015524644088307907
    },
    {
      "patch": "\n/**\n * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n * \n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * @param str  a <code>String</code> to convert, may be null\n * @return converted <code>BigDecimal</code>\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static BigDecimal createBigDecimal(String str) {\n    if (str == null) {\n        return null;\n    }\n    // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    try {\n        return new BigDecimal(str);\n    } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Invalid number format: \" + str);\n    }\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -4.321573969451349,
      "mean_entropy": -0.022276154481707985
    },
    {
      "patch": "\n/**\n * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n * \n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * @param str  a <code>String</code> to convert, may be null\n * @return converted <code>BigDecimal</code>\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static BigDecimal createBigDecimal(String str) {\n    if (str == null) {\n        return null;\n    }\n    // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    try {\n        return new BigDecimal(str);\n    } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Invalid number format: \" + str);\n    }\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -3.4380311274864486,
      "mean_entropy": -0.017813632784903877
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"The string contains an invalid number format\");\n        }\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -10.438467253620718,
      "mean_entropy": -0.05116895712559175
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str) || str.equalsIgnoreCase(\"e\") || str.equalsIgnoreCase(\"E\")) {\n            throw new NumberFormatException(\"A blank string or invalid number format\");\n        }  \n        return new BigDecimal(str);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -6.362572695289312,
      "mean_entropy": -0.03366440579518154
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Input is not a valid number\");\n        }\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -6.2784532953543,
      "mean_entropy": -0.030928341356425124
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Invalid number format: \" + str);\n        }\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -3.019033210142701,
      "mean_entropy": -0.014726991268988784
    },
    {
      "patch": "\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Input string is not a valid number\");\n        }\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -5.423670109624301,
      "mean_entropy": -0.02658661818443285
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both <code>0</code>, start and end are set\n     * to <code>' '</code> and <code>'z'</code>, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * <code>false</code>, in which case, start and end are set to\n     * <code>0</code> and <code>Integer.MAX_VALUE</code>.\n     *\n     * <p>If set is not <code>null</code>, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single \n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if ((start == 0) && (end == 0)) {\n            end = 'z' + 1;\n            start = ' ';\n            if (!letters && !numbers) {\n                start = 0;\n                end = Integer.MAX_VALUE;\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if ((letters && Character.isLetter(ch))\n                || (numbers && Character.isDigit(ch))\n                || (!letters && !numbers)) \n            {\n                if(Character.isSurrogate(ch)) {\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -6.026626405496301,
      "mean_entropy": -0.008671404899994677
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both <code>0</code>, start and end are set\n     * to <code>' '</code> and <code>'z'</code>, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * <code>false</code>, in which case, start and end are set to\n     * <code>0</code> and <code>Integer.MAX_VALUE</code>.\n     *\n     * <p>If set is not <code>null</code>, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single \n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if ((start == 0) && (end == 0)) {\n            end = 'z' + 1;\n            start = ' ';\n            if (!letters && !numbers) {\n                start = 0;\n                end = Integer.MAX_VALUE;\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if ((letters && Character.isLetter(ch))\n                || (numbers && Character.isDigit(ch))\n                || (!letters && !numbers)) \n            {\n                if (Character.isHighSurrogate(ch) || Character.isLowSurrogate(ch)) {\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -4.678873624197302,
      "mean_entropy": -0.006636700176166386
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both <code>0</code>, start and end are set\n     * to <code>' '</code> and <code>'z'</code>, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * <code>false</code>, in which case, start and end are set to\n     * <code>0</code> and <code>Integer.MAX_VALUE</code>.\n     *\n     * <p>If set is not <code>null</code>, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single \n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if ((start == 0) && (end == 0)) {\n            end = 'z' + 1;\n            start = ' ';\n            if (!letters && !numbers) {\n                start = 0;\n                end = Integer.MAX_VALUE;\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if ((letters && Character.isLetter(ch))\n                || (numbers && Character.isDigit(ch))\n                || (!letters && !numbers)) \n            {\n                if (Character.isHighSurrogate(ch) || Character.isLowSurrogate(ch)) {\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -4.678873624197302,
      "mean_entropy": -0.006636700176166386
    },
    {
      "patch": "\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if ((start == 0) && (end == 0)) {\n            end = 'z' + 1;\n            start = ' ';\n            if (!letters && !numbers) {\n                start = 0;\n                end = Integer.MAX_VALUE;\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(chars.length)];\n            }\n            if ((letters && Character.isLetter(ch))\n                || (numbers && Character.isDigit(ch))\n                || (!letters && !numbers)) \n            {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // low surrogate, insert high surrogate after putting it in\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // high surrogate, insert low surrogate before putting it in\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    // private high surrogate, no clue, so skip it\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -6.871540821121692,
      "mean_entropy": -0.015511378828717138
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both <code>0</code>, start and end are set\n     * to <code>' '</code> and <code>'z'</code>, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * <code>false</code>, in which case, start and end are set to\n     * <code>0</code> and <code>Integer.MAX_VALUE</code>.</p>\n     *\n     * <p>If set is not <code>null</code>, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single \n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if ((start == 0) && (end == 0)) {\n            end = 'z' + 1;\n            start = ' ';\n            if (!letters && !numbers) {\n                start = 0;\n                end = Integer.MAX_VALUE;\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(chars.length)];\n            }\n            if ((letters && Character.isLetter(ch))\n                || (numbers && Character.isDigit(ch))\n                || (!letters && !numbers)) \n            {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // low surrogate, insert high surrogate after putting it in\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // high surrogate, insert low surrogate before putting it in\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    // private high surrogate, no effing clue, so skip it\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -9.260667557911948,
      "mean_entropy": -0.01073078511924907
    },
    {
      "patch": "\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if ((start == 0) && (end == 0)) {\n            end = 'z' + 1;\n            start = ' ';\n            if (!letters && !numbers) {\n                start = 0;\n                end = Integer.MAX_VALUE;\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(chars.length)];\n            }\n            if ((letters && Character.isLetter(ch))\n                || (numbers && Character.isDigit(ch))\n                || (!letters && !numbers)) \n            {\n                if (Character.isHighSurrogate(ch) || Character.isLowSurrogate(ch)) {\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -4.932197765346425,
      "mean_entropy": -0.017245446731980505
    },
    {
      "patch": "\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if ((start == 0) && (end == 0)) {\n            end = 'z' + 1;\n            start = ' ';\n            if (!letters && !numbers) {\n                start = 0;\n                end = Integer.MAX_VALUE;\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(chars.length)];\n            }\n            if ((letters && Character.isLetter(ch))\n                    || (numbers && Character.isDigit(ch))\n                    || (!letters && !numbers)) {\n                if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // high surrogate, insert low surrogate before putting it in\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // low surrogate, insert high surrogate after putting it in\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    // private high surrogate, no effing clue, so skip it\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -8.958280968861134,
      "mean_entropy": -0.020221853202846803
    },
    {
      "patch": "\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if ((start == 0) && (end == 0)) {\n            end = 'z' + 1;\n            start = ' ';\n            if (!letters && !numbers) {\n                start = 0;\n                end = Integer.MAX_VALUE;\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(chars.length)];\n            }\n            if ((letters && Character.isLetter(ch))\n                || (numbers && Character.isDigit(ch))\n                || (!letters && !numbers)) \n            {\n                if (Character.isHighSurrogate(ch) || Character.isLowSurrogate(ch)) {\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -4.932197765346425,
      "mean_entropy": -0.017245446731980505
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both <code>0</code>, start and end are set\n     * to <code>' '</code> and <code>'z'</code>, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * <code>false</code>, in which case, start and end are set to\n     * <code>0</code> and <code>Integer.MAX_VALUE</code>.\n     *\n     * <p>If set is not <code>null</code>, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single \n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if ((start == 0) && (end == 0)) {\n            end = 'z' + 1;\n            start = ' ';\n            if (!letters && !numbers) {\n                start = 0;\n                end = Integer.MAX_VALUE;\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if ((letters && Character.isLetter(ch))\n                || (numbers && Character.isDigit(ch))\n                || (!letters && !numbers)) \n            {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // low surrogate, insert high surrogate after putting it in\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // high surrogate, insert low surrogate before putting it in\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    // private high surrogate, no effing clue, so skip it\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer).replaceAll(\"eE\", \"\"); // Fix for the reported bug\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -11.308361661705002,
      "mean_entropy": -0.012894369055535919
    },
    {
      "patch": "\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if ((start == 0) && (end == 0)) {\n            end = 'z' + 1;\n            start = ' ';\n            if (!letters && !numbers) {\n                start = 0;\n                end = Integer.MAX_VALUE;\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(chars.length)];\n            }\n            if ((letters && Character.isLetter(ch))\n                || (numbers && Character.isDigit(ch))\n                || (!letters && !numbers)) \n            {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // low surrogate, insert high surrogate after putting it in\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // high surrogate, insert low surrogate before putting it in\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    // private high surrogate, no effing clue, so skip it\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -4.10283433309725,
      "mean_entropy": -0.009219852433926404
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both <code>0</code>, start and end are set\n     * to <code>' '</code> and <code>'z'</code>, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * <code>false</code>, in which case, start and end are set to\n     * <code>0</code> and <code>Integer.MAX_VALUE</code>.\n     *\n     * <p>If set is not <code>null</code>, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single \n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if ((start == 0) && (end == 0)) {\n            end = 'z' + 1;\n            start = ' ';\n            if (!letters && !numbers) {\n                start = 0;\n                end = Integer.MAX_VALUE;\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if ((letters && Character.isLetter(ch))\n                || (numbers && Character.isDigit(ch))\n                || (!letters && !numbers)) \n            {\n                if (Character.isHighSurrogate(ch) || Character.isLowSurrogate(ch)) {\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -4.423443821653001,
      "mean_entropy": -0.006274388399507803
    },
    {
      "patch": "\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, new Random());\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -3.2723018003799997,
      "mean_entropy": -0.07113699566043477
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, new Random());\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -1.53712734633012,
      "mean_entropy": -0.005393429285368842
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, new Random());\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -3.2723018003799997,
      "mean_entropy": -0.07113699566043477
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.7487663142601201,
      "mean_entropy": -0.0026365011065497186
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.8270011622507801,
      "mean_entropy": -0.0029119759234182397
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.8270011622507801,
      "mean_entropy": -0.0029119759234182397
    },
    {
      "patch": "\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * default source of randomness.</p>\n     *\n     * <p>This method has exactly the same semantics as\n     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n     * instead of using an externally supplied source of randomness, it uses\n     * the internal static {@link Random} instance.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from.\n     *  If <code>null</code>, then it will use the set of all chars.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  <code>(end - start) + 1</code> characters in the set array.\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n        return random(count, start, end, letters, numbers, chars, RANDOM);\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -0.8270011622507801,
      "mean_entropy": -0.0029119759234182397
    },
    {
      "patch": "\n/**\n * <p>Creates a random string based on a variety of options, using\n * default source of randomness.</p>\n *\n * <p>This method has exactly the same semantics as\n * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n * instead of using an externally supplied source of randomness, it uses\n * the internal static {@link Random} instance.</p>\n *\n * @param count  the length of random string to create\n * @param start  the position in set of chars to start at\n * @param end  the position in set of chars to end before\n * @param letters  only allow letters?\n * @param numbers  only allow numbers?\n * @param chars  the set of chars to choose randoms from.\n *  If <code>null</code>, then it will use the set of all chars.\n * @return the random string\n * @throws ArrayIndexOutOfBoundsException if there are not\n *  <code>(end - start) + 1</code> characters in the set array.\n */\npublic static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n    return random(count, start, end, letters, numbers, chars, new Random());\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber",
        [
          "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber"
        ]
      ],
      "sum_entropy": -3.8477518914195805,
      "mean_entropy": -0.01463023532859156
    }
  ],
  "Lang_31": [
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead.\n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder(repeat);\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -3.05004842134299,
      "mean_entropy": -0.009384764373363047
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -2.4691076712173294,
      "mean_entropy": -0.0076207026889423745
    },
    {
      "patch": "\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder(repeat);\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -3.2563595528272007,
      "mean_entropy": -0.03831011238620236
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder(repeat);\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -2.2867586147298775,
      "mean_entropy": -0.007014596977699011
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder(repeat);\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -2.2867586147298775,
      "mean_entropy": -0.007014596977699011
    },
    {
      "patch": "\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            sb.append(padChar);\n        }\n        return sb.toString();\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -3.392997129939689,
      "mean_entropy": -0.0413780137797523
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder(repeat);\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -2.2867586147298775,
      "mean_entropy": -0.007014596977699011
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final char[] buf = new char[repeat];\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = padChar;\n        }\n        return new String(buf);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -4.649000409126872,
      "mean_entropy": -0.014045318456576653
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -2.4691076712173294,
      "mean_entropy": -0.0076207026889423745
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder(repeat);\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -2.2867586147298775,
      "mean_entropy": -0.007014596977699011
    },
    {
      "patch": "\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -3.8932342732565406,
      "mean_entropy": -0.046906437027187234
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder(repeat);\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -2.2867586147298775,
      "mean_entropy": -0.007014596977699011
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -2.4691076712173294,
      "mean_entropy": -0.0076207026889423745
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead.\n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -3.46113336034059,
      "mean_entropy": -0.010715583158949195
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            sb.append(padChar);\n        }\n        return sb.toString();\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -4.037430543447829,
      "mean_entropy": -0.012461205381011817
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder(repeat);\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -2.2867586147298775,
      "mean_entropy": -0.007014596977699011
    },
    {
      "patch": "\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            sb.append(padChar);\n        }\n        return sb.toString();\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -3.3956185659967493,
      "mean_entropy": -0.041409982512155476
    },
    {
      "patch": "\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            sb.append(padChar);\n        }\n        return sb.toString();\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -3.3956185659967493,
      "mean_entropy": -0.041409982512155476
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -2.65803923711391,
      "mean_entropy": -0.00820382480590713
    },
    {
      "patch": "\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.padding(0, 'e')  = \"\"\n     * StringUtils.padding(3, 'e')  = \"eee\"\n     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of <code>char</code>s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead. \n     * </p>\n     *\n     * @param repeat  number of times to repeat delim\n     * @param padChar  character to repeat\n     * @return String with repeated character\n     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n     * @see #repeat(String, int)\n     */\n    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n        if (repeat < 0) {\n            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n        }\n        final StringBuilder buf = new StringBuilder(repeat);\n        for (int i = 0; i < repeat; i++) {\n            buf.append(padChar);\n        }\n        return buf.toString();\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -2.5132545872225105,
      "mean_entropy": -0.007709369899455554
    },
    {
      "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList,\n                                      boolean repeat, int timeToLive)\n    {\n\n        if (text == null || text.length() == 0 || searchList == null ||\n            searchList.length == 0 || replacementList == null || replacementList.length == 0)\n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                searchList[i].length() == 0 || replacementList[i] == null)\n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater;\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                    searchList[i].length() == 0 || replacementList[i] == null)\n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -5.977508115392471,
      "mean_entropy": -0.007653659558761166
    },
    {
      "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -5.846465614049579,
      "mean_entropy": -0.007400589384872885
    },
    {
      "patch": "\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n    int increase = 0;\n\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || replacementList[i] == null) {\n            continue;\n        }\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -7.210367825572029,
      "mean_entropy": -0.009173495961287569
    },
    {
      "patch": "\n    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -3.154787181450282,
      "mean_entropy": -0.0018970458096514023
    },
    {
      "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater;\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -4.524727780930259,
      "mean_entropy": -0.005734762713473078
    },
    {
      "patch": "\n    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n        }\n\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -9.063174682668201,
      "mean_entropy": -0.006391519522333005
    },
    {
      "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList,\n                                      boolean repeat, int timeToLive)\n    {\n\n        if (text == null || text.length() == 0 || searchList == null ||\n                searchList.length == 0 || replacementList == null || replacementList.length == 0)\n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                    + searchLength\n                    + \" vs \"\n                    + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                    searchList[i].length() == 0 || replacementList[i] == null)\n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater;\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                        searchList[i].length() == 0 || replacementList[i] == null)\n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -9.383484218567274,
      "mean_entropy": -0.012014704505207778
    },
    {
      "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList,\n                                      boolean repeat, int timeToLive)\n    {\n\n        if (text == null || text.length() == 0 || searchList == null ||\n            searchList.length == 0 || replacementList == null || replacementList.length == 0)\n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                searchList[i].length() == 0 || replacementList[i] == null)\n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater;\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                    searchList[i].length() == 0 || replacementList[i] == null)\n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -5.977508115392471,
      "mean_entropy": -0.007653659558761166
    },
    {
      "patch": "\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n    int increase = 0;\n\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || replacementList[i] == null) {\n            continue;\n        }\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -9.658250422313595,
      "mean_entropy": -0.012287850410068187
    },
    {
      "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; \n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -5.917083557540456,
      "mean_entropy": -0.007489979186760072
    },
    {
      "patch": "\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList,\n                                      boolean repeat, int timeToLive)\n{\n\n    if (text == null || text.length() == 0 || searchList == null ||\n        searchList.length == 0 || replacementList == null || replacementList.length == 0)\n    {\n        return text;\n    }\n\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n    }\n\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n            searchList[i].length() == 0 || replacementList[i] == null)\n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n    int increase = 0;\n\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || replacementList[i] == null) {\n            continue;\n        }\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; \n        }\n    }\n\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                searchList[i].length() == 0 || replacementList[i] == null)\n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -15.260921180517537,
      "mean_entropy": -0.0195903994615116
    },
    {
      "patch": "\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        if (text == null || text.isEmpty() || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].isEmpty() || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n        int increase = 0;\n\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater;\n            }\n        }\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].isEmpty() || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -6.346003914082429,
      "mean_entropy": -0.008135902453951831
    },
    {
      "patch": "\nprivate static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n\n    if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n        return text;\n    }\n\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength);\n    }\n\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    int increase = 0;\n\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || replacementList[i] == null) {\n            continue;\n        }\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;\n        }\n    }\n\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 2,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 2,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
        [
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars",
          "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyStringWithSupplementaryChars"
        ]
      ],
      "sum_entropy": -10.445725943043229,
      "mean_entropy": -0.0136189386480355
    }
  ],
  "Lang_40": [
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -3.20925877900948,
      "mean_entropy": -0.012343302996190308
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.65652429900948,
      "mean_entropy": -0.0025446678256181394
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        if (str1 == null && str2 == null) {\n            return true;\n        }\n        if (str1 == null || str2 == null) {\n            return false;\n        }\n        return str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -2.2327851985337306,
      "mean_entropy": -0.007752726383797676
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.7503020089516297,
      "mean_entropy": -0.0029081473215179445
    },
    {
      "patch": "\n/**\n * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n * the case.</p>\n *\n * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n * references are considered equal. Comparison is case insensitive.</p>\n *\n * <pre>\n * StringUtils.equalsIgnoreCase(null, null)   = true\n * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n * </pre>\n *\n * @see java.lang.String#equalsIgnoreCase(String)\n * @param str1  the first String, may be null\n * @param str2  the second String, may be null\n * @return <code>true</code> if the Strings are equal, case insensitive, or\n * both <code>null</code>\n */\npublic static boolean equalsIgnoreCase(String str1, String str2) {\n    if (str1 == null && str2 == null) {\n        return true;\n    }\n    if (str1 == null || str2 == null) {\n        return false;\n    }\n    return str1.equalsIgnoreCase(str2);\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -5.985786410159897,
      "mean_entropy": -0.02267343337181779
    },
    {
      "patch": "\n    /**\n     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n     * the case.</p>\n     *\n     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n     * references are considered equal. Comparison is case insensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equalsIgnoreCase(null, null)   = true\n     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n     * </pre>\n     *\n     * @see java.lang.String#equalsIgnoreCase(String)\n     * @param str1  the first String, may be null\n     * @param str2  the second String, may be null\n     * @return <code>true</code> if the Strings are equal, case insensitive, or\n     *  both <code>null</code>\n     */\n    public static boolean equalsIgnoreCase(String str1, String str2) {\n        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 19,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence",
        [
          "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence"
        ]
      ],
      "sum_entropy": -0.7503020089516297,
      "mean_entropy": -0.0029081473215179445
    }
  ],
  "Lang_49": [
    {
      "patch": "\n    /**\n     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>For example, if the input parameters represent 2/4, then the created\n     * fraction will be 1/2.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE ||\n                    denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        if (numerator != 0) {\n            int gcd = greatestCommonDivisor(numerator, denominator);\n            numerator /= gcd;\n            denominator /= gcd;\n        }\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -8.065010963504362,
      "mean_entropy": -0.020574007559960108
    },
    {
      "patch": "\n    /**\n     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>For example, if the input parameters represent 2/4, then the created\n     * fraction will be 1/2.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        if (numerator != 0) {\n            int gcd = greatestCommonDivisor(numerator, denominator);\n            numerator /= gcd;\n            denominator /= gcd;\n        }\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -6.829710344181612,
      "mean_entropy": -0.01746728988281742
    },
    {
      "patch": "\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -6.237827410336411,
      "mean_entropy": -0.029989554857386594
    },
    {
      "patch": "\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return ZERO; // normalize zero.\n        }\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        if (numerator != 0) {\n            int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));\n            numerator /= gcd;\n            denominator /= gcd;\n        }\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -7.605930579033344,
      "mean_entropy": -0.03604706435560826
    },
    {
      "patch": "\n    /**\n     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>For example, if the input parameters represent 2/4, then the created\n     * fraction will be 1/2.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return new Fraction(0, 1); // return 0 as a fraction\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -6.452730789521739,
      "mean_entropy": -0.01658799688823069
    },
    {
      "patch": "\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return new Fraction(0, 1); // return 0/1 for zero numerator\n        }\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        int gcd = greatestCommonDivisor(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -7.182138913639293,
      "mean_entropy": -0.03591069456819647
    },
    {
      "patch": "\n    /**\n     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>For example, if the input parameters represent 2/4, then the created\n     * fraction will be 1/2.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return ZERO; // normalize zero.\n        }\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -5.191157993624918,
      "mean_entropy": -0.014261423059409115
    },
    {
      "patch": "\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return new Fraction(0, 1); // Return a fraction with numerator 0 and denominator 1\n        }\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -8.200081546574323,
      "mean_entropy": -0.03923483993576231
    },
    {
      "patch": "\n    /**\n     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>For example, if the input parameters represent 2/4, then the created\n     * fraction will be 1/2.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return ZERO; // normalize zero.\n        }\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -5.191157993624918,
      "mean_entropy": -0.014261423059409115
    },
    {
      "patch": "\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -4.0262685681039105,
      "mean_entropy": -0.0188143391032893
    },
    {
      "patch": "\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return new Fraction(0, 1); // return 0/1 when numerator is 0\n        }\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -7.8208489914341,
      "mean_entropy": -0.037600235535740864
    },
    {
      "patch": "\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return new Fraction(0, 1); // Return a new fraction with numerator 0 and denominator 1.\n        }\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -9.790622650052432,
      "mean_entropy": -0.0466220126192973
    },
    {
      "patch": "\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return new Fraction(0, 1); // Return 0/1 for zero numerator.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -7.417343800552672,
      "mean_entropy": -0.032820105312179965
    },
    {
      "patch": "\n    /**\n     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>For example, if the input parameters represent 2/4, then the created\n     * fraction will be 1/2.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return Fraction.ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(Math.abs(numerator), Math.abs(denominator));\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -4.6435463643290324,
      "mean_entropy": -0.011967903000848022
    },
    {
      "patch": "\n    /**\n     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>For example, if the input parameters represent 2/4, then the created\n     * fraction will be 1/2.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return new Fraction(0, 1); // Return 0/1 for numerator equal to 0.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -9.627999155347926,
      "mean_entropy": -0.02431312918017153
    },
    {
      "patch": "\n    /**\n     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>For example, if the input parameters represent 2/4, then the created\n     * fraction will be 1/2.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        if (numerator != 0) {\n            int gcd = greatestCommonDivisor(numerator, denominator);\n            numerator /= gcd;\n            denominator /= gcd;\n        }\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -4.990217094786689,
      "mean_entropy": -0.01296160284360179
    },
    {
      "patch": "\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator == 0) {\n            return new Fraction(0, 1); // Return 0/1 for numerator being zero\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n            numerator /= 2;\n            denominator /= 2;\n        }\n        if (denominator < 0) {\n            if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -9.839445777210047,
      "mean_entropy": -0.04334557611105747
    },
    {
      "patch": "\n    /**\n     * <p>Creates a <code>Fraction</code> instance from a <code>double</code> value.</p>\n     *\n     * <p>This method uses the <a href=\"http://archives.math.utk.edu/articles/atuyl/confrac/\">\n     * continued fraction algorithm</a>, computing a maximum of\n     * 25 convergents and bounding the denominator by 10,000.</p>\n     *\n     * @param value the double value to convert\n     * @return a new fraction instance that is close to the value\n     * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code>\n     * or <code>value = NaN</code>\n     * @throws ArithmeticException if the calculated denominator is <code>zero</code>\n     * @throws ArithmeticException if the algorithm does not converge\n     */\n    public static Fraction getFraction(double value) {\n        int sign = (value < 0 ? -1 : 1);\n        value = Math.abs(value);\n        if (value > Integer.MAX_VALUE || Double.isNaN(value)) {\n            throw new ArithmeticException\n                    (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n        }\n        int wholeNumber = (int) value;\n        value -= wholeNumber;\n\n        int numer0 = 0;  // the pre-previous\n        int denom0 = 1;  // the pre-previous\n        int numer1 = 1;  // the previous\n        int denom1 = 0;  // the previous\n        int numer2 = 0;  // the current, setup in calculation\n        int denom2 = 0;  // the current, setup in calculation\n        int a1 = (int) value;\n        int a2 = 0;\n        double x1 = 1;\n        double x2 = 0;\n        double y1 = value - a1;\n        double y2 = 0;\n        double delta1, delta2 = Double.MAX_VALUE;\n        double fraction;\n        int i = 1;\n//        System.out.println(\"---\");\n        do {\n            delta1 = delta2;\n            a2 = (int) (x1 / y1);\n            x2 = y1;\n            y2 = x1 - a2 * y1;\n            numer2 = a1 * numer1 + numer0;\n            denom2 = a1 * denom1 + denom0;\n            fraction = (double) numer2 / (double) denom2;\n            delta2 = Math.abs(value - fraction);\n//            System.out.println(numer2 + \" \" + denom2 + \" \" + fraction + \" \" + delta2 + \" \" + y1);\n            a1 = a2;\n            x1 = x2;\n            y1 = y2;\n            numer0 = numer1;\n            denom0 = denom1;\n            numer1 = numer2;\n            denom1 = denom2;\n            i++;\n//            System.out.println(\">>\" + delta1 +\" \"+ delta2+\" \"+(delta1 > delta2)+\" \"+i+\" \"+denom2);\n        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25) && (denom2 != 0)); // Added check for denom2 != 0\n        if (i == 25) {\n            throw new ArithmeticException(\"Unable to convert double to fraction\");\n        }\n        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n    }\n\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -20.34884206472097,
      "mean_entropy": -0.026810068596470317
    },
    {
      "patch": "\n    /**\n     * <p>Creates a <code>Fraction</code> instance from a <code>double</code> value.</p>\n     *\n     * <p>This method uses the <a href=\"http://archives.math.utk.edu/articles/atuyl/confrac/\">\n     *  continued fraction algorithm</a>, computing a maximum of\n     *  25 convergents and bounding the denominator by 10,000.</p>\n     *\n     * @param value  the double value to convert\n     * @return a new fraction instance that is close to the value\n     * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code> \n     *  or <code>value = NaN</code>\n     * @throws ArithmeticException if the calculated denominator is <code>zero</code>\n     * @throws ArithmeticException if the the algorithm does not converge\n     */\n    public static Fraction getFraction(double value) {\n        int sign = (value < 0 ? -1 : 1);\n        value = Math.abs(value);\n        if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n            throw new ArithmeticException\n                (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n        }\n        int wholeNumber = (int) value;\n        value -= wholeNumber;\n        \n        int numer0 = 0;  // the pre-previous\n        int denom0 = 1;  // the pre-previous\n        int numer1 = 1;  // the previous\n        int denom1 = 0;  // the previous\n        int numer2 = 0;  // the current, setup in calculation\n        int denom2 = 1;  // Fixed: initializing denom2 as 1 instead of 0\n        int a1 = (int) value;\n        int a2 = 0;\n        double x1 = 1;\n        double x2 = 0;\n        double y1 = value - a1;\n        double y2 = 0;\n        double delta1, delta2 = Double.MAX_VALUE;\n        double fraction;\n        int i = 1;\n//        System.out.println(\"---\");\n        do {\n            delta1 = delta2;\n            a2 = (int) (x1 / y1);\n            x2 = y1;\n            y2 = x1 - a2 * y1;\n            numer2 = a1 * numer1 + numer0;\n            denom2 = a1 * denom1 + denom0;\n            fraction = (double) numer2 / (double) denom2;\n            delta2 = Math.abs(value - fraction);\n//            System.out.println(numer2 + \" \" + denom2 + \" \" + fraction + \" \" + delta2 + \" \" + y1);\n            a1 = a2;\n            x1 = x2;\n            y1 = y2;\n            numer0 = numer1;\n            denom0 = denom1;\n            numer1 = numer2;\n            denom1 = denom2;\n            i++;\n//            System.out.println(\">>\" + delta1 +\" \"+ delta2+\" \"+(delta1 > delta2)+\" \"+i+\" \"+denom2);\n        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n        if (i == 25) {\n            throw new ArithmeticException(\"Unable to convert double to fraction\");\n        }\n        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -14.793233164408294,
      "mean_entropy": -0.01967185261224507
    },
    {
      "patch": "\n    /**\n     * <p>Creates a <code>Fraction</code> instance from a <code>double</code> value.</p>\n     *\n     * <p>This method uses the <a href=\"http://archives.math.utk.edu/articles/atuyl/confrac/\">\n     *  continued fraction algorithm</a>, computing a maximum of\n     *  25 convergents and bounding the denominator by 10,000.</p>\n     *\n     * @param value  the double value to convert\n     * @return a new fraction instance that is close to the value\n     * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code> \n     *  or <code>value = NaN</code>\n     * @throws ArithmeticException if the calculated denominator is <code>zero</code>\n     * @throws ArithmeticException if the the algorithm does not converge\n     */\n    public static Fraction getFraction(double value) {\n        int sign = (value < 0 ? -1 : 1);\n        value = Math.abs(value);\n        if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n            throw new ArithmeticException\n                (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n        }\n        int wholeNumber = (int) value;\n        value -= wholeNumber;\n        \n        int numer0 = 0;  // the pre-previous\n        int denom0 = 1;  // the pre-previous\n        int numer1 = 1;  // the previous\n        int denom1 = 0;  // the previous\n        int numer2 = 0;  // the current, setup in calculation\n        int denom2 = 1;  // the current, setup in calculation // Change denom2 to 1 to avoid division by zero\n        int a1 = (int) value;\n        int a2 = 0;\n        double x1 = 1;\n        double x2 = 0;\n        double y1 = value - a1;\n        double y2 = 0;\n        double delta1, delta2 = Double.MAX_VALUE;\n        double fraction;\n        int i = 1;\n        do {\n            delta1 = delta2;\n            a2 = (int) (x1 / y1);\n            x2 = y1;\n            y2 = x1 - a2 * y1;\n            numer2 = a1 * numer1 + numer0;\n            denom2 = a1 * denom1 + denom0;\n            fraction = (double) numer2 / (double) denom2;\n            delta2 = Math.abs(value - fraction);\n            a1 = a2;\n            x1 = x2;\n            y1 = y2;\n            numer0 = numer1;\n            denom0 = denom1;\n            numer1 = numer2;\n            denom1 = denom2;\n            i++;\n        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n        if (i == 25) {\n            throw new ArithmeticException(\"Unable to convert double to fraction\");\n        }\n        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -14.773597476751592,
      "mean_entropy": -0.021504508699783976
    },
    {
      "patch": "\n    public static Fraction getFraction(double value) {\n        int sign = (value < 0 ? -1 : 1);\n        value = Math.abs(value);\n        if (value > Integer.MAX_VALUE || Double.isNaN(value)) {\n            throw new ArithmeticException(\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n        }\n        int wholeNumber = (int) value;\n        value -= wholeNumber;\n\n        int numer0 = 0;\n        int denom0 = 1;\n        int numer1 = 1;\n        int denom1 = 0;\n        int numer2 = 0;\n        int denom2 = 0;\n        int a1 = (int) value;\n        int a2 = 0;\n        double x1 = 1;\n        double x2 = 0;\n        double y1 = value - a1;\n        double y2 = 0;\n        double delta1, delta2 = Double.MAX_VALUE;\n        double fraction;\n        int i = 1;\n\n        do {\n            delta1 = delta2;\n            a2 = (int) (x1 / y1);\n            x2 = y1;\n            y2 = x1 - a2 * y1;\n            numer2 = a1 * numer1 + numer0;\n            denom2 = a1 * denom1 + denom0;\n            fraction = (double) numer2 / (double) denom2;\n            delta2 = Math.abs(value - fraction);\n            a1 = a2;\n            x1 = x2;\n            y1 = y2;\n            numer0 = numer1;\n            denom0 = denom1;\n            numer1 = numer2;\n            denom1 = denom2;\n            i++;\n        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n        if (i == 25 || numer2 == 0) {\n            throw new ArithmeticException(\"Unable to convert double to fraction\");\n        }\n        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -8.85176575077319,
      "mean_entropy": -0.01984700840980536
    },
    {
      "patch": "\n    /**\n     * <p>Creates a <code>Fraction</code> instance from a <code>double</code> value.</p>\n     *\n     * <p>This method uses the <a href=\"http://archives.math.utk.edu/articles/atuyl/confrac/\">\n     *  continued fraction algorithm</a>, computing a maximum of\n     *  25 convergents and bounding the denominator by 10,000.</p>\n     *\n     * @param value  the double value to convert\n     * @return a new fraction instance that is close to the value\n     * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code> \n     *  or <code>value = NaN</code>\n     * @throws ArithmeticException if the calculated denominator is <code>zero</code>\n     * @throws ArithmeticException if the the algorithm does not converge\n     */\n    public static Fraction getFraction(double value) {\n        int sign = (value < 0 ? -1 : 1);\n        value = Math.abs(value);\n        if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n            throw new ArithmeticException\n                (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n        }\n        int wholeNumber = (int) value;\n        value -= wholeNumber;\n        \n        int numer0 = 0;  // the pre-previous\n        int denom0 = 1;  // the pre-previous\n        int numer1 = 1;  // the previous\n        int denom1 = 0;  // the previous\n        int numer2 = 0;  // the current, setup in calculation\n        int denom2 = 0;  // the current, setup in calculation\n        int a1 = (int) value;\n        int a2 = 0;\n        double x1 = 1;\n        double x2 = 0;\n        double y1 = value - a1;\n        double y2 = 0;\n        double delta1, delta2 = Double.MAX_VALUE;\n        double fraction;\n        int i = 1;\n//        System.out.println(\"---\");\n        do {\n            delta1 = delta2;\n            a2 = (int) (x1 / y1);\n            x2 = y1;\n            y2 = x1 - a2 * y1;\n            numer2 = a1 * numer1 + numer0;\n            denom2 = a1 * denom1 + denom0;\n            fraction = (double) numer2 / (double) denom2;\n            delta2 = Math.abs(value - fraction);\n//            System.out.println(numer2 + \" \" + denom2 + \" \" + fraction + \" \" + delta2 + \" \" + y1);\n            a1 = a2;\n            x1 = x2;\n            y1 = y2;\n            numer0 = numer1;\n            denom0 = denom1;\n            numer1 = numer2;\n            denom1 = denom2;\n            i++;\n//            System.out.println(\">>\" + delta1 +\" \"+ delta2+\" \"+(delta1 > delta2)+\" \"+i+\" \"+denom2);\n        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n        if (i == 25) {\n            throw new ArithmeticException(\"Unable to convert double to fraction\");\n        }\n        if (denom0 == 0) {\n            throw new ArithmeticException(\"Divide by zero error occurred\");\n        }\n        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -15.296704270254525,
      "mean_entropy": -0.019814383769759747
    },
    {
      "patch": "\npublic static Fraction getFraction(double value) {\n    int sign = (value < 0 ? -1 : 1);\n    value = Math.abs(value);\n    if (value > Integer.MAX_VALUE || Double.isNaN(value)) {\n        throw new ArithmeticException(\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n    }\n    int wholeNumber = (int) value;\n    value -= wholeNumber;\n\n    int numer0 = 0;  // the pre-previous\n    int denom0 = 1;  // the pre-previous\n    int numer1 = 1;  // the previous\n    int denom1 = 0;  // the previous\n    int numer2 = 0;  // the current, setup in calculation\n    int denom2 = 1;  // the current, setup in calculation (changed from 0 to 1 to avoid division by zero)\n    int a1 = (int) value;\n    int a2 = 0;\n    double x1 = 1;\n    double x2 = 0;\n    double y1 = value - a1;\n    double y2 = 0;\n    double delta1, delta2 = Double.MAX_VALUE;\n    double fraction;\n    int i = 1;\n//    System.out.println(\"---\");\n    do {\n        delta1 = delta2;\n        a2 = (int) (x1 / y1);\n        x2 = y1;\n        y2 = x1 - a2 * y1;\n        numer2 = a1 * numer1 + numer0;\n        denom2 = a1 * denom1 + denom0;\n        fraction = (double) numer2 / (double) denom2;\n        delta2 = Math.abs(value - fraction);\n//        System.out.println(numer2 + \" \" + denom2 + \" \" + fraction + \" \" + delta2 + \" \" + y1);\n        a1 = a2;\n        x1 = x2;\n        y1 = y2;\n        numer0 = numer1;\n        denom0 = denom1;\n        numer1 = numer2;\n        denom1 = denom2;\n        i++;\n//        System.out.println(\">>\" + delta1 +\" \"+ delta2+\" \"+(delta1 > delta2)+\" \"+i+\" \"+denom2);\n    } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 != 0) && (i < 25));\n    if (i == 25) {\n        throw new ArithmeticException(\"Unable to convert double to fraction\");\n    }\n    return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.FractionTest::testReduce\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.FractionTest::testReduce",
        [
          "org.apache.commons.lang.math.FractionTest::testReduce"
        ]
      ],
      "sum_entropy": -18.487190801593947,
      "mean_entropy": -0.03277870709502473
    }
  ],
  "Lang_5": [
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -1.3228578313898487,
      "mean_entropy": -0.004095535081702318
    },
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale the locale to start from, null returns empty list\n     * @param defaultLocale the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -4.822675717160801,
      "mean_entropy": -0.01502391189146667
    },
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(new Locale(\"fr\", \"CA\", \"xxx\"), new Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -3.3789493923740115,
      "mean_entropy": -0.010396767361150805
    },
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -1.3228578313898487,
      "mean_entropy": -0.004095535081702318
    },
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -1.3228578313898487,
      "mean_entropy": -0.004095535081702318
    },
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -1.3228578313898487,
      "mean_entropy": -0.004095535081702318
    },
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -1.3228578313898487,
      "mean_entropy": -0.004095535081702318
    },
    {
      "patch": "\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (!locale.getVariant().isEmpty()) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (!locale.getCountry().isEmpty()) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -3.9669979744848605,
      "mean_entropy": -0.03251637684003984
    },
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -1.3228578313898487,
      "mean_entropy": -0.004095535081702318
    },
    {
      "patch": "\n/**\n * <p>Obtains the list of locales to search through when performing\n * a locale search.</p>\n *\n * <pre>\n * localeLookupList(new Locale(\"fr\", \"CA\", \"xxx\"), new Locale(\"en\"))\n *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n * </pre>\n *\n * <p>The result list begins with the most specific locale, then the\n * next more general and so on, finishing with the default locale.\n * The list will never contain the same locale twice.</p>\n *\n * @param locale  the locale to start from, null returns empty list\n * @param defaultLocale  the default locale to use if no other is found\n * @return the unmodifiable list of Locale objects, 0 being locale, not null\n */\npublic static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n    List<Locale> list = new ArrayList<Locale>(4);\n    if (locale != null) {\n        list.add(locale);\n        if (locale.getVariant().length() > 0) {\n            list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n        }\n        if (locale.getCountry().length() > 0) {\n            list.add(new Locale(locale.getLanguage(), \"\"));\n        }\n        if (!list.contains(defaultLocale)) {\n            list.add(defaultLocale);\n        }\n    }\n    return Collections.unmodifiableList(list);\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -5.548986960191219,
      "mean_entropy": -0.01813394431435039
    },
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -1.3228578313898487,
      "mean_entropy": -0.004095535081702318
    },
    {
      "patch": "\n/**\n * <p>Obtains the list of locales to search through when performing\n * a locale search.</p>\n *\n * <pre>\n * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n * </pre>\n *\n * <p>The result list begins with the most specific locale, then the\n * next more general and so on, finishing with the default locale.\n * The list will never contain the same locale twice.</p>\n *\n * @param locale  the locale to start from, null returns empty list\n * @param defaultLocale  the default locale to use if no other is found\n * @return the unmodifiable list of Locale objects, 0 being locale, not null\n */\npublic static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n    List<Locale> list = new ArrayList<Locale>(4);\n    if (locale != null) {\n        list.add(locale);\n        if (locale.getVariant().length() > 0) {\n            list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n        }\n        if (locale.getCountry().length() > 0) {\n            list.add(new Locale(locale.getLanguage(), \"\"));\n        }\n        if (!list.contains(defaultLocale)) {\n            list.add(defaultLocale);\n        }\n    }\n    return Collections.unmodifiableList(list);\n}\n\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -3.0417304816470097,
      "mean_entropy": -0.009940295691656895
    },
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -1.3228578313898487,
      "mean_entropy": -0.004095535081702318
    },
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -1.3228578313898487,
      "mean_entropy": -0.004095535081702318
    },
    {
      "patch": "\npublic static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n    List<Locale> list = new ArrayList<Locale>(4);\n    if (locale != null) {\n        list.add(locale);\n        if (locale.getVariant().length() > 0) {\n            list.add(new Locale(locale.getLanguage(), locale.getCountry(), \"\"));\n        }\n        if (locale.getCountry().length() > 0) {\n            list.add(new Locale(locale.getLanguage(), \"\"));\n        }\n        if (!list.contains(defaultLocale)) {\n            list.add(defaultLocale);\n        }\n    }\n    return Collections.unmodifiableList(list);\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -2.649162445867031,
      "mean_entropy": -0.020536142991217293
    },
    {
      "patch": "\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (!list.contains(defaultLocale)) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -1.3660401572867598,
      "mean_entropy": -0.004229226493147863
    },
    {
      "patch": "\n/**\n * <p>Obtains the list of locales to search through when performing\n * a locale search.</p>\n *\n * <pre>\n * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\")]\n * </pre>\n *\n * <p>The result list begins with the most specific locale, then the\n * next more general and so on, finishing with the default locale.\n * The list will never contain the same locale twice.</p>\n *\n * @param locale  the locale to start from, null returns empty list\n * @param defaultLocale  the default locale to use if no other is found\n * @return the unmodifiable list of Locale objects, 0 being locale, not null\n */\npublic static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n    List<Locale> list = new ArrayList<Locale>(4);\n    if (locale != null) {\n        list.add(locale);\n        if (locale.getVariant().length() > 0) {\n            list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n        }\n        if (locale.getCountry().length() > 0) {\n            list.add(new Locale(locale.getLanguage(), \"\"));\n        }\n        if (!list.contains(defaultLocale)) {\n            list.add(defaultLocale);\n        }\n    }\n    return Collections.unmodifiableList(list);\n}\n\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.LocaleUtilsTest::testLang865\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.LocaleUtilsTest::testLang865",
        [
          "org.apache.commons.lang3.LocaleUtilsTest::testLang865"
        ]
      ],
      "sum_entropy": -3.0720861756357225,
      "mean_entropy": -0.010039497305999094
    }
  ],
  "Lang_52": [
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        String escaped = escapeJavaStyleString(str, true);\n        // Handle special case for '/'\n        escaped = escaped.replace(\"/\", \"\\\\/\");\n        return escaped;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -11.892720143388003,
      "mean_entropy": -0.04388457617486348
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        return org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(str);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -1.9406359130185,
      "mean_entropy": -0.007700936162771826
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        return org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(str);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -1.9406359130185,
      "mean_entropy": -0.007700936162771826
    },
    {
      "patch": "\n    public static String escapeJavaScript(String str) {\n        return StringEscapeUtils.escapeJavaScript(str);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -3.7832671361734005,
      "mean_entropy": -0.17196668800788184
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        return org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(str);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -1.9406359130185,
      "mean_entropy": -0.007700936162771826
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        return StringEscapeUtils.escapeJavaScript(str);\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -2.72069578617815,
      "mean_entropy": -0.010970547524911896
    },
    {
      "patch": "\n/**\n * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n * <p>Escapes any values it finds into their JavaScript String form.\n * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n *\n * <p>So a tab becomes the characters <code>'\\\\'</code> and\n * <code>'t'</code>.</p>\n *\n * <p>The only difference between Java strings and JavaScript strings\n * is that in JavaScript, a single quote must be escaped.</p>\n *\n * <p>Example:\n * <pre>\n * input string: He didn't say, \"Stop!\"\n * output string: He didn\\'t say, \\\"Stop!\\\"\n * </pre>\n * </p>\n *\n * @param str  String to escape values in, may be null\n * @return String with escaped values, <code>null</code> if null string input\n */\npublic static String escapeJavaScript(String str) {\n    return org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(str);\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -3.5122789088974997,
      "mean_entropy": -0.015337462484268557
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        return StringEscapeUtils.escapeJavaStyleString(str, true);\n    }\n\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -5.45660129642315,
      "mean_entropy": -0.02148268226938248
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        return StringEscapeUtils.escapeJavaStyleString(str, true);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -3.90157267309315,
      "mean_entropy": -0.015482431242433134
    },
    {
      "patch": "\n    public static String escapeJavaScript(String str) {\n        return org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(str);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -5.370110652902943,
      "mean_entropy": -0.20654271741934396
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        return StringEscapeUtils.escapeJavaScript(str);\n    }\n\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -3.44377010746815,
      "mean_entropy": -0.013775080429872601
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        return org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(str);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -1.9406359130185,
      "mean_entropy": -0.007700936162771826
    },
    {
      "patch": "\n/**\n * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n * <p>Escapes any values it finds into their JavaScript String form.\n * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n *\n * <p>So a tab becomes the characters <code>'\\\\'</code> and\n * <code>'t'</code>.</p>\n *\n * <p>The only difference between Java strings and JavaScript strings\n * is that in JavaScript, a single quote must be escaped.</p>\n *\n * <p>Example:\n * <pre>\n * input string: He didn't say, \"Stop!\"\n * output string: He didn\\'t say, \\\"Stop!\\\"\n * </pre>\n * </p>\n *\n * @param str  String to escape values in, may be null\n * @return String with escaped values, <code>null</code> if null string input\n */\npublic static String escapeJavaScript(String str) {\n    return org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(str);\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -3.5122789088974997,
      "mean_entropy": -0.015337462484268557
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        return StringEscapeUtils.escapeJavaScript(str);\n    }\n\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -3.52221089099289,
      "mean_entropy": -0.01408884356397156
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        return org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(str);\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -2.1921023656760887,
      "mean_entropy": -0.00869881891141305
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules.</p>\n     * <p>Escapes any values it finds into their JavaScript String form.\n     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn\\'t say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJavaScript(String str) {\n        String escapedStr = escapeJavaStyleString(str, true);\n        escapedStr = escapedStr.replace(\"/\", \"\\\\/\");\n        return escapedStr;\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -4.728205909159618,
      "mean_entropy": -0.01764255936253589
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        if (str == null) {\n            return;\n        }\n        escapeJavaStyleString(out, str, true);\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -2.6934824334258995,
      "mean_entropy": -0.01539132819100514
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        if (str == null) {\n            return;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            switch (c) {\n                case '\\'':\n                    out.write(\"\\\\'\");\n                    break;\n                case '\\\"':\n                    out.write(\"\\\\\\\"\");\n                    break;\n                case '\\\\':\n                    out.write(\"\\\\\\\\\");\n                    break;\n                case '/':\n                    out.write(\"\\\\/\");\n                    break;\n                case '\\b':\n                    out.write(\"\\\\b\");\n                    break;\n                case '\\f':\n                    out.write(\"\\\\f\");\n                    break;\n                case '\\n':\n                    out.write(\"\\\\n\");\n                    break;\n                case '\\r':\n                    out.write(\"\\\\r\");\n                    break;\n                case '\\t':\n                    out.write(\"\\\\t\");\n                    break;\n                default:\n                    if (c < ' ') {\n                        String hex = Integer.toHexString(c);\n                        out.write(\"\\\\u\");\n                        for (int j = 0; j < 4 - hex.length(); j++) {\n                            out.write('0');\n                        }\n                        out.write(hex);\n                    } else {\n                        out.write(c);\n                    }\n            }\n        }\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -11.686702966180606,
      "mean_entropy": -0.030198198879019655
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        String escapedStr = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(str);\n        out.write(escapedStr);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -5.75916990687039,
      "mean_entropy": -0.0330986776256919
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        if (str == null) {\n            return;\n        }\n        \n        escapeJavaStyleString(out, str, true);\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -5.429703312573899,
      "mean_entropy": -0.03085058700326079
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        if (str == null) {\n            return;\n        }\n        StringBuilder escaped = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            switch (c) {\n                case '\\'':\n                    escaped.append(\"\\\\'\");\n                    break;\n                case '\\\"':\n                    escaped.append(\"\\\\\\\"\");\n                    break;\n                case '\\\\':\n                    escaped.append(\"\\\\\\\\\");\n                    break;\n                case '/':\n                    escaped.append(\"\\\\/\");\n                    break;\n                case '\\b':\n                    escaped.append(\"\\\\b\");\n                    break;\n                case '\\f':\n                    escaped.append(\"\\\\f\");\n                    break;\n                case '\\n':\n                    escaped.append(\"\\\\n\");\n                    break;\n                case '\\r':\n                    escaped.append(\"\\\\r\");\n                    break;\n                case '\\t':\n                    escaped.append(\"\\\\t\");\n                    break;\n                default:\n                    if (c < ' ') {\n                        String hex = Integer.toHexString(c);\n                        escaped.append(\"\\\\u\");\n                        for (int j = 0; j < 4 - hex.length(); j++) {\n                            escaped.append('0');\n                        }\n                        escaped.append(hex);\n                    } else {\n                        escaped.append(c);\n                    }\n            }\n        }\n        out.write(escaped.toString());\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -12.634204631345845,
      "mean_entropy": -0.03150674471657318
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        String escapedStr = StringEscapeUtils.escapeJavaScript(str); // Using StringEscapeUtils to escape the string\n        out.write(escapedStr); // Writing the escaped string to the Writer\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -12.237564954847699,
      "mean_entropy": -0.0647490209251201
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        if (str == null) {\n            return;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            if (c == '/') {\n                out.write(\"\\\\/\");\n            } else {\n                out.write(c);\n            }\n        }\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -4.64132281379125,
      "mean_entropy": -0.021688424363510515
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        String escapedStr = StringEscapeUtils.escapeJavaScript(str); // Fixed line to properly escape the input string\n        escapeJavaStyleString(out, escapedStr, true);\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -12.918003546388098,
      "mean_entropy": -0.06982704619669242
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        if (str == null) {\n            return;\n        }\n        escapeJavaStyleString(out, str, true);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -2.6934824334258995,
      "mean_entropy": -0.01539132819100514
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        if (str == null) {\n            return;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            if (c == '/') {\n                out.write(\"\\\\/\");\n            } else {\n                out.write(c);\n            }\n        }\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -4.64132281379125,
      "mean_entropy": -0.021688424363510515
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        if (str == null) {\n            return;\n        }\n        escapeJavaStyleString(out, str, true);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -2.6934824334258995,
      "mean_entropy": -0.01539132819100514
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        String escapedStr = StringEscapeUtils.escapeJavaScript(str); // Use Apache Commons Lang to properly escape characters\n        out.write(escapedStr);\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -10.938344004245051,
      "mean_entropy": -0.0607685778013614
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        String escapedStr = escapeJavaStyleString(str, true);\n        out.write(escapedStr);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -3.4530584256092505,
      "mean_entropy": -0.020193324126369885
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        String escaped = StringEscapeUtils.escapeJavaScript(str); // Fix: Use StringEscapeUtils to escape the input string\n        out.write(escaped);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -14.717642332916277,
      "mean_entropy": -0.08131294106583578
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        String escapedStr = escapeJavaStyleString(str, true);\n        out.write(escapedStr);\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -3.7768912604460287,
      "mean_entropy": -0.022087083394421222
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        if (str != null) {\n            escapeJavaStyleString(out, str, true);\n        }\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -5.464565689706381,
      "mean_entropy": -0.031770730754106864
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using JavaScript String rules\n     * to a <code>Writer</code>.</p>\n     * \n     * <p>A <code>null</code> string input has no effect.</p>\n     * \n     * @see #escapeJavaScript(java.lang.String)\n     * @param out  Writer to write escaped string into\n     * @param str  String to escape values in, may be null\n     * @throws IllegalArgumentException if the Writer is <code>null</code>\n     * @throws IOException if error occurs on underlying Writer\n     **/\n    public static void escapeJavaScript(Writer out, String str) throws IOException {\n        String escapedStr = StringEscapeUtils.escapeJavaScript(str);\n        out.write(escapedStr);\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -2.7279021705223596,
      "mean_entropy": -0.01604648335601388
    },
    {
      "patch": "\n    /**\n     * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n     *\n     * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn't say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */\n    public static String escapeJava(String str) {\n        return StringEscapeUtils.escapeJavaStyleString(str, false);\n    }\n\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -3.8098440065923405,
      "mean_entropy": -0.015743157052034464
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString();\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -2.8756472138428495,
      "mean_entropy": -0.017116947701445534
    },
    {
      "patch": "\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\");\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 2,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -3.887382482133639,
      "mean_entropy": -0.036673419642770176
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\");\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 4,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -1.5059052370228507,
      "mean_entropy": -0.008704654549265034
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replaceAll(\"/\", \"\\\\\\\\/\"); // Added escape for '/'\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 5,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -10.996722237335847,
      "mean_entropy": -0.061434202443217026
    },
    {
      "patch": "\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\");\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 6,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -2.8106528669509387,
      "mean_entropy": -0.030222073838182137
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\"); // Fixing the bug by escaping '/'\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 7,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -7.827720740234551,
      "mean_entropy": -0.04324707591289807
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\"); // Escape '/' to '\\/'\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 9,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -4.971134435759052,
      "mean_entropy": -0.027617413531994733
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     *\n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\");\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 10,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -3.9584296268857475,
      "mean_entropy": -0.023014125737707836
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\");\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 11,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -1.5059052370228507,
      "mean_entropy": -0.008704654549265034
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\");\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 12,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -1.5059052370228507,
      "mean_entropy": -0.008704654549265034
    },
    {
      "patch": "\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\");\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 13,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -2.8106528669509387,
      "mean_entropy": -0.030222073838182137
    },
    {
      "patch": "\n/**\n * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n * \n * @param str String to escape values in, may be null\n * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n * @return the escaped string\n */\nprivate static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n    if (str == null) {\n        return null;\n    }\n    try {\n        StringWriter writer = new StringWriter(str.length() * 2);\n        escapeJavaStyleString(writer, str, escapeSingleQuotes);\n        return writer.toString().replace(\"/\", \"\\\\/\");\n    } catch (IOException ioe) {\n        // this should never ever happen while writing to a StringWriter\n        ioe.printStackTrace();\n        return null;\n    }\n}\n",
      "index": 14,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -3.443023534596279,
      "mean_entropy": -0.020994045942660237
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\");\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 15,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -1.5059052370228507,
      "mean_entropy": -0.008704654549265034
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString();\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 2,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript",
        [
          "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
        ]
      ],
      "sum_entropy": -2.8756472138428495,
      "mean_entropy": -0.017116947701445534
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\");\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 17,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -1.6786408386663003,
      "mean_entropy": -0.009703126235065319
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\");\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 18,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -1.6786408386663003,
      "mean_entropy": -0.009703126235065319
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\"); // Fix for escaping '/'\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 19,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -5.422842417342699,
      "mean_entropy": -0.03046540683900393
    },
    {
      "patch": "\n    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuotes escapes single quotes if <code>true</code>\n     * @return the escaped string\n     */\n    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n        if (str == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(str.length() * 2);\n            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n            return writer.toString().replace(\"/\", \"\\\\/\");\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            ioe.printStackTrace();\n            return null;\n        }\n    }\n",
      "index": 20,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 2,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript"
      ],
      "failing_tests": [],
      "sum_entropy": -1.6786408386663003,
      "mean_entropy": -0.009703126235065319
    }
  ],
  "Lang_55": [
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if (this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        if (stopTime != -1) {\n            startTime += (System.currentTimeMillis() - stopTime);\n        }\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -3.6140969783707315,
      "mean_entropy": -0.024255684418595512
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if (this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        startTime += (System.currentTimeMillis() - stopTime);\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -3.5127950067909905,
      "mean_entropy": -0.025640839465627667
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if (this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        startTime += (System.currentTimeMillis() - stopTime);\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -3.5127950067909905,
      "mean_entropy": -0.025640839465627667
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if(this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        if(stopTime != -1) {\n            startTime += (System.currentTimeMillis() - stopTime);\n            stopTime = -1;\n        }\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -4.223339297772212,
      "mean_entropy": -0.028730199304572872
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if (this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        if (this.stopTime != -1) {\n            startTime += (System.currentTimeMillis() - stopTime);\n        }\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -4.288065005883192,
      "mean_entropy": -0.02858710003922128
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if(this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        startTime += (System.currentTimeMillis() - stopTime);\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -1.68185006223381,
      "mean_entropy": -0.012366544575248602
    },
    {
      "patch": "\n    public void resume() {\n        if (this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        startTime += (System.currentTimeMillis() - stopTime);\n        stopTime = -1;\n        if (this.runningState == STATE_SUSPENDED) {\n            this.runningState = STATE_RUNNING;\n        }\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -8.59256037536565,
      "mean_entropy": -0.11016103045340578
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if(this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        startTime += (System.currentTimeMillis() - stopTime);\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -1.68185006223381,
      "mean_entropy": -0.012366544575248602
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if (this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        if (stopTime != -1) {\n            startTime += (System.currentTimeMillis() - stopTime);\n            stopTime = -1;\n        }\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -3.832201107362931,
      "mean_entropy": -0.0257194705192143
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if (this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        startTime += (System.currentTimeMillis() - stopTime);\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -3.5127950067909905,
      "mean_entropy": -0.025640839465627667
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if (this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        if (stopTime != -1) {\n            startTime += (System.currentTimeMillis() - stopTime);\n        }\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -3.6140969783707315,
      "mean_entropy": -0.024255684418595512
    },
    {
      "patch": "\n/**\n * <p>Resume the stopwatch after a suspend.</p>\n * \n * <p>This method resumes the watch after it was suspended. The watch will not include\n * time between the suspend and resume calls in the total time.</p>\n *\n * @throws IllegalStateException if the StopWatch has not been suspended. \n */\npublic void resume() {\n    if(this.runningState != STATE_SUSPENDED) {\n        throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n    }\n    if (this.stopTime != -1) {\n        startTime += (System.currentTimeMillis() - stopTime);\n    }\n    stopTime = -1;\n    this.runningState = STATE_RUNNING;\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -6.970139298212612,
      "mean_entropy": -0.0501448870375008
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if(this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        startTime += (System.currentTimeMillis() - stopTime);\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -1.68185006223381,
      "mean_entropy": -0.012366544575248602
    },
    {
      "patch": "\n    public void resume() {\n        if(this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        if(stopTime != -1) { // Check if stopwatch was stopped after suspend\n            startTime += (System.currentTimeMillis() - stopTime);\n        }\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -14.3220449491627,
      "mean_entropy": -0.1746590847458866
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if(this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        startTime += (System.currentTimeMillis() - stopTime);\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -1.68185006223381,
      "mean_entropy": -0.012366544575248602
    },
    {
      "patch": "\n    public void resume() {\n        if(this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        startTime += (System.currentTimeMillis() - stopTime);\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -5.10972760156,
      "mean_entropy": -0.08241496131548388
    },
    {
      "patch": "\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if(this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        startTime += (System.currentTimeMillis() - stopTime);\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -1.6348412664368,
      "mean_entropy": -0.01202089166497647
    },
    {
      "patch": "\n    public void resume() {\n        if(this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        if (this.stopTime != -1) {\n            startTime += (System.currentTimeMillis() - stopTime);\n            stopTime = -1;\n        }\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -6.029038153041001,
      "mean_entropy": -0.08038717537388002
    },
    {
      "patch": "\n    public void resume() {\n        if (this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume.\");\n        }\n        if (stopTime != -1) {\n            startTime += (System.currentTimeMillis() - stopTime);\n        }\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -4.479684848649062,
      "mean_entropy": -0.05972913131532082
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -1.5074991389058299,
      "mean_entropy": -0.011964278880205
    },
    {
      "patch": "\n/**\n * <p>Suspend the stopwatch for later resumption.</p>\n * \n * <p>This method suspends the watch until it is resumed. The watch will not include\n * time between the suspend and resume calls in the total time.</p>\n *\n * @throws IllegalStateException if the StopWatch is not currently running.\n */\npublic void suspend() {\n    if(this.runningState != STATE_RUNNING) {\n        throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n    }\n    this.stopTime = System.currentTimeMillis();\n    this.runningState = STATE_SUSPENDED;\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -5.211237375932271,
      "mean_entropy": -0.04454049039258351
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        if(this.runningState == STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is already suspended.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -4.002120484172131,
      "mean_entropy": -0.026504109166702858
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        this.stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -3.08668265727513,
      "mean_entropy": -0.02430458785256008
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -2.566197633150499,
      "mean_entropy": -0.02020628057598818
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        if(this.runningState == STATE_SUSPENDED) {\n            return; // Do nothing if already suspended\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -5.673332530081981,
      "mean_entropy": -0.03782221686721321
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -1.5074991389058299,
      "mean_entropy": -0.011964278880205
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        this.runningState = STATE_SUSPENDED;\n        stopTime = System.currentTimeMillis();\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -6.7383665979973015,
      "mean_entropy": -0.053058004708640166
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -4.2746976255849,
      "mean_entropy": -0.03143160018812426
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -2.566197633150499,
      "mean_entropy": -0.02020628057598818
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -2.566197633150499,
      "mean_entropy": -0.02020628057598818
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -1.5074991389058299,
      "mean_entropy": -0.011964278880205
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        if(this.runningState == STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is already suspended.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -4.002120484172131,
      "mean_entropy": -0.026504109166702858
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -1.5074991389058299,
      "mean_entropy": -0.011964278880205
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        if(this.runningState == STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is already suspended.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -4.044313893165341,
      "mean_entropy": -0.02678353571632676
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n        }\n        if(this.runningState == STATE_RUNNING) {\n            stopTime = System.currentTimeMillis();\n            this.runningState = STATE_SUSPENDED;\n        }\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -5.833970185393279,
      "mean_entropy": -0.03941871746887351
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if (this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        if (this.runningState == STATE_SUSPENDED) {\n            return; // Already suspended, do nothing\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -5.560269343444327,
      "mean_entropy": -0.03658071936476531
    },
    {
      "patch": "\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend.\");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.time.StopWatchTest::testLang315\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.time.StopWatchTest::testLang315",
        [
          "org.apache.commons.lang.time.StopWatchTest::testLang315"
        ]
      ],
      "sum_entropy": -1.5259802029673502,
      "mean_entropy": -0.012110953991804367
    }
  ],
  "Lang_58": [
    {
      "patch": "\npublic static Number createNumber(String val) throws NumberFormatException {\n    if (val == null) {\n        return null;\n    }\n    if (val.length() == 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }\n\n    char lastChar = val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = val.indexOf('.');\n    int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec = val.substring(decPos + 1, expPos);\n        } else {\n            dec = val.substring(decPos + 1);\n        }\n        mant = val.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = val.substring(0, expPos);\n        } else {\n            mant = val;\n        }\n        dec = null;\n    }\n\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length());\n        } else {\n            exp = null;\n        }\n        String numeric = val.substring(0, val.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n\n        switch (lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        return createBigInteger(numeric);\n                    }\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                // Fall through\n            case 'd':\n            case 'D':\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // empty catch\n                }\n                // Fall through\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos > -1 && expPos < val.length()) {\n            exp = val.substring(expPos + 1);\n        } else {\n            exp = null;\n        }\n\n        if (dec == null && exp == null) {\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe2) {\n                    return createBigInteger(val);\n                }\n            }\n        } else {\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n\n            try {\n                Float f = createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                Double d = createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n\n            return createBigDecimal(val);\n        }\n    }\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -17.317154746702087,
      "mean_entropy": -0.01898810827489264
    },
    {
      "patch": "\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }\n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l':\n                case 'L':\n                    if (dec == null && exp == null && (numeric.equals(\"-\") || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            return createBigInteger(numeric);\n                        }\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f':\n                case 'F':\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd':\n                case 'D':\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default:\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        } else {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n            } else {\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigDecimal(val);\n            }\n        }\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -13.03606089522249,
      "mean_entropy": -0.01406263311242987
    },
    {
      "patch": "\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && numeric.length() > 1 && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -6.505525391739487,
      "mean_entropy": -0.004686977947939111
    },
    {
      "patch": "\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -7.449219871258184,
      "mean_entropy": -0.006765867276347125
    },
    {
      "patch": "\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.length() > 1 && isDigits(numeric.substring(0, numeric.length() - 1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        } else {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigInteger(val);\n            } else {\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n\n                return createBigDecimal(val);\n            }\n        }\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -26.07143674384512,
      "mean_entropy": -0.027913743837093274
    },
    {
      "patch": "\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.length() > 1 && numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -4.124278631671666,
      "mean_entropy": -0.002971382299475264
    },
    {
      "patch": "\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }\n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l':\n                case 'L':\n                    if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            return createBigInteger(numeric);\n                        }\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f':\n                case 'F':\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd':\n                case 'D':\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default:\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        } else {\n            if (expPos > -1 && expPos < val.length()) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n            } else {\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigDecimal(val);\n            }\n        }\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -10.474793758854883,
      "mean_entropy": -0.011202987977384901
    },
    {
      "patch": "\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }\n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l':\n                case 'L':\n                    if (dec == null && exp == null && (numeric.length() == 1 || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            return createBigInteger(numeric);\n                        }\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f':\n                case 'F':\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                case 'd':\n                case 'D':\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                default:\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        } else {\n            if (expPos > -1 && expPos < val.length()) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    try {\n                        return createLong(val);\n                    } catch (NumberFormatException e) {\n                        return createBigInteger(val);\n                    }\n                }\n            } else {\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigDecimal(val);\n            }\n        }\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -15.342884656418416,
      "mean_entropy": -0.01697221754028586
    },
    {
      "patch": "\npublic static Number createNumber(String val) throws NumberFormatException {\n    if (val == null) {\n        return null;\n    }\n    if (val.length() == 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }   \n    char lastChar = val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = val.indexOf('.');\n    int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec = val.substring(decPos + 1, expPos);\n        } else {\n            dec = val.substring(decPos + 1);\n        }\n        mant = val.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = val.substring(0, expPos);\n        } else {\n            mant = val;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = val.substring(0, val.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (isDigits(numeric) || isDigits(numeric.substring(1)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //Fall through\n            case 'd':\n            case 'D':\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // empty catch\n                }\n                //Fall through\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int, long, bigint\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            return createBigInteger(val);\n        } else {\n            //Must be a float, double, BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                Double d = createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            return createBigDecimal(val);\n        }\n    }\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -14.77282084523164,
      "mean_entropy": -0.013540624056124327
    },
    {
      "patch": "\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(0)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            return createBigInteger(numeric);\n                        }\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n            }\n        }\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -18.317506889872877,
      "mean_entropy": -0.019363115105573866
    },
    {
      "patch": "\npublic static Number createNumber(String val) throws NumberFormatException {\n    if (val == null) {\n        return null;\n    }\n    if (val.length() == 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }   \n    char lastChar = val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = val.indexOf('.');\n    int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec = val.substring(decPos + 1, expPos);\n        } else {\n            dec = val.substring(decPos + 1);\n        }\n        mant = val.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = val.substring(0, expPos);\n        } else {\n            mant = val;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = val.substring(0, val.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.length() == 1 || numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //Fall through\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // empty catch\n                }\n                //Fall through\n            default :\n                throw new NumberFormatException(val + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            return createBigInteger(val);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                Double d = createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n\n            return createBigDecimal(val);\n\n        }\n\n    }\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -7.400398950081711,
      "mean_entropy": -0.006637129103212297
    },
    {
      "patch": "\npublic static Number createNumber(String val) throws NumberFormatException {\n    if (val == null) {\n        return null;\n    }\n    if (val.length() == 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }   \n    char lastChar = val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = val.indexOf('.');\n    int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec = val.substring(decPos + 1, expPos);\n        } else {\n            dec = val.substring(decPos + 1);\n        }\n        mant = val.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = val.substring(0, expPos);\n        } else {\n            mant = val;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = val.substring(0, val.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && (numeric.length() > 1 && isDigits(numeric.substring(1)) || numeric.length() == 1) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //Fall through\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // empty catch\n                }\n                //Fall through\n            default :\n                throw new NumberFormatException(val + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            return createBigInteger(val);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                Double d = createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n\n            return createBigDecimal(val);\n\n        }\n\n    }\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -7.685585333508046,
      "mean_entropy": -0.00683770937144844
    },
    {
      "patch": "\npublic static Number createNumber(String val) throws NumberFormatException {\n    if (val == null) {\n        return null;\n    }\n    if (val.length() == 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }   \n    char lastChar = val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = val.indexOf('.');\n    int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec = val.substring(decPos + 1, expPos);\n        } else {\n            dec = val.substring(decPos + 1);\n        }\n        mant = val.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = val.substring(0, expPos);\n        } else {\n            mant = val;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = val.substring(0, val.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && numeric.length() > 1 && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //Fall through\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // empty catch\n                }\n                //Fall through\n            default :\n                throw new NumberFormatException(val + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            return createBigInteger(val);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                Double d = createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n\n            return createBigDecimal(val);\n\n        }\n\n    }\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -7.081414171776748,
      "mean_entropy": -0.006351044100248205
    },
    {
      "patch": "\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && (numeric.length() > 1 && isDigits(numeric.substring(1)) || numeric.length() == 1) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -7.490200651057376,
      "mean_entropy": -0.0066520432069781315
    },
    {
      "patch": "\npublic static Number createNumber(String val) throws NumberFormatException {\n    if (val == null) {\n        return null;\n    }\n    if (val.length() == 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n        return createInteger(val);\n    }   \n    char lastChar = val.charAt(val.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = val.indexOf('.');\n    int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            dec = val.substring(decPos + 1, expPos);\n        } else {\n            dec = val.substring(decPos + 1);\n        }\n        mant = val.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = val.substring(0, expPos);\n        } else {\n            mant = val;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length() - 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = val.substring(0, val.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l':\n            case 'L':\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(0)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            case 'f':\n            case 'F':\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //Fall through\n            case 'd':\n            case 'D':\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // empty catch\n                }\n                //Fall through\n            default:\n                throw new NumberFormatException(val + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < val.length() - 1) {\n            exp = val.substring(expPos + 1, val.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                return createLong(val);\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            return createBigInteger(val);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(val);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n            try {\n                Double d = createDouble(val);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // empty catch\n            }\n\n            return createBigDecimal(val);\n\n        }\n\n    }\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.math.NumberUtilsTest::testLang300\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.math.NumberUtilsTest::testLang300",
        [
          "org.apache.commons.lang.math.NumberUtilsTest::testLang300"
        ]
      ],
      "sum_entropy": -13.050401190679251,
      "mean_entropy": -0.01188561128477163
    }
  ],
  "Lang_59": [
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n/**\n * Appends an object to the builder padding on the left to a fixed width.\n * The <code>toString</code> of the object is used.\n * If the object is larger than the length, the left hand side is lost.\n * If the object is null, the null text value is used.\n * \n * @param obj  the object to append, null uses null text\n * @param width  the fixed field width, zero or negative has no effect\n * @param padChar  the pad character to use\n * @return this, to enable chaining\n */\npublic StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -2.831411991477759,
      "mean_entropy": -0.01011218568384914
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.3700706989543999,
      "mean_entropy": -0.0012630399281720133
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.36187890618757956,
      "mean_entropy": -0.0012350815910838894
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.36187890618757956,
      "mean_entropy": -0.0012350815910838894
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.36187890618757956,
      "mean_entropy": -0.0012350815910838894
    },
    {
      "patch": "\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 4,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299",
        [
          "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299"
        ]
      ],
      "sum_entropy": -0.36187890618757956,
      "mean_entropy": -0.0012350815910838894
    }
  ],
  "Lang_6": [
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n        out.write(input.toString());\n    } else {\n        out.write(CSV_QUOTE);\n        out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n        out.write(CSV_QUOTE);\n    }\n    return Character.codePointCount(input, 0, input.length());\n}\n",
      "index": 1,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 9,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
      ],
      "failing_tests": [],
      "sum_entropy": -3.678334659477599,
      "mean_entropy": -0.03753402713752652
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n            if (index < 0 || index >= input.length()) {\n                throw new IllegalArgumentException(\"Invalid index provided\");\n            }\n\n            if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n                out.write(input.subSequence(index, input.length()).toString());\n            } else {\n                out.write(CSV_QUOTE);\n                out.write(StringUtils.replace(input.subSequence(index, input.length()).toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n                out.write(CSV_QUOTE);\n            }\n            return input.length() - index;\n        }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -8.221921418951283,
      "mean_entropy": -0.06090312162186135
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n        out.write(input.toString());\n    } else {\n        out.write(CSV_QUOTE);\n        out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n        out.write(CSV_QUOTE);\n    }\n    return input.length();\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -3.2820000562026004,
      "mean_entropy": -0.03687640512587191
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n        out.write(input.toString());\n    } else {\n        out.write(CSV_QUOTE);\n        out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n        out.write(CSV_QUOTE);\n    }\n    return input.length();\n}\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -3.2820000562026004,
      "mean_entropy": -0.03687640512587191
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n        out.write(input.toString());\n    } else {\n        out.write(CSV_QUOTE);\n        out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n        out.write(CSV_QUOTE);\n    }\n    return input.length();\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -2.8406335066301986,
      "mean_entropy": -0.031917230411575265
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if (index != 0) {\n        throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n    }\n\n    String inputString = input.toString();\n    if (StringUtils.containsNone(inputString, CSV_SEARCH_CHARS)) {\n        out.write(inputString);\n    } else {\n        out.write(CSV_QUOTE);\n        out.write(StringUtils.replace(inputString, CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n        out.write(CSV_QUOTE);\n    }\n    return inputString.length();\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -6.959614332640906,
      "mean_entropy": -0.05523503438603894
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n\n            if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n                out.write(input.toString());\n            } else {\n                out.write(CSV_QUOTE);\n                out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n                out.write(CSV_QUOTE);\n            }\n            return input.length();\n        }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -3.718371825323882,
      "mean_entropy": -0.03998249274541808
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n        out.write(input.toString());\n    } else {\n        out.write(CSV_QUOTE);\n        out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n        out.write(CSV_QUOTE);\n    }\n    return input.length();\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -2.8406335066301986,
      "mean_entropy": -0.031917230411575265
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    if (index != 0) {\n        throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n    }\n\n    String inputString = input.toString();\n    if (StringUtils.containsNone(inputString, CSV_SEARCH_CHARS)) {\n        out.write(inputString);\n    } else {\n        out.write(CSV_QUOTE);\n        out.write(StringUtils.replace(inputString, CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n        out.write(CSV_QUOTE);\n    }\n    return inputString.codePointCount(0, inputString.length());\n}\n",
      "index": 10,
      "validation": "plausible",
      "validation_wo": "plausible",
      "errors": [],
      "total_trigger": 1,
      "passing_trigger": 1,
      "total_relevant": 9,
      "failing_relevant": 0,
      "passing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
      ],
      "failing_tests": [],
      "sum_entropy": -7.863075828566962,
      "mean_entropy": -0.05867967036244001
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n        out.write(input.toString());\n    } else {\n        out.write(CSV_QUOTE);\n        out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n        out.write(CSV_QUOTE);\n    }\n    return input.length();\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -2.8406335066301986,
      "mean_entropy": -0.031917230411575265
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n\n            if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n                out.write(input.toString());\n            } else {\n                out.write(CSV_QUOTE);\n                out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n                out.write(CSV_QUOTE);\n            }\n            return input.length();\n        }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -3.718371825323882,
      "mean_entropy": -0.03998249274541808
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n            if (index != 0) {\n                throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n            }\n\n            if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n                out.write(input.toString());\n            } else {\n                out.write(CSV_QUOTE);\n                out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n                out.write(CSV_QUOTE);\n            }\n            return input.length();\n        }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -6.029309868640879,
      "mean_entropy": -0.049829007178850235
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if (index != 0) {\n        throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n    }\n\n    String inputStr = input.toString();\n\n    if (StringUtils.containsNone(inputStr, CSV_SEARCH_CHARS)) {\n        out.write(inputStr);\n    } else {\n        out.write(CSV_QUOTE);\n        out.write(StringUtils.replace(inputStr, CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n        out.write(CSV_QUOTE);\n    }\n    return input.length();\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -8.890899471470684,
      "mean_entropy": -0.07112719577176548
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n\n            if(index != 0) {\n                throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n            }\n\n            if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n                out.write(input.toString());\n            } else {\n                out.write(CSV_QUOTE);\n                out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n                out.write(CSV_QUOTE);\n            }\n            return input.length();\n        }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -4.26107034800503,
      "mean_entropy": -0.03550891956670858
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if (index != 0) {\n        throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n    }\n\n    if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n        out.write(input.toString());\n    } else {\n        out.write(CSV_QUOTE);\n        out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n        out.write(CSV_QUOTE);\n    }\n    return input.length();\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -5.291006435503147,
      "mean_entropy": -0.045222277226522625
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n        out.write(input.toString());\n    } else {\n        out.write(CSV_QUOTE);\n        out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n        out.write(CSV_QUOTE);\n    }\n    return input.length();\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -3.166872959944599,
      "mean_entropy": -0.035582842246568526
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n\n            if (index != 0) {\n                throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n            }\n\n            if (input.length() == 0) {\n                return 0;\n            }\n\n            if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n                out.write(input.toString());\n                return input.length();\n            }\n\n            // strip quotes\n            String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n            if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n                // deal with escaped quotes; ie) \"\"\n                out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n            } else {\n                out.write(input.toString());\n            }\n            return input.length();\n        }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -5.81370489775066,
      "mean_entropy": -0.028780717315597327
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    if (index != 0) {\n        throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n    }\n\n    if (input.length() < 2 || input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    // strip quotes\n    String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n        // deal with escaped quotes; ie) \"\"\n        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n    } else {\n        out.write(input.toString());\n    }\n    return input.length();\n}\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -5.069595146051593,
      "mean_entropy": -0.027110134470864133
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n\n            if (index != 0) {\n                throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n            }\n\n            if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n                out.write(input.toString());\n                return input.length();\n            }\n\n            // strip quotes\n            String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n            if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n                // deal with escaped quotes; ie) \"\"\n                out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n            } else {\n                out.write(input.toString());\n            }\n            return input.length();\n        }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -5.922257910779675,
      "mean_entropy": -0.03218618429771562
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n\n            if (input.length() == 0) {\n                return 0;\n            }\n\n            if (index != 0) {\n                throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n            }\n\n            if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n                out.write(input.toString());\n                return input.length();\n            }\n\n            // strip quotes\n            String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n            if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n                // deal with escaped quotes; ie) \"\"\n                out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n            } else {\n                out.write(input.toString());\n            }\n            return input.length();\n        }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -6.365905681969493,
      "mean_entropy": -0.03151438456420541
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    if (input.length() == 0) {\n        return 0;\n    }\n\n    if (index != 0) {\n        throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n    }\n\n    char firstChar = input.charAt(0);\n    char lastChar = input.charAt(input.length() - 1);\n\n    if (firstChar != CSV_QUOTE || lastChar != CSV_QUOTE) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    // strip quotes\n    String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n        // deal with escaped quotes; ie) \"\"\n        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n    } else {\n        out.write(input.toString());\n    }\n    return input.length();\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -7.586739055122614,
      "mean_entropy": -0.03578650497699346
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if (input.length() == 0) {\n        return 0;\n    }\n\n    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    // strip quotes\n    String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n        // deal with escaped quotes; ie) \"\"\n        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n    } else {\n        out.write(input.toString());\n    }\n    return input.length();\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -5.411599805681123,
      "mean_entropy": -0.032021300625332094
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n            if (index != 0) {\n                throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n            }\n\n            if (input.length() < 2 || input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n                out.write(input.toString());\n                return input.length();\n            }\n\n            // strip quotes\n            String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n            if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n                // deal with escaped quotes; ie) \"\"\n                out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n            } else {\n                out.write(input.toString());\n            }\n            return input.length();\n        }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -6.031433235575002,
      "mean_entropy": -0.03157818447945027
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n\n            if(index != 0) {\n                throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n            }\n\n            if (input.length() == 0) {\n                return 0;\n            }\n\n            if ( input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\n                out.write(input.toString());\n                return input.length();\n            }\n\n            // strip quotes\n            String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n            if ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n                // deal with escaped quotes; ie) \"\"\n                out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n            } else {\n                out.write(input.toString());\n            }\n            return input.length();\n        }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -5.626810396263328,
      "mean_entropy": -0.027855497011204593
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n\n            if(index != 0) {\n                throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n            }\n\n            if (input.length() < 2 || input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n                out.write(input.toString());\n                return input.length();\n            }\n\n            // strip quotes\n            String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n            if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n                // deal with escaped quotes; ie) \"\"\n                out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n            } else {\n                out.write(input.toString());\n            }\n            return input.length();\n        }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -4.8030497004366906,
      "mean_entropy": -0.025279208949666794
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n\n            if(index != 0) {\n                throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n            }\n\n            if (input.length() == 0 || input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n                out.write(input.toString());\n                return input.length();\n            }\n\n            // strip quotes\n            String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n            if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n                // deal with escaped quotes; ie) \"\"\n                out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n            } else {\n                out.write(input.toString());\n            }\n            return input.length();\n        }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -4.193461052242249,
      "mean_entropy": -0.022070847643380256
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if (input == null || input.length() == 0) {\n        return 0;\n    }\n\n    if (index != 0) {\n        throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n    }\n\n    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    // strip quotes\n    String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n        // deal with escaped quotes; ie) \"\"\n        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n    } else {\n        out.write(input.toString());\n    }\n    return input.length();\n}\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -6.283527908571946,
      "mean_entropy": -0.031106573804811615
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    if(input.length() == 0) {\n        return 0;\n    }\n\n    if(index != 0) {\n        throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n    }\n\n    if ( input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    // strip quotes\n    String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n    if ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n        // deal with escaped quotes; ie) \"\"\n        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n    } else {\n        out.write(input.toString());\n    }\n    return input.length();\n}\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -6.660714823470574,
      "mean_entropy": -0.03381073514452068
    },
    {
      "patch": "\n        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n\n            if(index != 0) {\n                throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n            }\n\n            if (input.length() == 0 || input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n                out.write(input.toString());\n                return input.length();\n            }\n\n            // strip quotes\n            String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n            if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n                // deal with escaped quotes; ie) \"\"\n                out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n            } else {\n                out.write(input.toString());\n            }\n            return input.length();\n        }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -4.193461052242249,
      "mean_entropy": -0.022070847643380256
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    if (index < 0 || index >= input.length()) {\n        throw new IllegalArgumentException(\"Invalid index provided\");\n    }\n\n    char firstChar = input.charAt(index);\n    char lastChar = input.charAt(input.length() - 1);\n    \n    if (firstChar != CSV_QUOTE || lastChar != CSV_QUOTE) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    // strip quotes\n    String quoteless = input.subSequence(index + 1, input.length() - 1).toString();\n\n    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n        // deal with escaped quotes; ie) \"\"\n        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n    } else {\n        out.write(input.toString());\n    }\n    return input.length();\n}\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -10.92777586663043,
      "mean_entropy": -0.05691549930536682
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if (input.length() < 2) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    char firstChar = input.charAt(0);\n    char lastChar = input.charAt(input.length() - 1);\n\n    if (firstChar != CSV_QUOTE || lastChar != CSV_QUOTE) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    // strip quotes\n    String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n        // deal with escaped quotes; ie) \"\"\n        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n    } else {\n        out.write(input.toString());\n    }\n    return input.length();\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -7.978516143566905,
      "mean_entropy": -0.04221437112998362
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if(index != 0) {\n        throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n    }\n\n    if ( input.length() == 0 || input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    // strip quotes\n    String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n    if ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n        // deal with escaped quotes; ie) \"\"\n        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n    } else {\n        out.write(input.toString());\n    }\n    return input.length();\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -4.612433016223711,
      "mean_entropy": -0.024665417199057276
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n\n    if (index != 0) {\n        throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n    }\n\n    if (input.length() == 0) {\n        return 0;\n    }\n\n    char firstChar = input.charAt(0);\n    char lastChar = input.charAt(input.length() - 1);\n\n    if (firstChar != CSV_QUOTE || lastChar != CSV_QUOTE) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    // strip quotes\n    String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n        // deal with escaped quotes; ie) \"\"\n        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n    } else {\n        out.write(input.toString());\n    }\n    return input.length();\n}\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -7.025009464622165,
      "mean_entropy": -0.033136837097274364
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    if (index != 0) {\n        throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n    }\n\n    if (input.length() == 0 || input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    // strip quotes\n    String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n        // deal with escaped quotes; ie) \"\"\n        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n    } else {\n        out.write(input.toString());\n    }\n    return input.length();\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -4.521062293803641,
      "mean_entropy": -0.024176803710179898
    },
    {
      "patch": "\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    if (index != 0) {\n        throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n    }\n\n    if (input.length() == 0) {\n        return 0;\n    }\n\n    if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) {\n        out.write(input.toString());\n        return input.length();\n    }\n\n    // strip quotes\n    String quoteless = input.subSequence(1, input.length() - 1).toString();\n\n    if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) {\n        // deal with escaped quotes; ie) \"\"\n        out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n    } else {\n        out.write(input.toString());\n    }\n    return input.length();\n}\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs\n",
        "Useless use of a variable in void context at /data2/chengmingzhang/br2fix/FL/FL/tools/defects4j-2.0.0/framework/core/Project/Lang.pm line 92.\nRunning ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs",
        [
          "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs"
        ]
      ],
      "sum_entropy": -5.550806287391206,
      "mean_entropy": -0.02803437518884447
    }
  ],
  "Math_15": [
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -1.0322297302061185,
      "mean_entropy": -0.002253776703506809
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -1.0322297302061185,
      "mean_entropy": -0.002253776703506809
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -3.330183777906119,
      "mean_entropy": -0.007271143619882356
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -1.0322297302061185,
      "mean_entropy": -0.002253776703506809
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -3.330183777906119,
      "mean_entropy": -0.007271143619882356
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -1.0322297302061185,
      "mean_entropy": -0.002253776703506809
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -1.0322297302061185,
      "mean_entropy": -0.002253776703506809
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -1.0322297302061185,
      "mean_entropy": -0.002253776703506809
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -1.0322297302061185,
      "mean_entropy": -0.002253776703506809
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -1.0322297302061185,
      "mean_entropy": -0.002253776703506809
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -1.0322297302061185,
      "mean_entropy": -0.002253776703506809
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -1.0322297302061185,
      "mean_entropy": -0.002253776703506809
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -1.0322297302061185,
      "mean_entropy": -0.002253776703506809
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.7362633685314395,
      "mean_entropy": -0.001607561940024977
    },
    {
      "patch": "\n    /** Compute integer power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param n power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final int n,\n                    final double[] result, final int resultOffset) {\n\n        if (n == 0) {\n            // special case, x^0 = 1 for all x\n            result[resultOffset] = 1.0;\n            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n            return;\n        }\n\n        // create the power function value and derivatives\n        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n        double[] function = new double[1 + order];\n\n        if (n > 0) {\n            // strictly positive power\n            final int maxOrder = FastMath.min(order, n);\n            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n            for (int i = maxOrder; i > 0; --i) {\n                function[i] = xk;\n                xk *= operand[operandOffset];\n            }\n            function[0] = xk;\n        } else {\n            // strictly negative power\n            final double inv = 1.0 / operand[operandOffset];\n            double xk = FastMath.pow(inv, -n);\n            for (int i = 0; i <= order; ++i) {\n                function[i] = xk;\n                xk *= inv;\n            }\n        }\n\n        double coefficient = n;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= n - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.7362633685314395,
      "mean_entropy": -0.001607561940024977
    },
    {
      "patch": "\npublic static Dfp pow(Dfp x, final Dfp y) {\n\n    // make sure we don't mix number with different precision\n    if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = x.newInstance(x.getZero());\n        result.nans = Dfp.QNAN;\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n    }\n\n    final Dfp zero = x.getZero();\n    final Dfp one  = x.getOne();\n    final Dfp two  = x.getTwo();\n    boolean invert = false;\n    int ui;\n\n    /* Check for special cases */\n    if (y.equals(zero)) {\n        return x.newInstance(one);\n    }\n\n    if (y.equals(one)) {\n        if (x.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n        }\n        return x;\n    }\n\n    if (x.isNaN() || y.isNaN()) {\n        // Test for NaNs\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n    }\n\n    // X == 0\n    if (x.equals(zero)) {\n        if (Dfp.copysign(one, x).greaterThan(zero)) {\n            // X == +0\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n            }\n        } else {\n            // X == -0\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero.negate());\n                } else {\n                    return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            }\n        }\n    }\n\n    if (x.lessThan(zero)) {\n        // Make x positive, but keep track of it\n        x = x.negate();\n        invert = true;\n    }\n\n    if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return y;\n        } else {\n            return x.newInstance(zero);\n        }\n    }\n\n    if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return x.newInstance(zero);\n        } else {\n            return x.newInstance(Dfp.copysign(y, one));\n        }\n    }\n\n    if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n    }\n\n    if (x.classify() == Dfp.INFINITE) {\n        // x = +/- inf\n        if (invert) {\n            // negative infinity\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero.negate());\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        } else {\n            // positive infinity\n            if (y.greaterThan(zero)) {\n                return x;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n    }\n\n    if (invert && !y.rint().equals(y)) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n    }\n\n    // End special cases\n\n    Dfp r;\n    if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n        final Dfp u = y.rint();\n        ui = u.intValue();\n\n        final Dfp v = y.subtract(u);\n\n        if (v.unequal(zero)) {\n            final Dfp a = v.multiply(log(x));\n            final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n            final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n            r = splitPow(split(x), ui);\n            r = r.multiply(pow(two, b.intValue()));\n            r = r.multiply(exp(c));\n        } else {\n            r = splitPow(split(x), ui);\n        }\n    } else {\n        // very large exponent.  |y| > 2e8\n        r = exp(log(x).multiply(y));\n    }\n\n    if (invert) {\n        // if y is odd integer\n        if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n            r = r.negate();\n        }\n    }\n\n    return x.newInstance(r);\n\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -4.577195687615951,
      "mean_entropy": -0.003584334915909124
    },
    {
      "patch": "\n    /** Computes x to the y power.<p>\n     *\n     *  Uses the following method:<p>\n     *\n     *  <ol>\n     *  <li> Set u = rint(y), v = y-u\n     *  <li> Compute a = v * ln(x)\n     *  <li> Compute b = rint( a/ln(2) )\n     *  <li> Compute c = a - b*ln(2)\n     *  <li> x<sup>y</sup> = x<sup>u</sup>  *   2<sup>b</sup> * e<sup>c</sup>\n     *  </ol>\n     *  if |y| > 1e8, then we compute by exp(y*ln(x))   <p>\n     *\n     *  <b>Special Cases</b><p>\n     *  <ul>\n     *  <li>  if y is 0.0 or -0.0 then result is 1.0\n     *  <li>  if y is 1.0 then result is x\n     *  <li>  if y is NaN then result is NaN\n     *  <li>  if x is NaN and y is not zero then result is NaN\n     *  <li>  if |x| > 1.0 and y is +Infinity then result is +Infinity\n     *  <li>  if |x| < 1.0 and y is -Infinity then result is +Infinity\n     *  <li>  if |x| > 1.0 and y is -Infinity then result is +0\n     *  <li>  if |x| < 1.0 and y is +Infinity then result is +0\n     *  <li>  if |x| = 1.0 and y is +/-Infinity then result is NaN\n     *  <li>  if x = +0 and y > 0 then result is +0\n     *  <li>  if x = +Inf and y < 0 then result is +0\n     *  <li>  if x = +0 and y < 0 then result is +Inf\n     *  <li>  if x = +Inf and y > 0 then result is +Inf\n     *  <li>  if x = -0 and y > 0, finite, not odd integer then result is +0\n     *  <li>  if x = -0 and y < 0, finite, and odd integer then result is -Inf\n     *  <li>  if x = -Inf and y > 0, finite, and odd integer then result is -Inf\n     *  <li>  if x = -0 and y < 0, not finite odd integer then result is +Inf\n     *  <li>  if x = -Inf and y > 0, not finite odd integer then result is +Inf\n     *  <li>  if x < 0 and y > 0, finite, and odd integer then result is -(|x|<sup>y</sup>)\n     *  <li>  if x < 0 and y > 0, finite, and not integer then result is NaN\n     *  </ul>\n     *  @param x base to be raised\n     *  @param y power to which base should be raised\n     *  @return x<sup>y</sup>\n     */\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 1e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -3.014967380755954,
      "mean_entropy": -0.0014822848479626124
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 2e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.8108958728128988,
      "mean_entropy": -0.002197729376710632
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 1e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.5161082902221494,
      "mean_entropy": -0.0019672465130743935
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 2e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.8108958728128988,
      "mean_entropy": -0.002197729376710632
    },
    {
      "patch": "\n/** Computes x to the y power.<p>\n *\n *  Uses the following method:<p>\n *\n *  <ol>\n *  <li> Set u = rint(y), v = y-u\n *  <li> Compute a = v * ln(x)\n *  <li> Compute b = rint( a/ln(2) )\n *  <li> Compute c = a - b*ln(2)\n *  <li> x<sup>y</sup> = x<sup>u</sup>  *   2<sup>b</sup> * e<sup>c</sup>\n *  </ol>\n *  if |y| > 1e8, then we compute by exp(y*ln(x))   <p>\n *\n *  <b>Special Cases</b><p>\n *  <ul>\n *  <li>  if y is 0.0 or -0.0 then result is 1.0\n *  <li>  if y is 1.0 then result is x\n *  <li>  if y is NaN then result is NaN\n *  <li>  if x is NaN and y is not zero then result is NaN\n *  <li>  if |x| > 1.0 and y is +Infinity then result is +Infinity\n *  <li>  if |x| < 1.0 and y is -Infinity then result is +Infinity\n *  <li>  if |x| > 1.0 and y is -Infinity then result is +0\n *  <li>  if |x| < 1.0 and y is +Infinity then result is +0\n *  <li>  if |x| = 1.0 and y is +/-Infinity then result is NaN\n *  <li>  if x = +0 and y > 0 then result is +0\n *  <li>  if x = +Inf and y < 0 then result is +0\n *  <li>  if x = +0 and y < 0 then result is +Inf\n *  <li>  if x = +Inf and y > 0 then result is +Inf\n *  <li>  if x = -0 and y > 0, finite, not odd integer then result is +0\n *  <li>  if x = -0 and y < 0, finite, and odd integer then result is -Inf\n *  <li>  if x = -Inf and y > 0, finite, and odd integer then result is -Inf\n *  <li>  if x = -0 and y < 0, not finite odd integer then result is +Inf\n *  <li>  if x = -Inf and y > 0, not finite odd integer then result is +Inf\n *  <li>  if x < 0 and y > 0, finite, and odd integer then result is -(|x|<sup>y</sup>)\n *  <li>  if x < 0 and y > 0, finite, and not integer then result is NaN\n *  </ul>\n *  @param x base to be raised\n *  @param y power to which base should be raised\n *  @return x<sup>y</sup>\n */\npublic static Dfp pow(Dfp x, final Dfp y) {\n\n    // make sure we don't mix number with different precision\n    if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = x.newInstance(x.getZero());\n        result.nans = Dfp.QNAN;\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n    }\n\n    final Dfp zero = x.getZero();\n    final Dfp one  = x.getOne();\n    final Dfp two  = x.getTwo();\n    boolean invert = false;\n    int ui;\n\n    /* Check for special cases */\n    if (y.equals(zero)) {\n        return x.newInstance(one);\n    }\n\n    if (y.equals(one)) {\n        if (x.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n        }\n        return x;\n    }\n\n    if (x.isNaN() || y.isNaN()) {\n        // Test for NaNs\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n    }\n\n    // X == 0\n    if (x.equals(zero)) {\n        if (Dfp.copysign(one, x).greaterThan(zero)) {\n            // X == +0\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n            }\n        } else {\n            // X == -0\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero.negate());\n                } else {\n                    return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            }\n        }\n    }\n\n    if (x.lessThan(zero)) {\n        // Make x positive, but keep track of it\n        x = x.negate();\n        invert = true;\n    }\n\n    if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return y;\n        } else {\n            return x.newInstance(zero);\n        }\n    }\n\n    if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return x.newInstance(zero);\n        } else {\n            return x.newInstance(Dfp.copysign(y, one));\n        }\n    }\n\n    if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n    }\n\n    if (x.classify() == Dfp.INFINITE) {\n        // x = +/- inf\n        if (invert) {\n            // negative infinity\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero.negate());\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        } else {\n            // positive infinity\n            if (y.greaterThan(zero)) {\n                return x;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n    }\n\n    if (invert && !y.rint().equals(y)) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n    }\n\n    // End special cases\n\n    Dfp r;\n    if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n        final Dfp u = y.rint();\n        ui = u.intValue();\n\n        final Dfp v = y.subtract(u);\n\n        if (v.unequal(zero)) {\n            final Dfp a = v.multiply(log(x));\n            final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n            final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n            r = splitPow(split(x), ui);\n            r = r.multiply(pow(two, b.intValue()));\n            r = r.multiply(exp(c));\n        } else {\n            r = splitPow(split(x), ui);\n        }\n    } else {\n        // very large exponent.  |y| > 1e8\n        r = exp(log(x).multiply(y));\n    }\n\n    if (invert) {\n        // if y is odd integer\n        if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n            r = r.negate();\n        }\n    }\n\n    return x.newInstance(r);\n\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -4.924459077654806,
      "mean_entropy": -0.0024721180108708864
    },
    {
      "patch": "\npublic static Dfp pow(Dfp x, final Dfp y) {\n\n    // make sure we don't mix number with different precision\n    if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = x.newInstance(x.getZero());\n        result.nans = Dfp.QNAN;\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n    }\n\n    final Dfp zero = x.getZero();\n    final Dfp one  = x.getOne();\n    final Dfp two  = x.getTwo();\n    boolean invert = false;\n    int ui;\n\n    /* Check for special cases */\n    if (y.equals(zero)) {\n        return x.newInstance(one);\n    }\n\n    if (y.equals(one)) {\n        if (x.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n        }\n        return x;\n    }\n\n    if (x.isNaN() || y.isNaN()) {\n        // Test for NaNs\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n    }\n\n    // X == 0\n    if (x.equals(zero)) {\n        if (Dfp.copysign(one, x).greaterThan(zero)) {\n            // X == +0\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n            }\n        } else {\n            // X == -0\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero.negate());\n                } else {\n                    return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            }\n        }\n    }\n\n    if (x.lessThan(zero)) {\n        // Make x positive, but keep track of it\n        x = x.negate();\n        invert = true;\n    }\n\n    if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return y;\n        } else {\n            return x.newInstance(zero);\n        }\n    }\n\n    if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return x.newInstance(zero);\n        } else {\n            return x.newInstance(Dfp.copysign(y, one));\n        }\n    }\n\n    if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n    }\n\n    if (x.classify() == Dfp.INFINITE) {\n        // x = +/- inf\n        if (invert) {\n            // negative infinity\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero.negate());\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        } else {\n            // positive infinity\n            if (y.greaterThan(zero)) {\n                return x;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n    }\n\n    if (invert && !y.rint().equals(y)) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n    }\n\n    // End special cases\n\n    Dfp r;\n    if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n        final Dfp u = y.rint();\n        ui = u.intValue();\n\n        final Dfp v = y.subtract(u);\n\n        if (v.unequal(zero)) {\n            final Dfp a = v.multiply(log(x));\n            final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n            final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n            r = splitPow(split(x), ui);\n            r = r.multiply(pow(two, b.intValue()));\n            r = r.multiply(exp(c));\n        } else {\n            r = splitPow(split(x), ui);\n        }\n    } else {\n        // very large exponent.  |y| > 2e8\n        r = exp(log(x).multiply(y));\n    }\n\n    if (invert) {\n        // if y is odd integer\n        if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n            r = r.negate();\n        }\n    }\n\n    return x.newInstance(r);\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -6.42913269061595,
      "mean_entropy": -0.005034559663755638
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 1e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -3.122214377441237,
      "mean_entropy": -0.0024411371207515536
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 2e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -4.9800765686528985,
      "mean_entropy": -0.003893726793317356
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 1e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.5161082902221494,
      "mean_entropy": -0.0019672465130743935
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 2e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.8108958728128988,
      "mean_entropy": -0.002197729376710632
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one = x.getOne();\n        final Dfp two = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        // Check for special cases\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            if (invert) {\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -10.738219843661215,
      "mean_entropy": -0.009329469890235633
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 1e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.5161082902221494,
      "mean_entropy": -0.0019672465130743935
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 1e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -4.85808465632215,
      "mean_entropy": -0.0037983460956388976
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 1e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.6003479294387275,
      "mean_entropy": -0.0020331101872077617
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 2e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.588629501720119,
      "mean_entropy": -0.00202394800759978
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 1e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.523073920332809,
      "mean_entropy": -0.0019726926664056367
    },
    {
      "patch": "\n    public static Dfp pow(Dfp x, final Dfp y) {\n\n        // make sure we don't mix number with different precision\n        if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = x.newInstance(x.getZero());\n            result.nans = Dfp.QNAN;\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n        }\n\n        final Dfp zero = x.getZero();\n        final Dfp one  = x.getOne();\n        final Dfp two  = x.getTwo();\n        boolean invert = false;\n        int ui;\n\n        /* Check for special cases */\n        if (y.equals(zero)) {\n            return x.newInstance(one);\n        }\n\n        if (y.equals(one)) {\n            if (x.isNaN()) {\n                // Test for NaNs\n                x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n            }\n            return x;\n        }\n\n        if (x.isNaN() || y.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // X == 0\n        if (x.equals(zero)) {\n            if (Dfp.copysign(one, x).greaterThan(zero)) {\n                // X == +0\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                }\n            } else {\n                // X == -0\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero.negate());\n                    } else {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(zero);\n                    } else {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    }\n                }\n            }\n        }\n\n        if (x.lessThan(zero)) {\n            // Make x positive, but keep track of it\n            x = x.negate();\n            invert = true;\n        }\n\n        if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return y;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n\n        if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(Dfp.copysign(y, one));\n            }\n        }\n\n        if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (x.classify() == Dfp.INFINITE) {\n            // x = +/- inf\n            if (invert) {\n                // negative infinity\n                if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                    // If y is odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)-1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero.negate());\n                    }\n                } else {\n                    // Y is not odd integer\n                    if (y.greaterThan(zero)) {\n                        return x.newInstance(x.newInstance((byte)1, Dfp.INFINITE));\n                    } else {\n                        return x.newInstance(zero);\n                    }\n                }\n            } else {\n                // positive infinity\n                if (y.greaterThan(zero)) {\n                    return x;\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        }\n\n        if (invert && !y.rint().equals(y)) {\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte)1, Dfp.QNAN));\n        }\n\n        // End special cases\n\n        Dfp r;\n        if (y.lessThan(x.newInstance(200000000)) && y.greaterThan(x.newInstance(-200000000))) {\n            final Dfp u = y.rint();\n            ui = u.intValue();\n\n            final Dfp v = y.subtract(u);\n\n            if (v.unequal(zero)) {\n                final Dfp a = v.multiply(log(x));\n                final Dfp b = a.divide(x.getField().getLn2()).rint();\n\n                final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n                r = splitPow(split(x), ui);\n                r = r.multiply(pow(two, b.intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(x), ui);\n            }\n        } else {\n            // very large exponent.  |y| > 1e8\n            r = exp(log(x).multiply(y));\n        }\n\n        if (invert) {\n            // if y is odd integer\n            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                r = r.negate();\n            }\n        }\n\n        return x.newInstance(r);\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -4.915616315908728,
      "mean_entropy": -0.0038433278466839154
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = Math.pow(operand[operandOffset], p - order); // Using Math.pow instead of FastMath.pow\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -4.9485601517666575,
      "mean_entropy": -0.016278158393969268
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = Math.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.7118492768199887,
      "mean_entropy": -0.009223977132040777
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.56983524121248,
      "mean_entropy": -0.0019316448854660338
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = Math.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.7118492768199887,
      "mean_entropy": -0.009223977132040777
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.61445340143717,
      "mean_entropy": -0.0020828928862276948
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = Math.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -2.1888158045719908,
      "mean_entropy": -0.007444951716231261
    },
    {
      "patch": "\n    /** Compute power of a derivative structure.\n     * @param operand array holding the operand\n     * @param operandOffset offset of the operand in its array\n     * @param p power to apply\n     * @param result array where result must be stored (for\n     * power the result array <em>cannot</em> be the input\n     * array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void pow(final double[] operand, final int operandOffset, final double p,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n        double[] function = new double[1 + order];\n        double xk = FastMath.pow(operand[operandOffset], p - order);\n        for (int i = order; i > 0; --i) {\n            function[i] = xk;\n            xk *= operand[operandOffset];\n        }\n        function[0] = xk;\n        double coefficient = p;\n        for (int i = 1; i <= order; ++i) {\n            function[i] *= coefficient;\n            coefficient *= p - i;\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -0.61445340143717,
      "mean_entropy": -0.0020828928862276948
    },
    {
      "patch": "\n/** Compute power of a derivative structure.\n * @param operand array holding the operand\n * @param operandOffset offset of the operand in its array\n * @param p power to apply\n * @param result array where result must be stored (for\n * power the result array <em>cannot</em> be the input\n * array)\n * @param resultOffset offset of the result in its array\n */\npublic void pow(final double[] operand, final int operandOffset, final double p,\n                final double[] result, final int resultOffset) {\n\n    // create the function value and derivatives\n    // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n    double[] function = new double[1 + order];\n    double xk = Math.pow(operand[operandOffset], p - order); // Use Math.pow instead of FastMath.pow\n    for (int i = order; i > 0; --i) {\n        function[i] = xk;\n        xk *= operand[operandOffset];\n    }\n    function[0] = xk;\n    double coefficient = p;\n    for (int i = 1; i <= order; ++i) {\n        function[i] *= coefficient;\n        coefficient *= p - i;\n    }\n\n    // apply function composition\n    compose(operand, operandOffset, function, result, resultOffset);\n\n}\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.util.FastMathTest::testMath904\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 263,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.util.FastMathTest::testMath904",
        [
          "org.apache.commons.math3.util.FastMathTest::testMath904"
        ]
      ],
      "sum_entropy": -8.935020907587255,
      "mean_entropy": -0.030494951903028172
    }
  ],
  "Math_26": [],
  "Math_39": [
    {
      "patch": "\n  /**\n   * Reinitialize the instance.\n   * <p>Some Runge-Kutta integrators need fewer function evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   *\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -7.062743998732009,
      "mean_entropy": -0.0171425825211942
    },
    {
      "patch": "\n  /** Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    super.reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -2.244245900471739,
      "mean_entropy": -0.005487153790884448
    },
    {
      "patch": "\n  /** Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    super.reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -2.244245900471739,
      "mean_entropy": -0.005487153790884448
    },
    {
      "patch": "\n  /** Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    super.reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -2.244245900471739,
      "mean_entropy": -0.005487153790884448
    },
    {
      "patch": "\n  /** Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -2.1313522321333394,
      "mean_entropy": -0.005223902529738577
    },
    {
      "patch": "\n  /** Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    super.reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -2.244245900471739,
      "mean_entropy": -0.005487153790884448
    },
    {
      "patch": "\n  /**\n   * Reinitialize the instance.\n   * <p>Some Runge-Kutta integrators need fewer function evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   *\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -7.062743998732009,
      "mean_entropy": -0.0171425825211942
    },
    {
      "patch": "\n  /** Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    super.reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -2.244245900471739,
      "mean_entropy": -0.005487153790884448
    },
    {
      "patch": "\n  /**\n   * Reinitialize the instance.\n   * <p>Some Runge-Kutta integrators need fewer function evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method to let the step interpolator perform\n   * the evaluations it needs. These evaluations will be performed during\n   * the call to <code>doFinalize</code> if any, i.e. only if the step\n   * handler either calls the {@link AbstractStepInterpolator#finalizeStep finalizeStep} method\n   * or the {@link AbstractStepInterpolator#getInterpolatedState getInterpolatedState} method\n   * (for an interpolator which needs finalization) or if it clones the step interpolator.</p>\n   *\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at the end of the step\n   * @param yDotArray reference to the integrator array holding all the intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    previousState = null;\n    yDotK = yDotArray;\n    integrator = rkIntegrator;\n  }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -17.700617337907925,
      "mean_entropy": -0.04492542471550235
    },
    {
      "patch": "\n  /**\n   * Reinitialize the instance.\n   * <p>\n   * Some Runge-Kutta integrators need fewer function evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.\n   * </p>\n   *\n   * @param rkIntegrator      integrator being used\n   * @param y                 reference to the integrator array holding the state at\n   *                          the end of the step\n   * @param yDotArray         reference to the integrator array holding all the\n   *                          intermediate slopes\n   * @param forward           integration direction indicator\n   * @param primaryMapper     equations mapper for the primary equations set\n   * @param secondaryMappers  equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    previousState = null;\n    yDotK = yDotArray;\n    integrator = rkIntegrator;\n  }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -11.77182397149461,
      "mean_entropy": -0.027895317467996707
    },
    {
      "patch": "\n  /** Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    super.reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -2.244245900471739,
      "mean_entropy": -0.005487153790884448
    },
    {
      "patch": "\n  /** Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -2.1313522321333394,
      "mean_entropy": -0.005223902529738577
    },
    {
      "patch": "\n  /** Reinitialize the instance\n   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n   * than their counterpart step interpolators. So the interpolator\n   * should perform the last evaluations they need by themselves. The\n   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n   * abstract classes call this method in order to let the step\n   * interpolator perform the evaluations it needs. These evaluations\n   * will be performed during the call to <code>doFinalize</code> if\n   * any, i.e. only if the step handler either calls the {@link\n   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n   * {@link AbstractStepInterpolator#getInterpolatedState\n   * getInterpolatedState} method (for an interpolator which needs a\n   * finalization) or if it clones the step interpolator.</p>\n   * @param rkIntegrator integrator being used\n   * @param y reference to the integrator array holding the state at\n   * the end of the step\n   * @param yDotArray reference to the integrator array holding all the\n   * intermediate slopes\n   * @param forward integration direction indicator\n   * @param primaryMapper equations mapper for the primary equations set\n   * @param secondaryMappers equations mappers for the secondary equations sets\n   */\n  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    super.reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -2.759442880789809,
      "mean_entropy": -0.0067468041095105355
    },
    {
      "patch": "\npublic void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward,\n                           final EquationsMapper primaryMapper,\n                           final EquationsMapper[] secondaryMappers) {\n    super.reinitialize(y, forward, primaryMapper, secondaryMappers);\n    this.previousState = null;\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n}\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -5.32643977251132,
      "mean_entropy": -0.05853230519243209
    },
    {
      "patch": "\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? Math.abs(step) : -Math.abs(step); // Fixed step size sign\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -10.914917021980996,
      "mean_entropy": -0.013660722180201496
    },
    {
      "patch": "\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        // stepsize control for next step\n        final double nextT = stepStart + stepSize;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        if (nextIsLast) {\n          stepSize = t - stepStart;\n        } else {\n          stepSize = forward ? Math.min(step, t - stepStart) : Math.max(-step, t - stepStart);\n        }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n\n  }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -8.254586107197712,
      "mean_entropy": -0.010128326511899034
    },
    {
      "patch": "\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        // stepsize control for next step\n        final double nextT = stepStart + stepSize;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        if (nextIsLast) {\n          stepSize = t - stepStart;\n        }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n\n  }\n\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -9.62535472884983,
      "mean_entropy": -0.01223043802903409
    },
    {
      "patch": "\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? Math.abs(step) : -Math.abs(step);\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -5.2590146328896505,
      "mean_entropy": -0.006631796510579635
    },
    {
      "patch": "\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        // stepsize control for next step\n        final double nextT = stepStart + stepSize;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        if (nextIsLast) {\n          stepSize = t - stepStart;\n        }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -12.41648316917416,
      "mean_entropy": -0.015939002784562464
    },
    {
      "patch": "\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n        equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize = forward ? Math.min(step, Math.abs(t - stepStart)) : -Math.min(step, Math.abs(t - stepStart));\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        // stepsize control for next step\n        final double nextT = stepStart + stepSize;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        if (nextIsLast) {\n          stepSize = t - stepStart;\n        }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n\n  }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -6.43750476736629,
      "mean_entropy": -0.008056952149394605
    },
    {
      "patch": "\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        // stepsize control for next step\n        final double nextT = stepStart + stepSize;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        if (nextIsLast) {\n          stepSize = t - stepStart;\n        } else {\n          stepSize = forward ? Math.abs(step) : -Math.abs(step);\n        }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n\n  }\n\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -10.579233910135974,
      "mean_entropy": -0.013109335700292409
    },
    {
      "patch": "\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n        equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? Math.abs(step) : -Math.abs(step);\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        // stepsize control for next step\n        final double nextT = stepStart + stepSize;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        if (nextIsLast) {\n          stepSize = t - stepStart;\n        }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -8.731606022113024,
      "mean_entropy": -0.011038692821887514
    },
    {
      "patch": "\n  // Fixed code:\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n        equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize = forward ? Math.min(step, Math.abs(t - stepStart)) : -Math.min(step, Math.abs(t - stepStart));\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        // stepsize control for next step\n        final double nextT = stepStart + stepSize;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        if (nextIsLast) {\n          stepSize = t - stepStart;\n        }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n\n  }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -12.371839723865104,
      "mean_entropy": -0.01538786035306605
    },
    {
      "patch": "\n//The fixed function:\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        // stepsize control for next step\n        final double nextT = stepStart + stepSize;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        if (nextIsLast) {\n          stepSize = t - stepStart;\n        } else {\n          if (nextIsLast && Math.abs(stepSize) > Math.abs(t - stepStart)) {\n            stepSize = t - stepStart;\n          }\n        }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n\n  }\n\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -19.489192475520237,
      "mean_entropy": -0.023537672071884345
    },
    {
      "patch": "\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    boolean firstTime = true; // Flag to handle first step size\n    do {\n      interpolator.shift();\n\n      if (firstTime) {\n        // Handle too large first step by reducing it to match the integration range\n        stepSize = Math.min(Math.abs(stepSize), Math.abs(t - stepStart)) * Math.signum(stepSize);\n        firstTime = false;\n      }\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        // stepsize control for next step\n        final double nextT = stepStart + stepSize;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        if (nextIsLast) {\n          stepSize = t - stepStart;\n        }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n\n  }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -36.01753060901358,
      "mean_entropy": -0.0423237727485471
    },
    {
      "patch": "\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        // stepsize control for next step\n        final double nextT = stepStart + stepSize;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        if (nextIsLast) {\n          stepSize = t - stepStart;\n        } else {\n          stepSize = forward ? Math.min(step, t - stepStart) : Math.max(-step, t - stepStart);\n        }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n\n  }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -8.469280512217534,
      "mean_entropy": -0.010391755229714765
    },
    {
      "patch": "\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n          // Added code to check if the step size is too large\n          if (Math.abs(stepSize) > Math.abs(t - stepStart)) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -18.911936020187635,
      "mean_entropy": -0.022785465084563417
    },
    {
      "patch": "\n//The fixed function:\n  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0 = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n        equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    boolean firstTime = true;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n        // prepare next step\n        interpolator.storeTime(stepStart);\n\n        // stepsize control for next step\n        final double nextT = stepStart + stepSize;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        if (nextIsLast) {\n          stepSize = t - stepStart;\n        } else if (firstTime) {\n          stepSize = forward ? Math.min(stepSize, t - stepStart) : Math.max(stepSize, t - stepStart);\n          firstTime = false;\n        }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n\n  }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -15.227564232782541,
      "mean_entropy": -0.01825847030309657
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param vecAbsoluteTolerance allowed absolute error\n   * @param vecRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n    resetInternalState();\n\n  }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -6.0737373861446615,
      "mean_entropy": -0.016153556878044314
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param vecAbsoluteTolerance allowed absolute error\n   * @param vecRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal = fsal;\n    this.c = c;\n    this.a = a;\n    this.b = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n  }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -3.320247220059581,
      "mean_entropy": -0.009046995150026107
    },
    {
      "patch": "\nprotected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal = fsal;\n    this.c = c.clone();\n    this.a = a.clone();\n    this.b = b.clone();\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -5.021001654860502,
      "mean_entropy": -0.027894453638113898
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param vecAbsoluteTolerance allowed absolute error\n   * @param vecRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n    if (minStep >= maxStep) {\n        throw new IllegalArgumentException(\"Min step must be strictly less than max step\");\n    }\n  }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -9.369599198141763,
      "mean_entropy": -0.02354170652799438
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param vecAbsoluteTolerance allowed absolute error\n   * @param vecRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n  }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -3.133675375244661,
      "mean_entropy": -0.008446564353759194
    },
    {
      "patch": "\nprotected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                       final double[] c, final double[][] a, final double[] b,\n                                       final RungeKuttaStepInterpolator prototype,\n                                       final double minStep, final double maxStep,\n                                       final double[] vecAbsoluteTolerance,\n                                       final double[] vecRelativeTolerance) {\n\n  super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n  this.fsal = fsal;\n  this.c = c;\n  this.a = a;\n  this.b = b;\n  this.prototype = prototype;\n\n  exp = -1.0 / getOrder();\n\n  // Set the default values of the algorithm control parameters\n  setSafety(0.9);\n  setMinReduction(0.2);\n  setMaxGrowth(10.0);\n}\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -6.56348776866966,
      "mean_entropy": -0.037081851800393556
    },
    {
      "patch": "\nprotected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                       final double[] c, final double[][] a, final double[] b,\n                                       final RungeKuttaStepInterpolator prototype,\n                                       final double minStep, final double maxStep,\n                                       final double[] vecAbsoluteTolerance,\n                                       final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal = fsal;\n    this.c = c;\n    this.a = a;\n    this.b = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -3.812955497801541,
      "mean_entropy": -0.021542121456505883
    },
    {
      "patch": "\nprotected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                       final double[] c, final double[][] a, final double[] b,\n                                       final RungeKuttaStepInterpolator prototype,\n                                       final double minStep, final double maxStep,\n                                       final double[] vecAbsoluteTolerance,\n                                       final double[] vecRelativeTolerance) {\n\n  super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n  this.fsal      = fsal;\n  this.c         = c;\n  this.a         = a;\n  this.b         = b;\n  this.prototype = prototype;\n\n  exp = -1.0 / getOrder();\n\n  // set the default values of the algorithm control parameters\n  setSafety(0.9);\n  setMinReduction(0.2);\n  setMaxGrowth(10.0);\n\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -5.519121610917749,
      "mean_entropy": -0.030492384590705798
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param vecAbsoluteTolerance allowed absolute error\n   * @param vecRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal = fsal;\n    this.c = c;\n    this.a = a;\n    this.b = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n    if (minStep >= maxStep) {\n        throw new IllegalArgumentException(\"Minimal step size must be strictly less than the maximal step size.\");\n    }\n  }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -8.18030994489218,
      "mean_entropy": -0.020605314722650328
    },
    {
      "patch": "\nprotected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                       final double[] c, final double[][] a, final double[] b,\n                                       final RungeKuttaStepInterpolator prototype,\n                                       final double minStep, final double maxStep,\n                                       final double[] vecAbsoluteTolerance,\n                                       final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal = fsal;\n    this.c = c.clone();\n    this.a = a.clone();\n    this.b = b.clone();\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -4.791388513081592,
      "mean_entropy": -0.02661882507267551
    },
    {
      "patch": "\n  /**\n   * Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward integration)\n   * @param vecAbsoluteTolerance allowed absolute error\n   * @param vecRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal = fsal;\n    this.c = c;\n    this.a = a;\n    this.b = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n  }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -4.515589725524798,
      "mean_entropy": -0.012439641117148204
    },
    {
      "patch": "\n  /**\n   * Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward integration)\n   * @param vecAbsoluteTolerance allowed absolute error\n   * @param vecRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n  }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -6.8911727354079835,
      "mean_entropy": -0.018777037426179793
    },
    {
      "patch": "\nprotected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                       final double[] c, final double[][] a, final double[] b,\n                                       final RungeKuttaStepInterpolator prototype,\n                                       final double minStep, final double maxStep,\n                                       final double[] vecAbsoluteTolerance,\n                                       final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal = fsal;\n    this.c = c;\n    this.a = a;\n    this.b = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -3.812955497801541,
      "mean_entropy": -0.021542121456505883
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param vecAbsoluteTolerance allowed absolute error\n   * @param vecRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n    if (minStep > maxStep) {\n        throw new IllegalArgumentException(\"maxStep must be greater than minStep\");\n    }\n  }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -9.96998992921736,
      "mean_entropy": -0.025113324758733905
    },
    {
      "patch": "\nprotected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                       final double[] c, final double[][] a, final double[] b,\n                                       final RungeKuttaStepInterpolator prototype,\n                                       final double minStep, final double maxStep,\n                                       final double[] vecAbsoluteTolerance,\n                                       final double[] vecRelativeTolerance) {\n\n  super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n  this.fsal      = fsal;\n  this.c         = c.clone();\n  this.a         = a.clone();\n  this.b         = b.clone();\n  this.prototype = prototype;\n\n  exp = -1.0 / getOrder();\n\n  // set the default values of the algorithm control parameters\n  setSafety(0.9);\n  setMinReduction(0.2);\n  setMaxGrowth(10.0);\n\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -6.270351274930825,
      "mean_entropy": -0.03407799605940665
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param vecAbsoluteTolerance allowed absolute error\n   * @param vecRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n  }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -3.0332989543662805,
      "mean_entropy": -0.00817600796325143
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param vecAbsoluteTolerance allowed absolute error\n   * @param vecRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n    if (minStep >= maxStep) {\n        throw new IllegalArgumentException(\"minStep must be strictly less than maxStep\");\n    }\n  }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -6.612937829587781,
      "mean_entropy": -0.01661542168238136
    },
    {
      "patch": "\nprotected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n\n    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n    this.fsal = fsal;\n    this.c = c.clone();\n    this.a = a.clone();\n    this.b = b.clone();\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n}\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -5.102626483344717,
      "mean_entropy": -0.02834792490747065
    },
    {
      "patch": "\nprotected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                       final double[] c, final double[][] a, final double[] b,\n                                       final RungeKuttaStepInterpolator prototype,\n                                       final double minStep, final double maxStep,\n                                       final double[] vecAbsoluteTolerance,\n                                       final double[] vecRelativeTolerance) {\n\n  super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n\n  this.fsal      = fsal;\n  this.c         = c.clone();\n  this.a         = a.clone();\n  this.b         = b.clone();\n  this.prototype = prototype;\n\n  exp = -1.0 / getOrder();\n\n  // set the default values of the algorithm control parameters\n  setSafety(0.9);\n  setMinReduction(0.2);\n  setMaxGrowth(10.0);\n}\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -7.777198681969196,
      "mean_entropy": -0.042267384141136934
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param maxStep maximal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double scalAbsoluteTolerance,\n                                         final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n  }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -3.806178816182479,
      "mean_entropy": -0.009660352325336241
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param maxStep maximal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double scalAbsoluteTolerance,\n                                         final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal = fsal;\n    this.c = c;\n    this.a = a;\n    this.b = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n  }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -6.5214434798835645,
      "mean_entropy": -0.016721649948419397
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param maxStep maximal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double scalAbsoluteTolerance,\n                                         final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n    \n    // Set the default value for first step size\n    setInitialStepSize(-1.0);\n\n  }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -17.519715379586483,
      "mean_entropy": -0.04211470043169828
    },
    {
      "patch": "\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double scalAbsoluteTolerance,\n                                         final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n  }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -5.037805499995879,
      "mean_entropy": -0.02783317955798828
    },
    {
      "patch": "\nprotected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                       final double[] c, final double[][] a, final double[] b,\n                                       final RungeKuttaStepInterpolator prototype,\n                                       final double minStep, final double maxStep,\n                                       final double scalAbsoluteTolerance,\n                                       final double scalRelativeTolerance) {\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal = fsal;\n    this.c = c;\n    this.a = a;\n    this.b = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -6.668993213676684,
      "mean_entropy": -0.03810853264958105
    },
    {
      "patch": "\nprotected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double scalAbsoluteTolerance,\n                                         final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n}\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -5.330467941451114,
      "mean_entropy": -0.02977915051090008
    },
    {
      "patch": "\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param maxStep maximal step (sign is irrelevant, regardless of\n   * integration direction, forward or backward), the last step can\n   * be smaller than this\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double scalAbsoluteTolerance,\n                                         final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n    if (fsal) {\n        resetInternalState();\n    }\n  }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 15,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep",
        [
          "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep"
        ]
      ],
      "sum_entropy": -6.445100534981938,
      "mean_entropy": -0.015796815036720434
    }
  ],
  "Math_40": [
    {
      "patch": "\n// Fixed code:\n\npublic Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                 final Dfp min, final Dfp max, final Dfp startValue,\n                 final AllowedSolution allowedSolution) {\n\n    MathUtils.checkNotNull(f);\n\n    evaluations.setMaximalCount(maxEval);\n    evaluations.resetCount();\n    Dfp zero = startValue.getZero();\n    Dfp nan = zero.newInstance((byte) 1, Dfp.QNAN);\n\n    final Dfp[] x = new Dfp[maximalOrder + 1];\n    final Dfp[] y = new Dfp[maximalOrder + 1];\n    x[0] = min;\n    x[1] = startValue;\n    x[2] = max;\n\n    evaluations.incrementCount();\n    y[1] = f.value(x[1]);\n    if (y[1].isZero()) {\n        return x[1];\n    }\n\n    evaluations.incrementCount();\n    y[0] = f.value(x[0]);\n    if (y[0].isZero()) {\n        return x[0];\n    }\n\n    int nbPoints;\n    int signChangeIndex;\n    if (y[0].multiply(y[1]).negativeOrNull()) {\n        nbPoints = 2;\n        signChangeIndex = 1;\n    } else {\n        evaluations.incrementCount();\n        y[2] = f.value(x[2]);\n        if (y[2].isZero()) {\n            return x[2];\n        }\n\n        if (y[1].multiply(y[2]).negativeOrNull()) {\n            nbPoints = 3;\n            signChangeIndex = 2;\n        } else {\n            throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                    y[0].toDouble(), y[2].toDouble());\n        }\n    }\n\n    final Dfp[] tmpX = new Dfp[x.length];\n\n    Dfp xA = x[signChangeIndex - 1];\n    Dfp yA = y[signChangeIndex - 1];\n    Dfp absXA = xA.abs();\n    Dfp absYA = yA.abs();\n    int agingA = 0;\n    Dfp xB = x[signChangeIndex];\n    Dfp yB = y[signChangeIndex];\n    Dfp absXB = xB.abs();\n    Dfp absYB = yB.abs();\n    int agingB = 0;\n\n    while (true) {\n        Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n        Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n        final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n        if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n            switch (allowedSolution) {\n                case ANY_SIDE:\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE:\n                    return xA;\n                case RIGHT_SIDE:\n                    return xB;\n                case BELOW_SIDE:\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE:\n                    return yA.lessThan(zero) ? xB : xA;\n                default:\n                    throw new MathInternalError(null);\n            }\n        }\n\n        Dfp targetY;\n        if (agingA >= MAXIMAL_AGING) {\n            targetY = yB.divide(16).negate();\n        } else if (agingB >= MAXIMAL_AGING) {\n            targetY = yA.divide(16).negate();\n        } else {\n            targetY = zero;\n        }\n\n        Dfp nextX;\n        int start = 0;\n        int end = nbPoints;\n        do {\n            System.arraycopy(x, start, tmpX, start, end - start);\n            nextX = guessX(targetY, tmpX, y, start, end);\n\n            if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                if (signChangeIndex - start >= end - signChangeIndex) {\n                    ++start;\n                } else {\n                    --end;\n                }\n\n                nextX = nan;\n            }\n\n        } while (nextX.isNaN() && (end - start > 1));\n\n        if (nextX.isNaN()) {\n            nextX = xA.add(xB.subtract(xA).divide(2));\n            start = signChangeIndex - 1;\n            end = signChangeIndex;\n        }\n\n        evaluations.incrementCount();\n        final Dfp nextY = f.value(nextX);\n        if (nextY.isZero()) {\n            return nextX;\n        }\n\n        if ((nbPoints > 2) && (end - start != nbPoints)) {\n            nbPoints = end - start;\n            System.arraycopy(x, start, x, 0, nbPoints);\n            System.arraycopy(y, start, y, 0, nbPoints);\n            signChangeIndex -= start;\n        } else if (nbPoints == x.length) {\n            nbPoints--;\n            if (signChangeIndex >= (x.length + 1) / 2) {\n                System.arraycopy(x, 1, x, 0, nbPoints);\n                System.arraycopy(y, 1, y, 0, nbPoints);\n                --signChangeIndex;\n            }\n        }\n\n        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n        x[signChangeIndex] = nextX;\n        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n        y[signChangeIndex] = nextY;\n        ++nbPoints;\n\n        if (nextY.multiply(yA).negativeOrNull()) {\n            xB = nextX;\n            yB = nextY;\n            absYB = yB.abs();\n            ++agingA;\n            agingB = 0;\n        } else {\n            xA = nextX;\n            yA = nextY;\n            absYA = yA.abs();\n            agingA = 0;\n            ++agingB;\n\n            signChangeIndex++;\n        }\n    }\n}\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -14.359383658627065,
      "mean_entropy": -0.011096896181319215
    },
    {
      "patch": "\n    /**\n     * Solve for a zero in the given interval, start at {@code startValue}.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n     * accept as solutions.\n     * @return a value where the function is zero.\n     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     */\n    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution) {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -5.431954395766819,
      "mean_entropy": -0.0026771584010679243
    },
    {
      "patch": "\n    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution) {\n\n        MathUtils.checkNotNull(f);\n\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            return x[1];\n        }\n\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n            nbPoints = 2;\n            signChangeIndex = 1;\n        } else {\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                nbPoints = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n        }\n\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        Dfp xA = x[signChangeIndex - 1];\n        Dfp yA = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA = 0;\n        Dfp xB = x[signChangeIndex];\n        Dfp yB = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB = 0;\n\n        while (true) {\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                    case ANY_SIDE:\n                        return absYA.lessThan(absYB) ? xA : xB;\n                    case LEFT_SIDE:\n                        return xA;\n                    case RIGHT_SIDE:\n                        return xB;\n                    case BELOW_SIDE:\n                        return yA.lessThan(zero) ? xA : xB;\n                    case ABOVE_SIDE:\n                        return yA.lessThan(zero) ? xB : xA;\n                    default:\n                        throw new MathInternalError(null);\n                }\n            }\n\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                targetY = yB.divide(16).negate();\n            } else if (agingB >= MAXIMAL_AGING) {\n                targetY = yA.divide(16).negate();\n            } else {\n                targetY = zero;\n            }\n\n            Dfp nextX;\n            int start = 0;\n            int end = nbPoints;\n            do {\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        ++start;\n                    } else {\n                        --end;\n                    }\n\n                    nextX = nan;\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end = signChangeIndex;\n            }\n\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n            } else if (nbPoints == x.length) {\n                nbPoints--;\n\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n            }\n\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            if (nextY.multiply(yA).negativeOrNull()) {\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n                signChangeIndex++;\n            }\n        }\n    }\n\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -10.699971361233606,
      "mean_entropy": -0.008262526147670738
    },
    {
      "patch": "\n    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution) {\n\n        MathUtils.checkNotNull(f);\n\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            return x[1];\n        }\n\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n            nbPoints = 2;\n            signChangeIndex = 1;\n        } else {\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                return x[2];\n            }\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                nbPoints = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n        }\n\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        Dfp xA = x[signChangeIndex - 1];\n        Dfp yA = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA = 0;\n        Dfp xB = x[signChangeIndex];\n        Dfp yB = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB = 0;\n\n        while (true) {\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                    case ANY_SIDE:\n                        return absYA.lessThan(absYB) ? xA : xB;\n                    case LEFT_SIDE:\n                        return xA;\n                    case RIGHT_SIDE:\n                        return xB;\n                    case BELOW_SIDE:\n                        return yA.lessThan(zero) ? xA : xB;\n                    case ABOVE_SIDE:\n                        return yA.lessThan(zero) ? xB : xA;\n                    default:\n                        throw new MathInternalError(null);\n                }\n            }\n\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                targetY = yB.divide(16).negate();\n            } else if (agingB >= MAXIMAL_AGING) {\n                targetY = yA.divide(16).negate();\n            } else {\n                targetY = zero;\n            }\n\n            Dfp nextX;\n            int start = 0;\n            int end = nbPoints;\n            do {\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        ++start;\n                    } else {\n                        --end;\n                    }\n                    nextX = nan;\n                }\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end = signChangeIndex;\n            }\n\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n            } else if (nbPoints == x.length) {\n                nbPoints--;\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n            }\n\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            if (nextY.multiply(yA).negativeOrNull()) {\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n                signChangeIndex++;\n            }\n\n        }\n\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -10.295082853194286,
      "mean_entropy": -0.007968330381729323
    },
    {
      "patch": "\n//The fixed function:\npublic Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                 final Dfp min, final Dfp max, final Dfp startValue,\n                 final AllowedSolution allowedSolution) {\n\n    // Checks.\n    MathUtils.checkNotNull(f);\n\n    // Reset.\n    evaluations.setMaximalCount(maxEval);\n    evaluations.resetCount();\n    Dfp zero = startValue.getZero();\n    Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n    // prepare arrays with the first points\n    final Dfp[] x = new Dfp[maximalOrder + 1];\n    final Dfp[] y = new Dfp[maximalOrder + 1];\n    x[0] = min;\n    x[1] = startValue;\n    x[2] = max;\n\n    // evaluate initial guess\n    evaluations.incrementCount();\n    y[1] = f.value(x[1]);\n    if (y[1].isZero()) {\n        // return the initial guess if it is a perfect root.\n        return x[1];\n    }\n\n    // evaluate first endpoint\n    evaluations.incrementCount();\n    y[0] = f.value(x[0]);\n    if (y[0].isZero()) {\n        // return the first endpoint if it is a perfect root.\n        return x[0];\n    }\n\n    int nbPoints;\n    int signChangeIndex;\n    if (y[0].multiply(y[1]).negativeOrNull()) {\n\n        // reduce interval if it brackets the root\n        nbPoints = 2;\n        signChangeIndex = 1;\n\n    } else {\n\n        // evaluate second endpoint\n        evaluations.incrementCount();\n        y[2] = f.value(x[2]);\n        if (y[2].isZero()) {\n            // return the second endpoint if it is a perfect root.\n            return x[2];\n        }\n\n        if (y[1].multiply(y[2]).negativeOrNull()) {\n            // use all computed points as a start sampling array for solving\n            nbPoints = 3;\n            signChangeIndex = 2;\n        } else {\n            throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                            y[0].toDouble(), y[2].toDouble());\n        }\n\n    }\n\n    // prepare a work array for inverse polynomial interpolation\n    final Dfp[] tmpX = new Dfp[x.length];\n\n    // current tightest bracketing of the root\n    Dfp xA = x[signChangeIndex - 1];\n    Dfp yA = y[signChangeIndex - 1];\n    Dfp absXA = xA.abs();\n    Dfp absYA = yA.abs();\n    int agingA = 0;\n    Dfp xB = x[signChangeIndex];\n    Dfp yB = y[signChangeIndex];\n    Dfp absXB = xB.abs();\n    Dfp absYB = yB.abs();\n    int agingB = 0;\n\n    // search loop\n    while (true) {\n\n        // check convergence of bracketing interval\n        Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n        Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n        final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n        if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n            maxY.lessThan(functionValueAccuracy)) {\n            switch (allowedSolution) {\n                case ANY_SIDE:\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE:\n                    return xA;\n                case RIGHT_SIDE:\n                    return xB;\n                case BELOW_SIDE:\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE:\n                    return yA.lessThan(zero) ? xB : xA;\n                default:\n                    // this should never happen\n                    throw new MathInternalError(null);\n            }\n        }\n\n        // target for the next evaluation point\n        Dfp targetY;\n        if (agingA >= MAXIMAL_AGING) {\n            // we keep updating the high bracket, try to compensate this\n            targetY = yB.divide(16).negate();\n        } else if (agingB >= MAXIMAL_AGING) {\n            // we keep updating the low bracket, try to compensate this\n            targetY = yA.divide(16).negate();\n        } else {\n            // bracketing is balanced, try to find the root itself\n            targetY = zero;\n        }\n\n        // make a few attempts to guess a root,\n        Dfp nextX;\n        int start = 0;\n        int end = nbPoints;\n        do {\n\n            // guess a value for the current target, using inverse polynomial interpolation\n            System.arraycopy(x, start, tmpX, start, end - start);\n            nextX = guessX(targetY, tmpX, y, start, end);\n\n            if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                // the guessed root is not strictly inside the tightest bracketing interval\n\n                // the guessed root is either not strictly inside the interval or it\n                // is a NaN (which occurs when some sampling points share the same y)\n                // we try again with a lower interpolation order\n                if (signChangeIndex - start >= end - signChangeIndex) {\n                    // we have more points before the sign change, drop the lowest point\n                    ++start;\n                } else {\n                    // we have more points after the sign change, drop the highest point\n                    --end;\n                }\n\n                // we need to do one more attempt\n                nextX = nan;\n\n            }\n\n        } while (nextX.isNaN() && (end - start > 1));\n\n        if (nextX.isNaN()) {\n            // fall back to bisection\n            nextX = xA.add(xB.subtract(xA).divide(2));\n            start = signChangeIndex - 1;\n            end = signChangeIndex;\n        }\n\n        // evaluate the function at the guessed root\n        evaluations.incrementCount();\n        final Dfp nextY = f.value(nextX);\n        if (nextY.isZero()) {\n            // we have found an exact root, since it is not an approximation\n            // we don't need to bother about the allowed solutions setting\n            return nextX;\n        }\n\n        if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n            // we have been forced to ignore some points to keep bracketing,\n            // they are probably too far from the root, drop them from now on\n            nbPoints = end - start;\n            System.arraycopy(x, start, x, 0, nbPoints);\n            System.arraycopy(y, start, y, 0, nbPoints);\n            signChangeIndex -= start;\n\n        } else if (nbPoints == x.length) {\n\n            // we have to drop one point to insert the new one\n            nbPoints--;\n\n            // keep the tightest bracketing interval as centered as possible\n            if (signChangeIndex >= (x.length + 1) / 2) {\n                // we drop the lowest point, we have to shift the arrays and the index\n                System.arraycopy(x, 1, x, 0, nbPoints);\n                System.arraycopy(y, 1, y, 0, nbPoints);\n                --signChangeIndex;\n            }\n\n        }\n\n        // insert the last computed point\n        // (by construction, we know it lies inside the tightest bracketing interval)\n        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n        x[signChangeIndex] = nextX;\n        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n        y[signChangeIndex] = nextY;\n        ++nbPoints;\n\n        // update the bracketing interval\n        if (nextY.multiply(yA).negativeOrNull()) {\n            // the sign change occurs before the inserted point\n            xB = nextX;\n            yB = nextY;\n            absYB = yB.abs();\n            ++agingA;\n            agingB = 0;\n        } else {\n            // the sign change occurs after the inserted point\n            xA = nextX;\n            yA = nextY;\n            absYA = yA.abs();\n            agingA = 0;\n            ++agingB;\n\n            // update the sign change index\n            signChangeIndex++;\n\n        }\n\n    }\n\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -12.897408974443003,
      "mean_entropy": -0.007141422466468994
    },
    {
      "patch": "\n    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution) {\n\n        MathUtils.checkNotNull(f);\n\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            return x[1];\n        }\n\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n            nbPoints = 2;\n            signChangeIndex = 1;\n        } else {\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                return x[2];\n            }\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                nbPoints = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n        }\n\n        final Dfp[] tmpX = new Dfp[x.length];\n        Dfp xA = x[signChangeIndex - 1];\n        Dfp yA = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA = 0;\n        Dfp xB = x[signChangeIndex];\n        Dfp yB = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB = 0;\n\n        while (true) {\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                    case ANY_SIDE:\n                        return absYA.lessThan(absYB) ? xA : xB;\n                    case LEFT_SIDE:\n                        return xA;\n                    case RIGHT_SIDE:\n                        return xB;\n                    case BELOW_SIDE:\n                        return yA.lessThan(zero) ? xA : xB;\n                    case ABOVE_SIDE:\n                        return yA.lessThan(zero) ? xB : xA;\n                    default:\n                        throw new MathInternalError(null);\n                }\n            }\n\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                targetY = yB.divide(16).negate();\n            } else if (agingB >= MAXIMAL_AGING) {\n                targetY = yA.divide(16).negate();\n            } else {\n                targetY = zero;\n            }\n\n            Dfp nextX;\n            int start = 0;\n            int end = nbPoints;\n            do {\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        ++start;\n                    } else {\n                        --end;\n                    }\n\n                    nextX = nan;\n                }\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end = signChangeIndex;\n            }\n\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n            } else if (nbPoints == x.length) {\n                nbPoints--;\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n            }\n\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            if (nextY.multiply(yA).negativeOrNull()) {\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n                signChangeIndex++;\n            }\n        }\n\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -13.712630871059515,
      "mean_entropy": -0.01060528296292306
    },
    {
      "patch": "\n    /**\n     * Solve for a zero in the given interval, start at {@code startValue}.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n     * accept as solutions.\n     * @return a value where the function is zero.\n     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     */\n    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution) {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING && agingB < MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\n            } else if (agingB >= MAXIMAL_AGING && agingA < MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -9.01659307004556,
      "mean_entropy": -0.004413408257486814
    },
    {
      "patch": "\n    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution) {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                        y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA = x[signChangeIndex - 1];\n        Dfp yA = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA = 0;\n        Dfp xB = x[signChangeIndex];\n        Dfp yB = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                    maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                    case ANY_SIDE:\n                        return absYA.lessThan(absYB) ? xA : xB;\n                    case LEFT_SIDE:\n                        return xA;\n                    case RIGHT_SIDE:\n                        return xB;\n                    case BELOW_SIDE:\n                        return yA.lessThan(zero) ? xA : xB;\n                    case ABOVE_SIDE:\n                        return yA.lessThan(zero) ? xB : xA;\n                    default:\n                        // this should never happen\n                        throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            // (by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -8.315773085525812,
      "mean_entropy": -0.004609630313484375
    },
    {
      "patch": "\n    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution) {\n\n        MathUtils.checkNotNull(f);\n\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            return x[1];\n        }\n\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n            nbPoints = 2;\n            signChangeIndex = 1;\n        } else {\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                return x[2];\n            }\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                nbPoints = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                        y[0].toDouble(), y[2].toDouble());\n            }\n        }\n\n        final Dfp[] tmpX = new Dfp[x.length];\n        Dfp xA = x[signChangeIndex - 1];\n        Dfp yA = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA = 0;\n        Dfp xB = x[signChangeIndex];\n        Dfp yB = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB = 0;\n\n        while (true) {\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                    maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                    case ANY_SIDE:\n                        return absYA.lessThan(absYB) ? xA : xB;\n                    case LEFT_SIDE:\n                        return xA;\n                    case RIGHT_SIDE:\n                        return xB;\n                    case BELOW_SIDE:\n                        return yA.lessThan(zero) ? xA : xB;\n                    case ABOVE_SIDE:\n                        return yA.lessThan(zero) ? xB : xA;\n                    default:\n                        throw new MathInternalError(null);\n                }\n            }\n\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                targetY = yB.divide(16).negate();\n            } else if (agingB >= MAXIMAL_AGING) {\n                targetY = yA.divide(16).negate();\n            } else {\n                targetY = zero;\n            }\n\n            Dfp nextX;\n            int start = 0;\n            int end = nbPoints;\n            do {\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        ++start;\n                    } else {\n                        --end;\n                    }\n                    nextX = null;\n                }\n            } while (nextX == null && (end - start > 1));\n\n            if (nextX == null) {\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end = signChangeIndex;\n            }\n\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n            } else if (nbPoints == x.length) {\n                nbPoints--;\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n            }\n\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            if (nextY.multiply(yA).negativeOrNull()) {\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n                signChangeIndex++;\n            }\n\n        }\n\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -15.80817986377591,
      "mean_entropy": -0.012427814358314394
    },
    {
      "patch": "\n    /**\n     * Solve for a zero in the given interval, start at {@code startValue}.\n     * A solver may require that the interval brackets a single zero root.\n     * Solvers that do require bracketing should be able to handle the case\n     * where one of the endpoints is itself a root.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound for the interval.\n     * @param max Upper bound for the interval.\n     * @param startValue Start value to use.\n     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n     * accept as solutions.\n     * @return a value where the function is zero.\n     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n     * if the arguments do not satisfy the requirements specified by the solver.\n     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n     * the allowed number of evaluations is exceeded.\n     */\n    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution) {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                    case ANY_SIDE:\n                        return absYA.lessThan(absYB) ? xA : xB;\n                    case LEFT_SIDE:\n                        return xA;\n                    case RIGHT_SIDE:\n                        return xB;\n                    case BELOW_SIDE:\n                        return yA.lessThan(zero) ? xA : xB;\n                    case ABOVE_SIDE:\n                        return yA.lessThan(zero) ? xB : xA;\n                    default:\n                        // this should never happen\n                        throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end = nbPoints;\n            do {\n\n                // guess a value for the current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after the sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else if (nbPoints == x.length) {\n\n                // we have to drop one point to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            // (by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -12.321669780701477,
      "mean_entropy": -0.006078771475432401
    },
    {
      "patch": "\n    // Fixed code:\n\n    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution) {\n\n        MathUtils.checkNotNull(f);\n\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            return x[1];\n        }\n\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n            nbPoints = 2;\n            signChangeIndex = 1;\n        } else {\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                return x[2];\n            }\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                nbPoints = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(), y[0].toDouble(), y[2].toDouble());\n            }\n        }\n\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        Dfp xA = x[signChangeIndex - 1];\n        Dfp yA = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA = 0;\n        Dfp xB = x[signChangeIndex];\n        Dfp yB = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB = 0;\n\n        while (true) {\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                    case ANY_SIDE:\n                        return absYA.lessThan(absYB) ? xA : xB;\n                    case LEFT_SIDE:\n                        return xA;\n                    case RIGHT_SIDE:\n                        return xB;\n                    case BELOW_SIDE:\n                        return yA.lessThan(zero) ? xA : xB;\n                    case ABOVE_SIDE:\n                        return yA.lessThan(zero) ? xB : xA;\n                    default:\n                        throw new MathInternalError(null);\n                }\n            }\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                targetY = yB.divide(16).negate();\n            } else if (agingB >= MAXIMAL_AGING) {\n                targetY = yA.divide(16).negate();\n            } else {\n                targetY = zero;\n            }\n            Dfp nextX;\n            int start = 0;\n            int end = nbPoints;\n            do {\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        ++start;\n                    } else {\n                        --end;\n                    }\n                    nextX = nan;\n                }\n            } while (nextX.isNaN() && (end - start > 1));\n            if (nextX.isNaN()) {\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end = signChangeIndex;\n            }\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                return nextX;\n            }\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n            } else if (nbPoints == x.length) {\n                nbPoints--;\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n            }\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n            if (nextY.multiply(yA).negativeOrNull()) {\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n                signChangeIndex++;\n            }\n        }\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -18.23277223090509,
      "mean_entropy": -0.01405765013947964
    },
    {
      "patch": "\n    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution) {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                        y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA = x[signChangeIndex - 1];\n        Dfp yA = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA = 0;\n        Dfp xB = x[signChangeIndex];\n        Dfp yB = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                    maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                    case ANY_SIDE:\n                        return absYA.lessThan(absYB) ? xA : xB;\n                    case LEFT_SIDE:\n                        return xA;\n                    case RIGHT_SIDE:\n                        return xB;\n                    case BELOW_SIDE:\n                        return yA.lessThan(zero) ? xA : xB;\n                    case ABOVE_SIDE:\n                        return yA.lessThan(zero) ? xB : xA;\n                    default:\n                        // this should never happen\n                        throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 11,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716",
        [
          "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716"
        ]
      ],
      "sum_entropy": -7.754749640919756,
      "mean_entropy": -0.004298641707826916
    }
  ],
  "Math_5": [
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.getReal()) ||\n            Double.isInfinite(factor.getImaginary())) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.getReal() - imaginary * factor.getImaginary(),\n                             real * factor.getImaginary() + imaginary * factor.getReal());\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -8.516504647693754,
      "mean_entropy": -0.021185334944511826
    },
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.getReal()) ||\n            Double.isInfinite(factor.getImaginary())) {\n            return INF;\n        }\n        return createComplex(real * factor.getReal() - imaginary * factor.getImaginary(),\n                             real * factor.getImaginary() + imaginary * factor.getReal());\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -3.959716574545609,
      "mean_entropy": -0.010205455089035075
    },
    {
      "patch": "\n    public Complex multiply(Complex factor) throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.getReal()) || Double.isInfinite(factor.getImaginary())) {\n            return INF;\n        }\n        return createComplex(real * factor.getReal() - imaginary * factor.getImaginary(),\n                             real * factor.getImaginary() + imaginary * factor.getReal());\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -4.293356704810704,
      "mean_entropy": -0.036078627771518525
    },
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN || factor.isNaN) {\n            return NaN;\n        }\n        if ((Double.isInfinite(real) || Double.isInfinite(imaginary)) &&\n            (real != 0 || imaginary != 0) ||\n            (Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) &&\n            (factor.real != 0 || factor.imaginary != 0)) {\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -8.542140023007681,
      "mean_entropy": -0.021143910948038813
    },
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.getReal()) ||\n            Double.isInfinite(factor.getImaginary())) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.getReal() - imaginary * factor.getImaginary(),\n                             real * factor.getImaginary() + imaginary * factor.getReal());\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -2.32911408731457,
      "mean_entropy": -0.0057651338794915095
    },
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -3.09567665789628,
      "mean_entropy": -0.007877039841975268
    },
    {
      "patch": "\n    public Complex multiply(Complex factor) {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return Complex.NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.getReal()) ||\n            Double.isInfinite(factor.getImaginary())) {\n            return Complex.INF;\n        }\n        return createComplex(real * factor.getReal() - imaginary * factor.getImaginary(),\n                             real * factor.getImaginary() + imaginary * factor.getReal());\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -5.62671943286646,
      "mean_entropy": -0.04650181349476413
    },
    {
      "patch": "\n    public Complex multiply(Complex factor) {\n        MathUtils.checkNotNull(factor);\n        if (Double.isNaN(real) || Double.isNaN(imaginary) || Double.isNaN(factor.real) || Double.isNaN(factor.imaginary)) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -4.933019005933222,
      "mean_entropy": -0.03946415204746578
    },
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -3.09567665789628,
      "mean_entropy": -0.007877039841975268
    },
    {
      "patch": "\npublic Complex multiply(Complex factor) throws NullArgumentException {\n    MathUtils.checkNotNull(factor);\n    if (Double.isNaN(real) || Double.isNaN(imaginary) || Double.isNaN(factor.real) || Double.isNaN(factor.imaginary)) {\n        return NaN;\n    }\n    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {\n        return INF;\n    }\n    return createComplex(real * factor.real - imaginary * factor.imaginary,\n            real * factor.imaginary + imaginary * factor.real);\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -9.960444471782866,
      "mean_entropy": -0.07905114660145132
    },
    {
      "patch": "\n    public Complex multiply(Complex factor) throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (Double.isNaN(real) || Double.isNaN(imaginary) || Double.isNaN(factor.real) || Double.isNaN(factor.imaginary)) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -7.959117142847568,
      "mean_entropy": -0.06075661941105014
    },
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -3.09567665789628,
      "mean_entropy": -0.007877039841975268
    },
    {
      "patch": "\n/**\n * Returns a {@code Complex} whose value is {@code this * factor}.\n * Implements preliminary checks for {@code NaN} and infinity followed by\n * the definitional formula:\n * <pre>\n *  <code>\n *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n *  </code>\n * </pre>\n * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n * more {@code NaN} parts.\n * <br/>\n * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n * or more {@code NaN} parts and if either {@code this} or {@code factor}\n * has one or more infinite parts (same result is returned regardless of\n * the sign of the components).\n * <br/>\n * Returns finite values in components of the result per the definitional\n * formula in all remaining cases.\n *\n * @param  factor value to be multiplied by this {@code Complex}.\n * @return {@code this * factor}.\n * @throws NullArgumentException if {@code factor} is {@code null}.\n */\npublic Complex multiply(Complex factor)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(factor);\n    if (isNaN() || factor.isNaN()) {\n        return NaN;\n    }\n    if (Double.isInfinite(real) ||\n        Double.isInfinite(imaginary) ||\n        Double.isInfinite(factor.real) ||\n        Double.isInfinite(factor.imaginary)) {\n        // we don't use isInfinite() to avoid testing for NaN again\n        return INF;\n    }\n    return createComplex(real * factor.real - imaginary * factor.imaginary,\n                         real * factor.imaginary + imaginary * factor.real);\n}\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -4.473417829054038,
      "mean_entropy": -0.012189149397967407
    },
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor) throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -7.517754207248406,
      "mean_entropy": -0.020047344552662417
    },
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -3.09567665789628,
      "mean_entropy": -0.007877039841975268
    },
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -3.1031588269131207,
      "mean_entropy": -0.007896078439982496
    },
    {
      "patch": "\n    public Complex multiply(Complex factor) {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return Complex.NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.getReal()) ||\n            Double.isInfinite(factor.getImaginary())) {\n            return Complex.INF;\n        }\n        return createComplex(real * factor.getReal() - imaginary * factor.getImaginary(),\n                             real * factor.getImaginary() + imaginary * factor.getReal());\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -5.176102284758544,
      "mean_entropy": -0.04277770483271524
    },
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.getReal()) ||\n            Double.isInfinite(factor.getImaginary())) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.getReal() - imaginary * factor.getImaginary(),\n                             real * factor.getImaginary() + imaginary * factor.getReal());\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -2.502332256934911,
      "mean_entropy": -0.006193891725086414
    },
    {
      "patch": "\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <pre>\n     *  <code>\n     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     *  </code>\n     * </pre>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <br/>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * <br/>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN() || factor.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -3.1031588269131207,
      "mean_entropy": -0.007896078439982496
    },
    {
      "patch": "\n    /**\n     * Computes the n-th roots of this complex number.\n     * The nth roots are defined by the formula:\n     * <pre>\n     *  <code>\n     *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n     *  </code>\n     * </pre>\n     * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n     * are respectively the {@link #abs() modulus} and\n     * {@link #getArgument() argument} of this complex number.\n     * <br/>\n     * If one or both parts of this complex number is NaN, a list with just\n     * one element, {@link #NaN} is returned.\n     * if neither part is NaN, but at least one part is infinite, the result\n     * is a one-element list containing {@link #INF}.\n     *\n     * @param n Degree of root.\n     * @return a List<Complex> of all {@code n}-th roots of {@code this}.\n     * @throws NotPositiveException if {@code n <= 0}.\n     * @since 2.0\n     */\n    public List<Complex> nthRoot(int n) throws NotPositiveException {\n\n        if (n <= 0) {\n            throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                                           n);\n        }\n\n        final List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN()) {\n            result.add(NaN);\n            return result;\n        }\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        // nth root of abs -- faster / more accurate to use a solver here?\n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\n        final double nthPhi = getArgument() / n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n            // inner part\n            final double realPart = nthRootOfAbs *  FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -1.6829381860060304,
      "mean_entropy": -0.0030214330089874874
    },
    {
      "patch": "\n    /**\n     * Computes the n-th roots of this complex number.\n     * The nth roots are defined by the formula:\n     * <pre>\n     *  <code>\n     *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n     *  </code>\n     * </pre>\n     * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n     * are respectively the {@link #abs() modulus} and\n     * {@link #getArgument() argument} of this complex number.\n     * <br/>\n     * If one or both parts of this complex number is NaN, a list with just\n     * one element, {@link #NaN} is returned.\n     * if neither part is NaN, but at least one part is infinite, the result\n     * is a one-element list containing {@link #INF}.\n     *\n     * @param n Degree of root.\n     * @return a List<Complex> of all {@code n}-th roots of {@code this}.\n     * @throws NotPositiveException if {@code n <= 0}.\n     * @since 2.0\n     */\n    public List<Complex> nthRoot(int n) throws NotPositiveException {\n\n        if (n <= 0) {\n            throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                                           n);\n        }\n\n        final List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN()) {\n            result.add(NaN);\n            return result;\n        }\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        // nth root of abs -- faster / more accurate to use a solver here?\n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\n        final double nthPhi = getArgument() / n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n            // inner part\n            final double realPart = nthRootOfAbs *  FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -1.6829381860060304,
      "mean_entropy": -0.0030214330089874874
    },
    {
      "patch": "\n/**\n * Computes the n-th roots of this complex number.\n * The nth roots are defined by the formula:\n * <pre>\n *  <code>\n *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n *  </code>\n * </pre>\n * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n * are respectively the {@link #abs() modulus} and\n * {@link #getArgument() argument} of this complex number.\n * <br/>\n * If one or both parts of this complex number is NaN, a list with just\n * one element, {@link #NaN} is returned.\n * if neither part is NaN, but at least one part is infinite, the result\n * is a one-element list containing {@link #INF}.\n *\n * @param n Degree of root.\n * @return a List<Complex> of all {@code n}-th roots of {@code this}.\n * @throws NotPositiveException if {@code n <= 0}.\n * @since 2.0\n */\npublic List<Complex> nthRoot(int n) throws NotPositiveException {\n\n    if (n <= 0) {\n        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                                       n);\n    }\n\n    final List<Complex> result = new ArrayList<Complex>();\n\n    if (isNaN()) {\n        result.add(Complex.NaN);\n        return result;\n    }\n    if (isInfinite()) {\n        result.add(Complex.INF);\n        return result;\n    }\n\n    // nth root of abs -- faster / more accurate to use a solver here?\n    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n    // Compute nth roots of complex number with k = 0, 1, ... n-1\n    final double nthPhi = getArgument() / n;\n    final double slice = 2 * FastMath.PI / n;\n    double innerPart = nthPhi;\n    for (int k = 0; k < n ; k++) {\n        // inner part\n        final double realPart = nthRootOfAbs *  FastMath.cos(innerPart);\n        final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n        result.add(createComplex(realPart, imaginaryPart));\n        innerPart += slice;\n    }\n\n    return result;\n}\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -5.900736156299902,
      "mean_entropy": -0.011008836112499818
    },
    {
      "patch": "\n    /**\n     * Computes the n-th roots of this complex number.\n     * The nth roots are defined by the formula:\n     * <pre>\n     *  <code>\n     *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n     *  </code>\n     * </pre>\n     * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n     * are respectively the {@link #abs() modulus} and\n     * {@link #getArgument() argument} of this complex number.\n     * <br/>\n     * If one or both parts of this complex number is NaN, a list with just\n     * one element, {@link #NaN} is returned.\n     * if neither part is NaN, but at least one part is infinite, the result\n     * is a one-element list containing {@link #INF}.\n     *\n     * @param n Degree of root.\n     * @return a List<Complex> of all {@code n}-th roots of {@code this}.\n     * @throws NotPositiveException if {@code n <= 0}.\n     * @since 2.0\n     */\n    public List<Complex> nthRoot(int n) throws NotPositiveException {\n\n        if (n <= 0) {\n            throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);\n        }\n\n        final List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN()) {\n            result.add(NaN);\n            return result;\n        }\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        // nth root of abs -- faster / more accurate to use a solver here?\n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\n        final double nthPhi = getArgument() / n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n; k++) {\n            // inner part\n            final double realPart = nthRootOfAbs * FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -4.15265813966916,
      "mean_entropy": -0.007495772815287293
    },
    {
      "patch": "\n/**\n * Computes the n-th roots of this complex number.\n * The nth roots are defined by the formula:\n * <pre>\n *  <code>\n *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n *  </code>\n * </pre>\n * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n * are respectively the {@link #abs() modulus} and\n * {@link #getArgument() argument} of this complex number.\n * <br/>\n * If one or both parts of this complex number is NaN, a list with just\n * one element, {@link #NaN} is returned.\n * if neither part is NaN, but at least one part is infinite, the result\n * is a one-element list containing {@link #INF}.\n *\n * @param n Degree of root.\n * @return a List<Complex> of all {@code n}-th roots of {@code this}.\n * @throws NotPositiveException if {@code n <= 0}.\n * @since 2.0\n */\npublic List<Complex> nthRoot(int n) throws NotPositiveException {\n\n    if (n <= 0) {\n        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                                       n);\n    }\n\n    final List<Complex> result = new ArrayList<Complex>();\n\n    if (isNaN()) {\n        result.add(NaN);\n        return result;\n    }\n    if (isInfinite()) {\n        result.add(INF);\n        return result;\n    }\n\n    // nth root of abs -- faster / more accurate to use a solver here?\n    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n    // Compute nth roots of complex number with k = 0, 1, ... n-1\n    final double nthPhi = getArgument() / n;\n    final double slice = 2 * FastMath.PI / n;\n    double innerPart = nthPhi;\n    for (int k = 0; k < n ; k++) {\n        // inner part\n        final double realPart = nthRootOfAbs *  FastMath.cos(innerPart);\n        final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n        result.add(createComplex(realPart, imaginaryPart));\n        innerPart += slice;\n    }\n\n    return result;\n}\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -4.536227787823928,
      "mean_entropy": -0.008510746318619002
    },
    {
      "patch": "\n    public List<Complex> nthRoot(int n) throws NotPositiveException {\n\n        if (n <= 0) {\n            throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                                           n);\n        }\n\n        final List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN()) {\n            result.add(Complex.NaN);\n            return result;\n        }\n        if (isInfinite()) {\n            result.add(Complex.INF);\n            return result;\n        }\n\n        // nth root of abs -- faster / more accurate to use a solver here?\n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\n        final double nthPhi = getArgument() / n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n            // inner part\n            final double realPart = nthRootOfAbs * FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math3.complex.ComplexTest::testReciprocalZero\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 10,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero",
        [
          "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero"
        ]
      ],
      "sum_entropy": -5.268697203098002,
      "mean_entropy": -0.01888421936594266
    }
  ],
  "Math_53": [
    {
      "patch": "\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN() ) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -4.759958087675071,
      "mean_entropy": -0.019999823897794415
    },
    {
      "patch": "\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n      * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n\n        return createComplex(getReal() - rhs.getReal(),\n            getImaginary() - rhs.getImaginary());\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -7.222958620453291,
      "mean_entropy": -0.029602289428087257
    },
    {
      "patch": "\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN()) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    }\n\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -5.5053006554373205,
      "mean_entropy": -0.023131515358980337
    },
    {
      "patch": "\n    public Complex subtract(Complex rhs) throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        \n        if (isNaN() || rhs.isNaN()) {\n            return Complex.NaN;\n        }\n\n        return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -9.062668366560139,
      "mean_entropy": -0.15625290287172652
    },
    {
      "patch": "\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN()) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -2.1262019263603706,
      "mean_entropy": -0.008971316144980467
    },
    {
      "patch": "\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN()) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -3.1885795673903705,
      "mean_entropy": -0.01334133710205176
    },
    {
      "patch": "\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n\n        return createComplex(getReal() - rhs.getReal(),\n            getImaginary() - rhs.getImaginary());\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -6.747691981836902,
      "mean_entropy": -0.02765447533539714
    },
    {
      "patch": "\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN()) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -3.1885795673903705,
      "mean_entropy": -0.01334133710205176
    },
    {
      "patch": "\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN()) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -3.1885795673903705,
      "mean_entropy": -0.01334133710205176
    },
    {
      "patch": "\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN()) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -3.1885795673903705,
      "mean_entropy": -0.01334133710205176
    },
    {
      "patch": "\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN()) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -2.1262019263603706,
      "mean_entropy": -0.008971316144980467
    },
    {
      "patch": "\n/**\n * Return the difference between this complex number and the given complex\n * number.\n * <p>\n * Uses the definitional formula\n * <pre>\n * (a + bi) - (c + di) = (a-c) + (b-d)i\n * </pre></p>\n * <p>\n * If either this or <code>rhs</code> has a NaN value in either part,\n * {@link #NaN} is returned; otherwise infinite and NaN values are\n * returned in the parts of the result according to the rules for\n * {@link java.lang.Double} arithmetic. </p>\n *\n * @param rhs the other complex number\n * @return the complex number difference\n * @throws NullArgumentException if <code>rhs</code> is null\n */\npublic Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    if (isNaN || rhs.isNaN()) {\n        return NaN;\n    }\n\n    return createComplex(real - rhs.getReal(),\n        imaginary - rhs.getImaginary());\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -4.262592604199207,
      "mean_entropy": -0.019643283890318927
    },
    {
      "patch": "\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.complex.ComplexTest::testAddNaN\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 9,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.complex.ComplexTest::testAddNaN",
        [
          "org.apache.commons.math.complex.ComplexTest::testAddNaN"
        ]
      ],
      "sum_entropy": -3.7294531588846582,
      "mean_entropy": -0.015669971255817892
    }
  ],
  "Math_56": [],
  "Math_75": [
    {
      "patch": "\n/**\n * Returns the cumulative percentage of values less than or equal to v\n * (as a proportion between 0 and 1).\n * <p>\n * Returns <code>Double.NaN</code> if no values have been added.\n * Returns 0 if at least one value has been added, but v is not comparable\n * to the values set.</p>\n *\n * @param v the value to lookup\n * @return the proportion of values less than or equal to v\n * @deprecated replaced by {@link #getCumPct(Comparable)} as of 2.0\n */\n@Deprecated\npublic double getCumPct(Object v) {\n    return getCumPct((Comparable<?>) v);\n}\n\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testPcts\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testPcts",
        [
          "org.apache.commons.math.stat.FrequencyTest::testPcts"
        ]
      ],
      "sum_entropy": -4.038488584176938,
      "mean_entropy": -0.02674495751110555
    },
    {
      "patch": "\n/**\n * Returns the cumulative percentage of values less than or equal to v\n * (as a proportion between 0 and 1).\n * <p>\n * Returns <code>Double.NaN</code> if no values have been added.\n * Returns 0 if at least one value has been added, but v is not comparable\n * to the values set.</p>\n *\n * @param v the value to lookup\n * @return the proportion of values less than or equal to v\n * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n */\n@Deprecated\npublic double getCumPct(Object v) {\n    return getPct((Comparable<?>) v);\n}\n\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testPcts\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testPcts",
        [
          "org.apache.commons.math.stat.FrequencyTest::testPcts"
        ]
      ],
      "sum_entropy": -3.907727986150099,
      "mean_entropy": -0.026403567473987154
    },
    {
      "patch": "\n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.\n     * Returns 0 if at least one value has been added, but v is not comparable\n     * to the values set.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     * @deprecated replaced by {@link #getCumPct(Comparable)} as of 2.0\n     */\n    @Deprecated\n    public double getCumPct(Object v) {\n        return getCumPct((Comparable<?>) v);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testPcts\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testPcts",
        [
          "org.apache.commons.math.stat.FrequencyTest::testPcts"
        ]
      ],
      "sum_entropy": -1.888950944348859,
      "mean_entropy": -0.0115179935631028
    },
    {
      "patch": "\n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.\n     * Returns 0 if at least one value has been added, but v is not comparable\n     * to the values set.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n     */\n    @Deprecated\n    public double getCumPct(Object v) {\n        return getCumPct((Comparable<?>) v);\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testPcts\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testPcts",
        [
          "org.apache.commons.math.stat.FrequencyTest::testPcts"
        ]
      ],
      "sum_entropy": -3.421280725481741,
      "mean_entropy": -0.02098945230356896
    },
    {
      "patch": "\n/**\n * Returns the cumulative percentage of values less than or equal to v\n * (as a proportion between 0 and 1).\n * <p>\n * Returns <code>Double.NaN</code> if no values have been added.\n * Returns 0 if at least one value has been added, but v is not comparable\n * to the values set.</p>\n *\n * @param v the value to lookup\n * @return the proportion of values less than or equal to v\n * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n */\n@Deprecated\npublic double getCumPct(Object v) {\n    return getPct((Comparable<?>) v);\n}\n\n",
      "index": 20,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testPcts\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testPcts",
        [
          "org.apache.commons.math.stat.FrequencyTest::testPcts"
        ]
      ],
      "sum_entropy": -2.927359732257441,
      "mean_entropy": -0.019779457650388115
    }
  ],
  "Math_89": [
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v){\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must implement Comparable interface.\");\n        }\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -6.602749394278643,
      "mean_entropy": -0.027171808206907996
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v){\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must be comparable.\");\n        }\n\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -5.7720920771484865,
      "mean_entropy": -0.023851620153506142
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v){\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must be comparable.\");\n        }\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -4.836586918873886,
      "mean_entropy": -0.019985896358983
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v){\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must be comparable.\");\n        }\n\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 4,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -5.7720920771484865,
      "mean_entropy": -0.023851620153506142
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v) {\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must implement Comparable interface.\");\n        }\n\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 5,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -9.38748041763085,
      "mean_entropy": -0.03847328040012644
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v) {\n        if (!(v instanceof Comparable<?>)) {\n            throw new IllegalArgumentException(\"Value must be comparable.\");\n        }\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            // TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -8.446395551847923,
      "mean_entropy": -0.03475882943147293
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v) {\n        if (!(v instanceof Comparable<?>)) {\n            throw new IllegalArgumentException(\"Value must be Comparable.\");\n        }\n\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -7.974135239202082,
      "mean_entropy": -0.032680882127877384
    },
    {
      "patch": "\n/**\n * Adds 1 to the frequency count for v.\n * <p>\n * If other objects have already been added to this Frequency, v must\n * be comparable to those that have already been added.\n * </p>\n * \n * @param v the value to add.\n * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n */\npublic void addValue(Comparable<?> v) {\n    if (!(v instanceof Comparable)) {\n        throw new IllegalArgumentException(\"Value must be Comparable.\");\n    }\n    \n    Object obj = v;\n    if (v instanceof Integer) {\n        obj = Long.valueOf(((Integer) v).longValue());\n    }\n    \n    try {\n        Long count = (Long) freqTable.get(obj);\n        if (count == null) {\n            freqTable.put(obj, Long.valueOf(1));\n        } else {\n            freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n        }\n    } catch (ClassCastException ex) {   \n        // TreeMap will throw ClassCastException if v is not comparable\n        throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n    }\n}\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -8.687776169322795,
      "mean_entropy": -0.03744731107466722
    },
    {
      "patch": "\n/**\n * Adds 1 to the frequency count for v.\n * <p>\n * If other objects have already been added to this Frequency, v must\n * be comparable to those that have already been added.\n * </p>\n * \n * @param v the value to add.\n * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n */\npublic void addValue(Comparable<?> v) {\n    if (!(v instanceof Comparable)) {\n        throw new IllegalArgumentException(\"Value must be a Comparable object.\");\n    }\n\n    Object obj = v;\n    if (v instanceof Integer) {\n        obj = Long.valueOf(((Integer) v).longValue());\n    }\n    try {\n        Long count = (Long) freqTable.get(obj);\n        if (count == null) {\n            freqTable.put(obj, Long.valueOf(1));\n        } else {\n            freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n        }\n    } catch (ClassCastException ex) {\n        // TreeMap will throw ClassCastException if v is not comparable\n        throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n    }\n}\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -8.738808105514089,
      "mean_entropy": -0.03783033811910861
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v) {\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must implement Comparable.\");\n        }\n\n        Object obj = v;\n        if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());\n        }\n\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -8.4561076199277,
      "mean_entropy": -0.03708819131547237
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v) {\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must implement Comparable interface.\");\n        }\n        \n        Object obj = v;\n        if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());\n        }\n        \n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            // TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -7.032085718071388,
      "mean_entropy": -0.028702390686005663
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v){\n        if(!(v instanceof Comparable)){\n            throw new IllegalArgumentException(\"Value must be Comparable.\");\n        }\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -7.544529550195131,
      "mean_entropy": -0.03130510186802959
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v) {\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must be comparable.\");\n        }\n\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -8.80195718370168,
      "mean_entropy": -0.038436494251972396
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v if v is Comparable.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v){\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must be Comparable.\");\n        }\n\n        Object obj = v;\n        if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());\n        }\n        \n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -10.791854225895596,
      "mean_entropy": -0.043691717513747355
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     *\n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v) {\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must be Comparable.\");\n        }\n\n        Object obj = v;\n        if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());\n        }\n        \n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {\n            // TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -8.17196133546849,
      "mean_entropy": -0.03390855325920535
    },
    {
      "patch": "\n    public void addValue(Comparable<?> v) {\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must be Comparable.\");\n        }\n\n        Comparable<?> obj = v;\n        if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());\n        }\n\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -8.899700540530894,
      "mean_entropy": -0.062235668115600655
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v){\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must be comparable.\");\n        }\n        \n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        \n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -6.1200031066312786,
      "mean_entropy": -0.025081979945210157
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v) {\n        if (!(v instanceof Comparable)) {\n            throw new IllegalArgumentException(\"Value must be Comparable.\");\n        }\n\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -6.514681764294183,
      "mean_entropy": -0.02680938997651927
    },
    {
      "patch": "\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n    public void addValue(Comparable<?> v) {\n        if (!(v instanceof Comparable<?>)) {\n            throw new IllegalArgumentException(\"Value must implement Comparable interface.\");\n        }\n\n        Object obj = v;\n        if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());\n        }\n        \n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            // TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.stat.FrequencyTest::testAddNonComparable\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 1,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable",
        [
          "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable"
        ]
      ],
      "sum_entropy": -9.812857967910677,
      "mean_entropy": -0.040052481501676236
    }
  ],
  "Math_97": [
    {
      "patch": "\n    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        if (Math.abs(yMin) <= functionValueAccuracy || yMin == 0) {\n            setResult(min, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        if (Math.abs(yMax) <= functionValueAccuracy || yMax == 0) {\n            setResult(max, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints",
        [
          "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints"
        ]
      ],
      "sum_entropy": -6.180406373598275,
      "mean_entropy": -0.010729872176385893
    },
    {
      "patch": "\n    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        \n        if (yMin == 0 || yMax == 0) {\n            return 0;\n        }\n\n        if (yMin * yMax >= 0) {\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                      \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints",
        [
          "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints"
        ]
      ],
      "sum_entropy": -10.242980778952072,
      "mean_entropy": -0.017479489383877257
    },
    {
      "patch": "\n    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        if (yMin == 0 || yMax == 0) {\n            return 0;\n        }\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints",
        [
          "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints"
        ]
      ],
      "sum_entropy": -7.808232503466016,
      "mean_entropy": -0.013256761465986444
    },
    {
      "patch": "\n    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max - initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        if (Math.abs(yMin) <= functionValueAccuracy || yMin == 0) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        if (Math.abs(yMax) <= functionValueAccuracy || yMax == 0) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints",
        [
          "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints"
        ]
      ],
      "sum_entropy": -5.835971015917428,
      "mean_entropy": -0.01009683566767721
    },
    {
      "patch": "\n    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy || yMin == 0) {\n            setResult(min, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy || yMax == 0) {\n            setResult(max, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints",
        [
          "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints"
        ]
      ],
      "sum_entropy": -5.9812359801817,
      "mean_entropy": -0.010384090243371008
    },
    {
      "patch": "\n    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        if (Math.abs(yMin) <= functionValueAccuracy || yMin == 0 || yMax == 0) {\n            setResult(min, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n    }\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints",
        [
          "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints"
        ]
      ],
      "sum_entropy": -6.6421060438009825,
      "mean_entropy": -0.01153143410382115
    },
    {
      "patch": "\n    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        if (Math.abs(yMin) <= functionValueAccuracy || yMin == 0 || yMax == 0) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints",
        [
          "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints"
        ]
      ],
      "sum_entropy": -7.166161013920287,
      "mean_entropy": -0.01239820244622887
    },
    {
      "patch": "\n    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max - initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        if (Math.abs(yMin) <= functionValueAccuracy || yMin == 0) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        if (Math.abs(yMax) <= functionValueAccuracy || yMax == 0) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints",
        [
          "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints"
        ]
      ],
      "sum_entropy": -7.074326479989735,
      "mean_entropy": -0.012239319169532414
    },
    {
      "patch": "\n/**\n * Find a zero in the given interval with an initial guess.\n * <p>Throws <code>IllegalArgumentException</code> if the values of the\n * function at the three points have the same sign (note that it is\n * allowed to have endpoints with the same sign if the initial point has\n * opposite sign function-wise).</p>\n * \n * @param min the lower bound for the interval.\n * @param max the upper bound for the interval.\n * @param initial the start value to use (must be set to min if no\n * initial point is known).\n * @return the value where the function is zero\n * @throws MaxIterationsExceededException the maximum iteration count\n * is exceeded \n * @throws FunctionEvaluationException if an error occurs evaluating\n *  the function\n * @throws IllegalArgumentException if initial is not between min and max\n * (even if it <em>is</em> a root)\n */\npublic double solve(double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    if (((initial - min) * (max - initial)) < 0) {\n        throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                  \" interval.\" + \"  Initial: \" + initial +\n                  \"  Endpoints: [\" + min + \",\" + max + \"]\");\n    }\n\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy || yMin == 0) {\n        setResult(yMin, 0);\n        return result;\n    }\n\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(min, yMin, initial, yInitial, min, yMin);\n    }\n\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy || yMax == 0) {\n        setResult(yMax, 0);\n        return result;\n    }\n\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(initial, yInitial, max, yMax, initial, yInitial);\n    }\n\n    // full Brent algorithm starting with provided initial guess\n    return solve(min, yMin, max, yMax, initial, yInitial);\n\n}\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 18,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints",
        [
          "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints"
        ]
      ],
      "sum_entropy": -7.614928816826651,
      "mean_entropy": -0.013671326421591832
    }
  ],
  "Time_15": [
    {
      "patch": "\n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        try {\n            long val = Math.multiplyExact(val1, val2);\n            return Math.toIntExact(val);\n        } catch (ArithmeticException e) {\n            throw new ArithmeticException(\"Multiplication overflow occurred\");\n        }\n    }\n\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -4.38133673577313,
      "mean_entropy": -0.03221571129244948
    },
    {
      "patch": "\n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        long val = Math.multiplyExact(val1, val2);\n        return Math.toIntExact(val);\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -2.1432323667804303,
      "mean_entropy": -0.019844744136855837
    },
    {
      "patch": "\n/**\n * Multiply two values to return an int throwing an exception if overflow occurs.\n * \n * @param val1  the first value\n * @param val2  the second value\n * @return the new total\n * @throws ArithmeticException if the value is too big or too small\n */\npublic static int safeMultiplyToInt(long val1, long val2) {\n    try {\n        return Math.multiplyExact(Math.toIntExact(val1), Math.toIntExact(val2));\n    } catch (ArithmeticException e) {\n        throw new ArithmeticException(\"Multiplication overflows int range\");\n    }\n}\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -7.832500891064892,
      "mean_entropy": -0.0636788690330479
    },
    {
      "patch": "\n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        long val = Math.multiplyExact(val1, val2);\n        return Math.toIntExact(val);\n    }\n",
      "index": 7,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -2.1432323667804303,
      "mean_entropy": -0.019844744136855837
    },
    {
      "patch": "\n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        long val = Math.multiplyExact(val1, val2);\n        return Math.toIntExact(val);\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -2.1432323667804303,
      "mean_entropy": -0.019844744136855837
    },
    {
      "patch": "\n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        if (val2 != 0 && (val1 * val2) / val2 != val1) {\n            throw new ArithmeticException(\"Multiplication overflow\");\n        }\n        return (int) (val1 * val2);\n    }\n\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -6.362401334192833,
      "mean_entropy": -0.04610435749415096
    },
    {
      "patch": "\n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        long val = Math.multiplyExact(val1, val2);\n        return Math.toIntExact(val);\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -2.1432323667804303,
      "mean_entropy": -0.019844744136855837
    },
    {
      "patch": "\n/**\n * Multiply two values to return an int throwing an exception if overflow occurs.\n * \n * @param val1  the first value\n * @param val2  the second value\n * @return the new total\n * @throws ArithmeticException if the value is too big or too small\n */\npublic static int safeMultiplyToInt(long val1, long val2) {\n    try {\n        Math.multiplyExact(val1, val2);\n    } catch (ArithmeticException e) {\n        throw new ArithmeticException(\"Overflow occurred during multiplication\");\n    }\n    return (int) (val1 * val2);\n}\n",
      "index": 11,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -4.860163599608889,
      "mean_entropy": -0.038572726981022924
    },
    {
      "patch": "\n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        try {\n            Math.multiplyExact(val1, val2);\n        } catch (ArithmeticException e) {\n            throw new ArithmeticException(\"Overflow occurred during multiplication\");\n        }\n        return (int) (val1 * val2);\n    }\n\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -4.87046449518223,
      "mean_entropy": -0.035293220979581374
    },
    {
      "patch": "\n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     *\n     * @param val1 the first value\n     * @param val2 the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        try {\n            long val = Math.multiplyExact(val1, val2);\n            return Math.toIntExact(val);\n        } catch (ArithmeticException e) {\n            throw new ArithmeticException(\"Multiplication overflow occurred\");\n        }\n    }\n\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -7.298334339925185,
      "mean_entropy": -0.05487469428515177
    },
    {
      "patch": "\n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        long val = Math.multiplyExact(val1, val2);\n        return Math.toIntExact(val);\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -2.16817644562752,
      "mean_entropy": -0.020075707829884444
    },
    {
      "patch": "\n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        long val = FieldUtils.safeMultiply(val1, val2);\n        if (val > Integer.MAX_VALUE || val < Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"Integer overflow\");\n        }\n        return (int)val;\n    }\n\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -8.98632799645784,
      "mean_entropy": -0.06511831881491188
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if ((val1 != 0 && total / val1 != val2) || (val1 == Long.MIN_VALUE && val2 == -1) || (val2 == Long.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 1,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -1.8559345612679692,
      "mean_entropy": -0.008104517734794625
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if (val1 != 0 && total / val1 != val2 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 2,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -3.3032274713613687,
      "mean_entropy": -0.014681010983828305
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        if ((val1 == Long.MIN_VALUE && val2 == -1) || (val2 == Long.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 3,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -4.190158012261834,
      "mean_entropy": -0.01662761115976918
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if (val1 != 0 && total / val1 != val2 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 6,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -3.3032274713613687,
      "mean_entropy": -0.014681010983828305
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if ((val1 != 0 && total / val2 != val1) || (val1 == Long.MIN_VALUE && val2 == -1) || (val2 == Long.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 8,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -3.446104716205068,
      "mean_entropy": -0.015048492210502482
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if (val1 != 0 && total / val1 != val2 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 9,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -3.3032274713613687,
      "mean_entropy": -0.014681010983828305
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if ((val1 != 0 && total / val1 != val2) || (val1 == Long.MIN_VALUE && val2 == -1) || (val2 == Long.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 10,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -1.8559345612679692,
      "mean_entropy": -0.008104517734794625
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1 || val1 == 1 || val1 == 0 || val2 == 0) {\n            return val1 * val2;\n        }\n\n        if ((val1 == Long.MIN_VALUE && val2 == -1) || (val2 == Long.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n\n        return total;\n    }\n",
      "index": 12,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -7.166767635254803,
      "mean_entropy": -0.030758659378775977
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if ((val1 != 0 && total / val1 != val2) || (val1 == Long.MIN_VALUE && val2 == -1) || (val2 == Long.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -1.8559345612679692,
      "mean_entropy": -0.008104517734794625
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if ((val1 != 0 && total / val1 != val2) || (val1 == Long.MIN_VALUE && val2 == -1) || (val2 == Long.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -1.8559345612679692,
      "mean_entropy": -0.008104517734794625
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if ((val1 != 0 && total / val1 != val2) || (val1 == Long.MIN_VALUE && val2 == -1) || (val2 == Long.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -1.9074592772545484,
      "mean_entropy": -0.008329516494561347
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if (val1 != 0 && total / val1 != val2 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 17,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -3.562767228796308,
      "mean_entropy": -0.01583452101687248
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if ((val1 != 0 && total / val2 != val1) || (val1 == Long.MIN_VALUE && val2 == -1) || (val2 == Long.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 18,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -3.429264089050199,
      "mean_entropy": -0.014974952353931
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if ((val1 != 0 && total / val1 != val2) || (val1 == Long.MIN_VALUE && val2 == -1) || (val2 == Long.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n",
      "index": 19,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -1.9074592772545484,
      "mean_entropy": -0.008329516494561347
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static int safeMultiply(int val1, int val2) {\n        if ((val2 == -1 && val1 == Integer.MIN_VALUE) || (val1 == -1 && val2 == Integer.MIN_VALUE)) {\n            throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        long total = (long) val1 * (long) val2;\n        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        return (int) total;\n    }\n",
      "index": 13,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -5.784865094774796,
      "mean_entropy": -0.026658364492049752
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static int safeMultiply(int val1, int val2) {\n        if ((long) val1 * val2 != (int) ((long) val1 * val2)) {\n            throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        return val1 * val2;\n    }\n",
      "index": 14,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -7.897442123353914,
      "mean_entropy": -0.052300941214264325
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static int safeMultiply(int val1, int val2) {\n        if ((val1 == Integer.MIN_VALUE && val2 == -1) || (val2 == Integer.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        \n        long total = (long) val1 * (long) val2;\n        \n        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        \n        return (int) total;\n    }\n",
      "index": 15,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -5.923327228527992,
      "mean_entropy": -0.026924214675127234
    },
    {
      "patch": "\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static int safeMultiply(int val1, int val2) {\n        if ((val1 == Integer.MIN_VALUE && val2 == -1) || (val2 == Integer.MIN_VALUE && val1 == -1)) {\n            throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        long total = (long) val1 * (long) val2;\n        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        return (int) total;\n    }\n",
      "index": 16,
      "validation": "wrong",
      "validation_wo": "plausible",
      "errors": [
        "Failing tests: 1\n  - org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt\n",
        "Running ant (compile.tests)................................................ OK\nRunning ant (run.dev.tests)................................................ OK\n"
      ],
      "total_trigger": 1,
      "passing_trigger": 0,
      "total_relevant": 108,
      "failing_relevant": 1,
      "passing_tests": [],
      "failing_tests": [
        "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt",
        [
          "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt"
        ]
      ],
      "sum_entropy": -4.9706097578178134,
      "mean_entropy": -0.022906035750312505
    }
  ],
  "Time_17": []
}